{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ODMantic Documentation : https://art049.github.io/odmantic/ ODMantic is an Object Document Mapper (a kind of ORM but for NoSQL databases) for MongoDB based on standard python type hints. It's built on top of pydantic for model definition and validation. Core features: Simple : define your model by typing your fields using python types, build queries using python comparison operators Developer experience : field/method autocompletion, type hints, data validation, perform database operations in a functional way Fully typed : leverage static analysis to reduce runtime issues AsyncIO : works well with ASGI frameworks ( FastAPI , Starlette , ...) Serialization : built in JSON serialization and JSON schema generation Requirements \u00b6 Python : 3.6 and later (tested against 3.6, 3.7, 3.8 and 3.9) MongoDB : 4.0 and later Two direct dependencies: pydantic : makes data validation and schema definition both handy and elegant. motor : an asyncio MongoDB driver officially developed by the MongoDB team. Installation \u00b6 pip install odmantic Example \u00b6 To enjoy an async context without any code boilerplate, you can reproduce the following steps using the AsyncIO REPL (only for Python 3.8+). python3.8 -m asyncio If you are using an earlier version of Python you can use IPython which provide an Autoawait feature (starting from Python 3.6). Define your first model \u00b6 from typing import Optional from odmantic import Field , Model class Publisher ( Model ): name : str founded : int = Field ( ge = 1440 ) location : Optional [ str ] = None By defining the Publisher class, we've just created an ODMantic model \ud83c\udf89. In this example, the model will represent book publishers. This model contains three fields: name : This is the name of the Publisher. This is a simple string field without any specific validation but it will be required to build a new Publisher. founded : This is the year of foundation of the Publisher. Since the printing press has been invented in 1440, it would be handy to allow only values above 1440. The ge keyword argument passed to the Field is exactly doing this. The model will require a founded value greater or equal than 1440. location : This field will contain the country code of the Publisher. Defining this field as Optional with a None default value makes it a non required field that will be set automatically when not specified. The collection name has been defined by ODMantic as well. In this case it will be publisher . Create some instances \u00b6 instances = [ Publisher ( name = \"HarperCollins\" , founded = 1989 , location = \"US\" ), Publisher ( name = \"Hachette Livre\" , founded = 1826 , location = \"FR\" ), Publisher ( name = \"Lulu\" , founded = 2002 ) ] We defined three instances of the Publisher model. They all have a name property as it was required. All the foundations years are later than 1440. The last publisher has no location specified so by default this field is set to None (it will be stored as null in the database). For now, those instances only exists locally. We will persist them in a database in the next step. Populate the database with your instances \u00b6 For the next steps, you'll need to start a local MongoDB server.The easiest way is to use docker. Simply run the next command in a terminal (closing the terminal will terminate the MongoDB instance and remove the container). docker run --rm --net = host mongo First, let's connect to the database using the engine. In ODMantic, every database operation is performed using the engine object. from odmantic import AIOEngine engine = AIOEngine () By default, the AIOEngine (stands for AsyncIOEngine) automatically tries to connect to a MongoDB instance running locally (on port 27017). Since we didn't provide any database name, it will use the database named test by default. The next step is to persist the instances we created before. We can perform this operation using the AIOEngine.save_all method. await engine . save_all ( instances ) Most of the engine I/O methods are asynchronous, hence the await keyword used here. Once the operation is complete, we should be able to see our created documents in the database. You can use Compass or RoboMongo if you'd like to have a graphical interface. Another possibility is to use mongo CLI directly: mongo --eval \"db.publisher.find({})\" Output: connecting to: mongodb:// 127.0 . 0.1 : 27017 { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54c9\" ) , \"founded\" : 1989 , \"location\" : \"US\" , \"name\" : \"HarperCollins\" } , { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54ca\" ) , \"founded\" : 1826 , \"location\" : \"FR\" , \"name\" : \"Hachette Livre\" } , { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54cb\" ) , \"founded\" : 2002 , \"location\" : null , \"name\" : \"Lulu\" } The created instances are stored in the test database under the publisher collection. We can see that an _id field has been added to each document. MongoDB need this field to act as a primary key. Actually, this field is added by ODMantic and you can access it under the name id . print ( instances [ 0 ] . id ) #> ObjectId(\"5f67b331514d6855bc5c54c9\") Find instances matching a criteria \u00b6 Since we now have some documents in the database, we can start building some queries. First, let's find publishers created before the 2000s: early_publishers = await engine . find ( Publisher , Publisher . founded <= 2000 ) print ( early_publishers ) #> [Publisher(name=\"HarperCollins\", founded=1989, location=\"US), #> Publisher(name=\"Hachette Livre\", founded=1826, location=\"FR\")] Here, we called the engine.find method. The first argument we need to specify is the Model class we want to query on (in our case Publisher ). The second argument is the actual query. Similarly to SQLAlchemy , you can build ODMantic queries using the regular python operators. When awaited, the engine.find method will return the list of matching instances stored in the database. Another possibility is to query for at most one instance. For example, if we want to retrieve a publisher from Canada (CA): ca_publisher = await engine . find_one ( Publisher , Publisher . location == \"CA\" ) print ( ca_publisher ) #> None Here the result is None because no matching instances have been found in the database. The engine.find_one method returns an instance if one exists in the database otherwise, it will return None . Modify an instance \u00b6 Finally, let's edit some instances. For example, we can set the location for the publisher named Lulu . First, we need to gather the instance from the database: lulu = await engine . find_one ( Publisher , Publisher . name == \"Lulu\" ) print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=None) We still have the same instance, with no location set. We can change this field: lulu . location = \"US\" print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=\"US) The location has been changed locally but the last step to persist this change is to save the document: await engine . save ( lulu ) We can now check the database state: mongo --eval \"db.publisher.find({name: 'Lulu'})\" Output: connecting to: mongodb:// 127.0 . 0.1 : 27017 { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54cb\" ) , \"founded\" : 2002 , \"location\" : \"US\" , \"name\" : \"Lulu\" } The document have been successfully updated ! Now, what if we would like to change the foundation date with an invalid one (before 1440) ? lulu . founded = 1000 #> ValidationError: 1 validation error for Publisher #> founded #> ensure this value is greater than 1440 #> (type=value_error.number.not_gt; limit_value=1440) This will raise an exception as it's not matching the model definition. The raised exception is actually a ValidationError created by from pydantic . Next steps \u00b6 If you already have experience with Pydantic and FastAPI, the Usage with FastAPI example might be interesting for you. Otherwise, to get started on more advanced practices like relations and building more advanced queries, you can directly check the other sections of the documentation . If you wish to contribute to the project (Thank you! ), you can have a look to the Contributing section of the documentation. License \u00b6 This project is licensed under the terms of the ISC license .","title":"Overview"},{"location":"#requirements","text":"Python : 3.6 and later (tested against 3.6, 3.7, 3.8 and 3.9) MongoDB : 4.0 and later Two direct dependencies: pydantic : makes data validation and schema definition both handy and elegant. motor : an asyncio MongoDB driver officially developed by the MongoDB team.","title":"Requirements"},{"location":"#installation","text":"pip install odmantic","title":"Installation"},{"location":"#example","text":"To enjoy an async context without any code boilerplate, you can reproduce the following steps using the AsyncIO REPL (only for Python 3.8+). python3.8 -m asyncio If you are using an earlier version of Python you can use IPython which provide an Autoawait feature (starting from Python 3.6).","title":"Example"},{"location":"#define-your-first-model","text":"from typing import Optional from odmantic import Field , Model class Publisher ( Model ): name : str founded : int = Field ( ge = 1440 ) location : Optional [ str ] = None By defining the Publisher class, we've just created an ODMantic model \ud83c\udf89. In this example, the model will represent book publishers. This model contains three fields: name : This is the name of the Publisher. This is a simple string field without any specific validation but it will be required to build a new Publisher. founded : This is the year of foundation of the Publisher. Since the printing press has been invented in 1440, it would be handy to allow only values above 1440. The ge keyword argument passed to the Field is exactly doing this. The model will require a founded value greater or equal than 1440. location : This field will contain the country code of the Publisher. Defining this field as Optional with a None default value makes it a non required field that will be set automatically when not specified. The collection name has been defined by ODMantic as well. In this case it will be publisher .","title":"Define your first model"},{"location":"#create-some-instances","text":"instances = [ Publisher ( name = \"HarperCollins\" , founded = 1989 , location = \"US\" ), Publisher ( name = \"Hachette Livre\" , founded = 1826 , location = \"FR\" ), Publisher ( name = \"Lulu\" , founded = 2002 ) ] We defined three instances of the Publisher model. They all have a name property as it was required. All the foundations years are later than 1440. The last publisher has no location specified so by default this field is set to None (it will be stored as null in the database). For now, those instances only exists locally. We will persist them in a database in the next step.","title":"Create some instances"},{"location":"#populate-the-database-with-your-instances","text":"For the next steps, you'll need to start a local MongoDB server.The easiest way is to use docker. Simply run the next command in a terminal (closing the terminal will terminate the MongoDB instance and remove the container). docker run --rm --net = host mongo First, let's connect to the database using the engine. In ODMantic, every database operation is performed using the engine object. from odmantic import AIOEngine engine = AIOEngine () By default, the AIOEngine (stands for AsyncIOEngine) automatically tries to connect to a MongoDB instance running locally (on port 27017). Since we didn't provide any database name, it will use the database named test by default. The next step is to persist the instances we created before. We can perform this operation using the AIOEngine.save_all method. await engine . save_all ( instances ) Most of the engine I/O methods are asynchronous, hence the await keyword used here. Once the operation is complete, we should be able to see our created documents in the database. You can use Compass or RoboMongo if you'd like to have a graphical interface. Another possibility is to use mongo CLI directly: mongo --eval \"db.publisher.find({})\" Output: connecting to: mongodb:// 127.0 . 0.1 : 27017 { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54c9\" ) , \"founded\" : 1989 , \"location\" : \"US\" , \"name\" : \"HarperCollins\" } , { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54ca\" ) , \"founded\" : 1826 , \"location\" : \"FR\" , \"name\" : \"Hachette Livre\" } , { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54cb\" ) , \"founded\" : 2002 , \"location\" : null , \"name\" : \"Lulu\" } The created instances are stored in the test database under the publisher collection. We can see that an _id field has been added to each document. MongoDB need this field to act as a primary key. Actually, this field is added by ODMantic and you can access it under the name id . print ( instances [ 0 ] . id ) #> ObjectId(\"5f67b331514d6855bc5c54c9\")","title":"Populate the database with your instances"},{"location":"#find-instances-matching-a-criteria","text":"Since we now have some documents in the database, we can start building some queries. First, let's find publishers created before the 2000s: early_publishers = await engine . find ( Publisher , Publisher . founded <= 2000 ) print ( early_publishers ) #> [Publisher(name=\"HarperCollins\", founded=1989, location=\"US), #> Publisher(name=\"Hachette Livre\", founded=1826, location=\"FR\")] Here, we called the engine.find method. The first argument we need to specify is the Model class we want to query on (in our case Publisher ). The second argument is the actual query. Similarly to SQLAlchemy , you can build ODMantic queries using the regular python operators. When awaited, the engine.find method will return the list of matching instances stored in the database. Another possibility is to query for at most one instance. For example, if we want to retrieve a publisher from Canada (CA): ca_publisher = await engine . find_one ( Publisher , Publisher . location == \"CA\" ) print ( ca_publisher ) #> None Here the result is None because no matching instances have been found in the database. The engine.find_one method returns an instance if one exists in the database otherwise, it will return None .","title":"Find instances matching a criteria"},{"location":"#modify-an-instance","text":"Finally, let's edit some instances. For example, we can set the location for the publisher named Lulu . First, we need to gather the instance from the database: lulu = await engine . find_one ( Publisher , Publisher . name == \"Lulu\" ) print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=None) We still have the same instance, with no location set. We can change this field: lulu . location = \"US\" print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=\"US) The location has been changed locally but the last step to persist this change is to save the document: await engine . save ( lulu ) We can now check the database state: mongo --eval \"db.publisher.find({name: 'Lulu'})\" Output: connecting to: mongodb:// 127.0 . 0.1 : 27017 { \"_id\" : ObjectId( \"5f67b331514d6855bc5c54cb\" ) , \"founded\" : 2002 , \"location\" : \"US\" , \"name\" : \"Lulu\" } The document have been successfully updated ! Now, what if we would like to change the foundation date with an invalid one (before 1440) ? lulu . founded = 1000 #> ValidationError: 1 validation error for Publisher #> founded #> ensure this value is greater than 1440 #> (type=value_error.number.not_gt; limit_value=1440) This will raise an exception as it's not matching the model definition. The raised exception is actually a ValidationError created by from pydantic .","title":"Modify an instance"},{"location":"#next-steps","text":"If you already have experience with Pydantic and FastAPI, the Usage with FastAPI example might be interesting for you. Otherwise, to get started on more advanced practices like relations and building more advanced queries, you can directly check the other sections of the documentation . If you wish to contribute to the project (Thank you! ), you can have a look to the Contributing section of the documentation.","title":"Next steps"},{"location":"#license","text":"This project is licensed under the terms of the ISC license .","title":"License"},{"location":"changelog/","text":"Changelog \u00b6 The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased \u00b6 Use a Config class to configure models ( #37 by @art049 ) Deprecated \u00b6 Usage of __collection__ to customize the collection name. Prefer the collection Config option ( more details ) Added \u00b6 Integration with Pydantic Config class: It's now possible to define custom json_encoders on the Models Some other Config options provided by Pydantic are now available ( more details ) Support CPython 3.9 ( #32 by @art049 ) Unpin pydantic to support 1.7.0 ( #29 by @art049 ) 0.2.1 - 2020-10-25 \u00b6 Fixed \u00b6 Fix combined use of skip and limit with engine.find ( #25 by @art049 ) 0.2.0 - 2020-10-25 \u00b6 Deprecated \u00b6 Deprecate AIOEngineDependency to prefer a global engine object, more details ( #21 by @art049 ) Added \u00b6 Add sorting support ( #17 by @adriencaccia ) Support motor 2.3.0 ( #20 by @art049 ) Fixed \u00b6 Fix FastAPI usage with References ( #19 by @art049 ) Docs \u00b6 Adding a CONTRIBUTING.md file to the root directory with link to docs ( #8 by @sanders41 ) Raw Query Usage Documentation Fix ( #10 by @adeelsohailahmed ) Update Filtering to include Bitwise Operator Warning ( #24 by @adeelsohailahmed ) 0.1.0 - 2020-10-19 \u00b6 Initial Release \u00b6","title":"Changelog"},{"location":"changelog/#changelog","text":"The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"Use a Config class to configure models ( #37 by @art049 )","title":"Unreleased"},{"location":"changelog/#deprecated","text":"Usage of __collection__ to customize the collection name. Prefer the collection Config option ( more details )","title":"Deprecated"},{"location":"changelog/#added","text":"Integration with Pydantic Config class: It's now possible to define custom json_encoders on the Models Some other Config options provided by Pydantic are now available ( more details ) Support CPython 3.9 ( #32 by @art049 ) Unpin pydantic to support 1.7.0 ( #29 by @art049 )","title":"Added"},{"location":"changelog/#021-2020-10-25","text":"","title":"0.2.1 - 2020-10-25"},{"location":"changelog/#fixed","text":"Fix combined use of skip and limit with engine.find ( #25 by @art049 )","title":"Fixed"},{"location":"changelog/#020-2020-10-25","text":"","title":"0.2.0 - 2020-10-25"},{"location":"changelog/#deprecated_1","text":"Deprecate AIOEngineDependency to prefer a global engine object, more details ( #21 by @art049 )","title":"Deprecated"},{"location":"changelog/#added_1","text":"Add sorting support ( #17 by @adriencaccia ) Support motor 2.3.0 ( #20 by @art049 )","title":"Added"},{"location":"changelog/#fixed_1","text":"Fix FastAPI usage with References ( #19 by @art049 )","title":"Fixed"},{"location":"changelog/#docs","text":"Adding a CONTRIBUTING.md file to the root directory with link to docs ( #8 by @sanders41 ) Raw Query Usage Documentation Fix ( #10 by @adeelsohailahmed ) Update Filtering to include Bitwise Operator Warning ( #24 by @adeelsohailahmed )","title":"Docs"},{"location":"changelog/#010-2020-10-19","text":"","title":"0.1.0 - 2020-10-19"},{"location":"changelog/#initial-release","text":"","title":"Initial Release"},{"location":"contributing/","text":"Contributing \u00b6 Sharing feedback \u00b6 This project is still quite new and therefore having your feedback will really help to prioritize relevant feature developments . The easiest way to share feedback and discuss about the project is to join the Gitter chatroom . If you want to contribute (thanks a lot ! ), you can open an issue on Github. Before creating a non obvious (typo, documentation fix) Pull Request, please make sure to open an issue. Developing locally \u00b6 With the VSCode's devcontainer feature \u00b6 This feature will make the tools/environment installation very simple as you will develop in a container that has already been configured to run this project. Here are the steps: Clone the repository and open it with Visual Studio Code . Make sure that the Remote - Containers ( ms-vscode-remote.remote-containers ) extension is installed. Run the Remote-Container: Reopen in Container command (press Ctrl + Shift + P and then type the command). After the setup script completes, the environment is ready. You can start the local development . You can go to the development tasks section to see the available task commands. MongoDB container In this containerized development environment, a MongoDB instance should already be running as a part of the development docker-compose.yml file internally used by VSCode. Regular environment setup \u00b6 Installing the tools \u00b6 Git LFS : used to store documentation assets in the repository Docker : used to run a local MongoDB instance Task : task manager Installing python based development tools In order to install the devtools written in python, it's recommended to use pipx . python3 -m pip install --user pipx python3 -m pipx ensurepath Poetry : packaging system and dependency manager pipx install poetry tox : multi-environment test runner pipx install tox pre-commit : pre commit hook manager pipx install pre-commit Python versions If you want to test the project with multiple python versions, you'll need to install them manually. You can use pyenv to install them easily. # Install the versions pyenv install \"3.6.12\" pyenv install \"3.7.9\" pyenv install \"3.8.9\" pyenv install \"3.9.0\" # Make the versions available locally in the project pyenv local 3 .8.6 3 .7.9 3 .6.12 3 .9.0 Configuring the local environment \u00b6 task setup Running development tasks \u00b6 The following tasks are available for the project: task setup : Configure the development environment. task lint : Run the linting checks. task format : Format the code (and imports). task mongodb : Start the local MongoDB server. task test : Run the tests with the current version. task full-test : Run the tests against all supported versions. task coverage : Get the test coverage (xml and html) with the current version. task docs : Start the local documentation server.","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#sharing-feedback","text":"This project is still quite new and therefore having your feedback will really help to prioritize relevant feature developments . The easiest way to share feedback and discuss about the project is to join the Gitter chatroom . If you want to contribute (thanks a lot ! ), you can open an issue on Github. Before creating a non obvious (typo, documentation fix) Pull Request, please make sure to open an issue.","title":"Sharing feedback"},{"location":"contributing/#developing-locally","text":"","title":"Developing locally"},{"location":"contributing/#with-the-vscodes-devcontainer-feature","text":"This feature will make the tools/environment installation very simple as you will develop in a container that has already been configured to run this project. Here are the steps: Clone the repository and open it with Visual Studio Code . Make sure that the Remote - Containers ( ms-vscode-remote.remote-containers ) extension is installed. Run the Remote-Container: Reopen in Container command (press Ctrl + Shift + P and then type the command). After the setup script completes, the environment is ready. You can start the local development . You can go to the development tasks section to see the available task commands. MongoDB container In this containerized development environment, a MongoDB instance should already be running as a part of the development docker-compose.yml file internally used by VSCode.","title":"With the VSCode's devcontainer feature"},{"location":"contributing/#regular-environment-setup","text":"","title":"Regular environment setup"},{"location":"contributing/#installing-the-tools","text":"Git LFS : used to store documentation assets in the repository Docker : used to run a local MongoDB instance Task : task manager Installing python based development tools In order to install the devtools written in python, it's recommended to use pipx . python3 -m pip install --user pipx python3 -m pipx ensurepath Poetry : packaging system and dependency manager pipx install poetry tox : multi-environment test runner pipx install tox pre-commit : pre commit hook manager pipx install pre-commit Python versions If you want to test the project with multiple python versions, you'll need to install them manually. You can use pyenv to install them easily. # Install the versions pyenv install \"3.6.12\" pyenv install \"3.7.9\" pyenv install \"3.8.9\" pyenv install \"3.9.0\" # Make the versions available locally in the project pyenv local 3 .8.6 3 .7.9 3 .6.12 3 .9.0","title":"Installing the tools"},{"location":"contributing/#configuring-the-local-environment","text":"task setup","title":"Configuring the local environment"},{"location":"contributing/#running-development-tasks","text":"The following tasks are available for the project: task setup : Configure the development environment. task lint : Run the linting checks. task format : Format the code (and imports). task mongodb : Start the local MongoDB server. task test : Run the tests with the current version. task full-test : Run the tests against all supported versions. task coverage : Get the test coverage (xml and html) with the current version. task docs : Start the local documentation server.","title":"Running development tasks"},{"location":"engine/","text":"Engine \u00b6 Creating the engine \u00b6 In the previous examples, we created the engine using default parameters: MongoDB: running on localhost port 27017 Database name: test It's possible to provide a custom AsyncIOMotorClient to the [AIOEngine][odmantic.engine.AIOEngine] constructor. In the same way, the database name can be changed using the database keyword argument. 1 2 3 4 5 6 from motor.motor_asyncio import AsyncIOMotorClient from odmantic import AIOEngine client = AsyncIOMotorClient ( \"mongodb://localhost:27017/\" ) engine = AIOEngine ( motor_client = client , database = \"example_db\" ) For additional information about the MongoDB connection strings, see this section of the MongoDB documentation. Usage with DNS SRV records If you decide to use the DNS Seed List Connection Format (i.e mongodb+srv://... ), you will need to install the dnspython package. Create \u00b6 There are two ways of persisting instances to the database (i.e creating new documents): [AIOEngine.save][odmantic.engine.AIOEngine.save]: to save a single instance [AIOEngine.save_all][odmantic.engine.AIOEngine.save]: to save multiple instances at once 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () leeroy = Player ( name = \"Leeroy Jenkins\" , game = \"World of Warcraft\" ) await engine . save ( leeroy ) players = [ Player ( name = \"Shroud\" , game = \"Counter-Strike\" ), Player ( name = \"Serral\" , game = \"Starcraft\" ), Player ( name = \"TLO\" , game = \"Starcraft\" ), ] await engine . save_all ( players ) Resulting documents in the player collection { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a46\" ) , \"game\" : \"World of Warcraft\" , \"name\" : \"Leeroy Jenkins\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a47\" ) , \"game\" : \"Counter-Strike\" , \"name\" : \"Shroud\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a49\" ) , \"game\" : \"Starcraft\" , \"name\" : \"TLO\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a48\" ) , \"game\" : \"Starcraft\" , \"name\" : \"Serral\" } Referenced instances When calling [AIOEngine.save][odmantic.engine.AIOEngine.save] or [AIOEngine.save_all][odmantic.engine.AIOEngine.save], the referenced models will be persisted as well. Upsert behavior The save and save_all methods behave as upsert operations ( more details ). Hence, you might overwrite documents if you save instances with an existing primary key already existing in the database. Read \u00b6 Examples database content The next examples will consider that you have a player collection populated with the documents previously created. Fetch a single instance \u00b6 As with regular MongoDB driver, you can use the [AIOEngine.find_one][odmantic.engine.AIOEngine.find_one] method to get at most one instance of a specific Model. This method will either return an instance matching the specified criteriums or None if no instances have been found. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player = await engine . find_one ( Player , Player . name == \"Serral\" ) print ( repr ( player )) #> Player(id=ObjectId(...), name=\"Serral\", game=\"Starcraft\") another_player = await engine . find_one ( Player , Player . name == \"Player_Not_Stored_In_Database\" ) print ( another_player ) #> None Fetch using sort We can use the sort parameter to fetch the Player instance with the first name in ascending order: await engine . find_one ( Player , sort = Player . name ) Find out more on sort in the dedicated section . Fetch multiple instances \u00b6 To get more than one instance from the database at once, you can use the [AIOEngine.find][odmantic.engine.AIOEngine.find] method. This method will return an [AIOCursor][odmantic.engine.AIOCursor] object, that can be used in two different ways. Usage as an async iterator \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () async for player in engine . find ( Player , Player . game == \"Starcraft\" ): print ( repr ( player )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') #> Player(id=ObjectId(...), name='Serral', game='Starcraft') Ordering instances The sort parameter allows to order the query in ascending or descending order on a single or multiple fields. engine . find ( Player , sort = ( Player . name , Player . game . desc ())) Find out more on sort in the dedicated section . Usage as an awaitable \u00b6 Even if the async iterator usage should be preferred, in some cases it might be required to gather all the documents from the database before processing them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () players = await engine . find ( Player , Player . game != \"Starcraft\" ) print ( players ) #> [ #> Player(id=ObjectId(...), name=\"Leeroy Jenkins\", game=\"World of Warcraft\"), #> Player(id=ObjectId(...), name=\"Shroud\", game=\"Counter-Strike\"), #> ] Pagination You can as well use the skip and limit keyword arguments when using [AIOEngine.find][odmantic.engine.AIOEngine.find], respectively to skip a specified number of instances and to limit the number of fetched instances. Referenced instances When calling [AIOEngine.find][odmantic.engine.AIOEngine.find] or [AIOEngine.find_one][odmantic.engine.AIOEngine.find_one], the referenced models will be recursively resolved as well. Passing the model class to find and find_one When using the method to retrieve instances from the database, you have to specify the Model you want to query on as the first positional parameter. Internally, this enables ODMantic to properly type the results. Count instances \u00b6 You can count instances in the database by using the [AIOEngine.count][odmantic.engine.AIOEngine.count] method. It's possible as well to use this method with filtering queries. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player_count = await engine . count ( Player ) print ( player_count ) #> 4 cs_count = await engine . count ( Player , Player . game == \"Counter-Strike\" ) print ( cs_count ) #> 1 valorant_count = await engine . count ( Player , Player . game == \"Valorant\" ) print ( valorant_count ) #> 0 Combining multiple queries in read operations While using [find][odmantic.engine.AIOEngine.find], [find_one][odmantic.engine.AIOEngine.find_one] or [count][odmantic.engine.AIOEngine.count], you may pass as many queries as you want as positional arguments. Those will be implicitly combined as single [and_][odmantic.query.and_] query. Update \u00b6 Updating an instance in the database can be done simply by modifying the instance locally and saving it again to the database. The [AIOEngine.save][odmantic.engine.AIOEngine.save] and [AIOEngine.save_all][odmantic.engine.AIOEngine.save] methods are actually behaving as upsert operations. In other words, if the instance already exists it will be updated. Otherwise, the related document will be created in the database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () shroud = await engine . find_one ( Player , Player . name == \"Shroud\" ) print ( shroud . game ) #> Counter-Strike shroud . game = \"Valorant\" await engine . save ( shroud ) Resulting documents in the player collection { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a46\" ) , \"game\" : \"World of Warcraft\" , \"name\" : \"Leeroy Jenkins\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a47\" ) , \"game\" : \"Valorant\" , \"name\" : \"Shroud\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a49\" ) , \"game\" : \"Starcraft\" , \"name\" : \"TLO\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a48\" ) , \"game\" : \"Starcraft\" , \"name\" : \"Serral\" } Primary field update Currently, changing the primary field value is disabled and a NotImplementedError exception will be raised if you try to do so. It is still possible to mutate the primary field if the field type is mutable but it might result in unexpected behaviors. Workaround to modify the primary key There is still a workaround to update the primary key of a document: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from bson import ObjectId from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () shroud = await engine . find_one ( Player , Player . name == \"Shroud\" ) print ( shroud . id ) #> 5f86074f6dfecacc68428a62 new_id = ObjectId ( \"ffffffffffffffffffffffff\" ) # First delete the remote instance await engine . delete ( shroud ) # Then, copy the player object with a new primary key new_shroud = Player ( ** { ** shroud . dict (), \"id\" : new_id }) # Finally create again the document await engine . save ( new_shroud ) Resulting document associated to the player { \"_id\" : ObjectId( \"ffffffffffffffffffffffff\" ) , \"game\" : \"Valorant\" , \"name\" : \"Shroud\" } Delete \u00b6 You can delete instance by passing them to the [AIOEngine.delete][odmantic.engine.AIOEngine.delete] method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () players = await engine . find ( Player ) for player in players : await engine . delete ( player ) The collection is now empty .","title":"Engine"},{"location":"engine/#engine","text":"","title":"Engine"},{"location":"engine/#creating-the-engine","text":"In the previous examples, we created the engine using default parameters: MongoDB: running on localhost port 27017 Database name: test It's possible to provide a custom AsyncIOMotorClient to the [AIOEngine][odmantic.engine.AIOEngine] constructor. In the same way, the database name can be changed using the database keyword argument. 1 2 3 4 5 6 from motor.motor_asyncio import AsyncIOMotorClient from odmantic import AIOEngine client = AsyncIOMotorClient ( \"mongodb://localhost:27017/\" ) engine = AIOEngine ( motor_client = client , database = \"example_db\" ) For additional information about the MongoDB connection strings, see this section of the MongoDB documentation. Usage with DNS SRV records If you decide to use the DNS Seed List Connection Format (i.e mongodb+srv://... ), you will need to install the dnspython package.","title":"Creating the engine"},{"location":"engine/#create","text":"There are two ways of persisting instances to the database (i.e creating new documents): [AIOEngine.save][odmantic.engine.AIOEngine.save]: to save a single instance [AIOEngine.save_all][odmantic.engine.AIOEngine.save]: to save multiple instances at once 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () leeroy = Player ( name = \"Leeroy Jenkins\" , game = \"World of Warcraft\" ) await engine . save ( leeroy ) players = [ Player ( name = \"Shroud\" , game = \"Counter-Strike\" ), Player ( name = \"Serral\" , game = \"Starcraft\" ), Player ( name = \"TLO\" , game = \"Starcraft\" ), ] await engine . save_all ( players ) Resulting documents in the player collection { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a46\" ) , \"game\" : \"World of Warcraft\" , \"name\" : \"Leeroy Jenkins\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a47\" ) , \"game\" : \"Counter-Strike\" , \"name\" : \"Shroud\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a49\" ) , \"game\" : \"Starcraft\" , \"name\" : \"TLO\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a48\" ) , \"game\" : \"Starcraft\" , \"name\" : \"Serral\" } Referenced instances When calling [AIOEngine.save][odmantic.engine.AIOEngine.save] or [AIOEngine.save_all][odmantic.engine.AIOEngine.save], the referenced models will be persisted as well. Upsert behavior The save and save_all methods behave as upsert operations ( more details ). Hence, you might overwrite documents if you save instances with an existing primary key already existing in the database.","title":"Create"},{"location":"engine/#read","text":"Examples database content The next examples will consider that you have a player collection populated with the documents previously created.","title":"Read"},{"location":"engine/#fetch-a-single-instance","text":"As with regular MongoDB driver, you can use the [AIOEngine.find_one][odmantic.engine.AIOEngine.find_one] method to get at most one instance of a specific Model. This method will either return an instance matching the specified criteriums or None if no instances have been found. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player = await engine . find_one ( Player , Player . name == \"Serral\" ) print ( repr ( player )) #> Player(id=ObjectId(...), name=\"Serral\", game=\"Starcraft\") another_player = await engine . find_one ( Player , Player . name == \"Player_Not_Stored_In_Database\" ) print ( another_player ) #> None Fetch using sort We can use the sort parameter to fetch the Player instance with the first name in ascending order: await engine . find_one ( Player , sort = Player . name ) Find out more on sort in the dedicated section .","title":"Fetch a single instance"},{"location":"engine/#fetch-multiple-instances","text":"To get more than one instance from the database at once, you can use the [AIOEngine.find][odmantic.engine.AIOEngine.find] method. This method will return an [AIOCursor][odmantic.engine.AIOCursor] object, that can be used in two different ways.","title":"Fetch multiple instances"},{"location":"engine/#usage-as-an-async-iterator","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () async for player in engine . find ( Player , Player . game == \"Starcraft\" ): print ( repr ( player )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') #> Player(id=ObjectId(...), name='Serral', game='Starcraft') Ordering instances The sort parameter allows to order the query in ascending or descending order on a single or multiple fields. engine . find ( Player , sort = ( Player . name , Player . game . desc ())) Find out more on sort in the dedicated section .","title":"Usage as an async iterator"},{"location":"engine/#usage-as-an-awaitable","text":"Even if the async iterator usage should be preferred, in some cases it might be required to gather all the documents from the database before processing them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () players = await engine . find ( Player , Player . game != \"Starcraft\" ) print ( players ) #> [ #> Player(id=ObjectId(...), name=\"Leeroy Jenkins\", game=\"World of Warcraft\"), #> Player(id=ObjectId(...), name=\"Shroud\", game=\"Counter-Strike\"), #> ] Pagination You can as well use the skip and limit keyword arguments when using [AIOEngine.find][odmantic.engine.AIOEngine.find], respectively to skip a specified number of instances and to limit the number of fetched instances. Referenced instances When calling [AIOEngine.find][odmantic.engine.AIOEngine.find] or [AIOEngine.find_one][odmantic.engine.AIOEngine.find_one], the referenced models will be recursively resolved as well. Passing the model class to find and find_one When using the method to retrieve instances from the database, you have to specify the Model you want to query on as the first positional parameter. Internally, this enables ODMantic to properly type the results.","title":"Usage as an awaitable"},{"location":"engine/#count-instances","text":"You can count instances in the database by using the [AIOEngine.count][odmantic.engine.AIOEngine.count] method. It's possible as well to use this method with filtering queries. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player_count = await engine . count ( Player ) print ( player_count ) #> 4 cs_count = await engine . count ( Player , Player . game == \"Counter-Strike\" ) print ( cs_count ) #> 1 valorant_count = await engine . count ( Player , Player . game == \"Valorant\" ) print ( valorant_count ) #> 0 Combining multiple queries in read operations While using [find][odmantic.engine.AIOEngine.find], [find_one][odmantic.engine.AIOEngine.find_one] or [count][odmantic.engine.AIOEngine.count], you may pass as many queries as you want as positional arguments. Those will be implicitly combined as single [and_][odmantic.query.and_] query.","title":"Count instances"},{"location":"engine/#update","text":"Updating an instance in the database can be done simply by modifying the instance locally and saving it again to the database. The [AIOEngine.save][odmantic.engine.AIOEngine.save] and [AIOEngine.save_all][odmantic.engine.AIOEngine.save] methods are actually behaving as upsert operations. In other words, if the instance already exists it will be updated. Otherwise, the related document will be created in the database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () shroud = await engine . find_one ( Player , Player . name == \"Shroud\" ) print ( shroud . game ) #> Counter-Strike shroud . game = \"Valorant\" await engine . save ( shroud ) Resulting documents in the player collection { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a46\" ) , \"game\" : \"World of Warcraft\" , \"name\" : \"Leeroy Jenkins\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a47\" ) , \"game\" : \"Valorant\" , \"name\" : \"Shroud\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a49\" ) , \"game\" : \"Starcraft\" , \"name\" : \"TLO\" } { \"_id\" : ObjectId( \"5f85f36d6dfecacc68428a48\" ) , \"game\" : \"Starcraft\" , \"name\" : \"Serral\" } Primary field update Currently, changing the primary field value is disabled and a NotImplementedError exception will be raised if you try to do so. It is still possible to mutate the primary field if the field type is mutable but it might result in unexpected behaviors. Workaround to modify the primary key There is still a workaround to update the primary key of a document: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from bson import ObjectId from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () shroud = await engine . find_one ( Player , Player . name == \"Shroud\" ) print ( shroud . id ) #> 5f86074f6dfecacc68428a62 new_id = ObjectId ( \"ffffffffffffffffffffffff\" ) # First delete the remote instance await engine . delete ( shroud ) # Then, copy the player object with a new primary key new_shroud = Player ( ** { ** shroud . dict (), \"id\" : new_id }) # Finally create again the document await engine . save ( new_shroud ) Resulting document associated to the player { \"_id\" : ObjectId( \"ffffffffffffffffffffffff\" ) , \"game\" : \"Valorant\" , \"name\" : \"Shroud\" }","title":"Update"},{"location":"engine/#delete","text":"You can delete instance by passing them to the [AIOEngine.delete][odmantic.engine.AIOEngine.delete] method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () players = await engine . find ( Player ) for player in players : await engine . delete ( player ) The collection is now empty .","title":"Delete"},{"location":"fields/","text":"Fields \u00b6 The id field \u00b6 The ObjectId data type is the default primary key type used by MongoDB. An ObjectId comes with many information embedded into it (timestamp, machine identifier, ...). Since by default MongoDB will create a field _id containing an ObjectId primary key, ODMantic will bind it automatically to an implicit field named id . 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model class Player ( Model ): name : str leeroy = Player ( name = \"Leeroy Jenkins\" ) print ( leeroy . id ) #> ObjectId('5ed50fcad11d1975aa3d7a28') print ( repr ( leeroy )) #> Player(id=ObjectId('5ed50fcad11d1975aa3d7a28'), name=\"Leeroy Jenkins\") ObjectId creation This id field will be generated on instance creation, before saving the instance to the database. This helps to keep consistency between the instances persisted to the database and the ones only created locally. Even if this behavior is convenient, it is still possible to define custom primary keys . Field types \u00b6 Optional fields \u00b6 By default, every single field will be required. To specify a field as non-required, the easiest way is to use the typing.Optional generic type that will allow the field to take the None value as well (it will be stored as null in the database). 1 2 3 4 5 6 7 8 9 10 11 12 from typing import Optional from odmantic import Model class Person ( Model ): name : str age : Optional [ int ] john = Person ( name = \"John\" ) print ( john . age ) #> None Union fields \u00b6 As explained in the Python Typing documentation , Optional[X] is equivalent to Union[X, None] . That implies that the field type will be either X or None . It's possible to combine any kind of type using the typ\u00eeng.Union type constructor. For example if we want to allow both string and int in a field: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from typing import Union from odmantic import Model class Thing ( Model ): ref_id : Union [ int , str ] thing_1 = Thing ( ref_id = 42 ) print ( thing_1 . ref_id ) #> 42 thing_2 = Thing ( ref_id = \"i am a string\" ) print ( thing_2 . ref_id ) #> i am a string NoneType Internally python describes the type of the None object as NoneType but in practice, None is used directly in type annotations ( more details ). Enum fields \u00b6 To define choices, it's possible to use the standard enum classes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from enum import Enum from odmantic import AIOEngine , Model class TreeKind ( str , Enum ): BIG = \"big\" SMALL = \"small\" class Tree ( Model ): name : str kind : TreeKind sequoia = Tree ( name = \"Sequoia\" , kind = TreeKind . BIG ) print ( sequoia . kind ) #> TreeKind.BIG print ( sequoia . kind == \"big\" ) #> True spruce = Tree ( name = \"Spruce\" , kind = \"small\" ) print ( spruce . kind ) #> TreeKind.SMALL print ( spruce . kind == TreeKind . SMALL ) #> True engine = AIOEngine () await engine . save_all ([ sequoia , spruce ]) Resulting documents in the collection tree after execution { \"_id\" : ObjectId( \"5f818f2dd5708527282c49b6\" ) , \"kind\" : \"big\" , \"name\" : \"Sequoia\" } { \"_id\" : ObjectId( \"5f818f2dd5708527282c49b7\" ) , \"kind\" : \"small\" , \"name\" : \"Spruce\" } If you try to use a value not present in the allowed choices, a ValidationError exception will be raised. Usage of enum.auto If you might add some values to an Enum , it's strongly recommended not to use the enum.auto value generator. Depending on the order you add choices, it could completely break the consistency with documents stored in the database. Unwanted behavior example 1 2 3 4 5 6 7 8 9 10 11 12 from enum import Enum , auto class Color ( Enum ): RED = auto () BLUE = auto () print ( Color . RED . value ) #> 1 print ( Color . BLUE . value ) #> 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from enum import Enum , auto class Color ( Enum ): RED = auto () GREEN = auto () BLUE = auto () print ( Color . RED . value ) #> 1 print ( Color . GREEN . value ) #> 2 print ( Color . BLUE . value ) #> 3 Container fields \u00b6 List \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from typing import List , Union from odmantic import Model class SimpleListModel ( Model ): field : list print ( SimpleListModel ( field = [ 1 , \"a\" , True ]) . field ) #> [1, 'a', True] print ( SimpleListModel ( field = ( 1 , \"a\" , True )) . field ) #> [1, 'a', True] class IntListModel ( Model ): field : List [ int ] print ( IntListModel ( field = [ 1 , 5 ]) . field ) #> [1, 5] print ( IntListModel ( field = ( 1 , 5 )) . field ) #> [1, 5] class IntStrListModel ( Model ): field : List [ Union [ int , str ]] print ( IntStrListModel ( field = [ 1 , \"b\" ]) . field ) #> [1, 'b'] print ( IntStrListModel ( field = ( 1 , \"b\" )) . field ) #> [1, 'b'] Tip It's possible to define element count constraints for a list field using the [Field][odmantic.field.Field] descriptor. Tuple \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from typing import Tuple from odmantic import Model class SimpleTupleModel ( Model ): field : tuple print ( SimpleTupleModel ( field = [ 1 , \"a\" , True ]) . field ) #> (1, 'a', True) print ( SimpleTupleModel ( field = ( 1 , \"a\" , True )) . field ) #> (1, 'a', True) class TwoIntTupleModel ( Model ): field : Tuple [ int , int ] print ( SimpleTupleModel ( field = ( 1 , 10 )) . field ) #> (1, 10) print ( SimpleTupleModel ( field = [ 1 , 10 ]) . field ) #> (1, 10) class IntTupleModel ( Model ): field : Tuple [ int , ... ] print ( IntTupleModel ( field = ( 1 ,)) . field ) #> (1,) print ( IntTupleModel ( field = [ 1 , 2 , 3 , 10 ]) . field ) #> (1, 2, 3, 10) Dict \u00b6 Tip For mapping types with already known keys, you can see the embedded models section . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from typing import Dict , Union from odmantic import Model class SimpleDictModel ( Model ): field : dict print ( SimpleDictModel ( field = { 18 : \"a string\" , True : 42 , 18.3 : [ 1 , 2 , 3 ]}) . field ) #> {18: 'a string', True: 42, 18.3: [1, 2, 3]} class IntStrDictModel ( Model ): field : Dict [ int , str ] print ( IntStrDictModel ( field = { 1 : \"one\" , 2 : \"two\" }) . field ) #> {1: 'one', 2: 'two'} class IntBoolStrDictModel ( Model ): field : Dict [ int , Union [ bool , str ]] print ( IntBoolStrDictModel ( field = { 0 : False , 1 : True , 3 : \"three\" }) . field ) #> {0: False, 1: True, 3: 'three'} Performance tip Whenever possible, try to avoid mutable container types ( List , Set , ...) and prefer their Immutable alternatives ( Tuple , FrozenSet , ...). This will allow ODMantic to speedup database writes by only saving the modified container fields. BSON types integration \u00b6 ODMantic supports native python BSON types ( bson package ). Those types can be used directly as field types: bson.ObjectId bson.Int64 bson.Decimal128 bson.Regex bson.Binary Generic python to BSON type map Python type BSON type Comment bson.ObjectId objectId bool bool int int value between -2^31 and 2^31 - 1 int long value not between -2^31 and 2^31 - 1 bson.Int64 long float double bson.Decimal128 decimal decimal.Decimal decimal str string typing.Pattern regex bson.Regex regex bytes binData bson.Binary binData datetime.datetime date microseconds are truncated, only naive datetimes are allowed typing.Dict object typing.List array typing.Sequence array typing.Tuple[T, ...] array Pydantic fields \u00b6 Most of the types supported by pydantic are supported by ODMantic. See pydantic: Field Types for more field types. Unsupported fields: typing.Callable Fields with a specific behavior: datetime.datetime : Only naive datetime objects will be allowed as MongoDB doesn't store the timezone information. Also, the microsecond information will be truncated. Customization \u00b6 The field customization can mainly be performed using the [Field][odmantic.field.Field] descriptor. This descriptor is here to define everything about the field except its type. Default values \u00b6 The easiest way to set a default value to a field is by assigning this default value directly while defining the model. 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Model class Player ( Model ): name : str level : int = 0 p = Player ( name = \"Dash\" ) print ( repr ( p )) #> Player(id=ObjectId('5f7cd4be16af832772f1615e'), name='Dash', level=0) You can combine default values and an existing [Field][odmantic.field.Field] descriptor using the default keyword argument. 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Field , Model class Player ( Model ): name : str level : int = Field ( default = 1 , ge = 1 ) p = Player ( name = \"Dash\" ) print ( repr ( p )) #> Player(id=ObjectId('5f7cdbfbb54a94e9e8717c77'), name='Dash', level=1) Default factory You may as well define a factory function instead of a value using the default_factory argument of the [Field][odmantic.field.Field] descriptor. Tip For typing.Optional fields, None is already set as the default value Default values validation Currently the default values are not validated yet during the model creation. An inconsistent default value might raise a ValidationError while building an instance. Document structure \u00b6 By default, the MongoDB documents fields will be named after the field name. It is possible to override this naming policy by using the key_name argument in the [Field][odmantic.field.Field] descriptor. 1 2 3 4 5 6 7 8 9 from odmantic import AIOEngine , Field , Model class Player ( Model ): name : str = Field ( key_name = \"username\" ) engine = AIOEngine () await engine . save ( Player ( name = \"Jack\" )) Resulting documents in the collection player after execution { \"_id\" : ObjectId( \"5ed50fcad11d1975aa3d7a28\" ) , \"username\" : \"Jack\" , } See this section for more details about the _id field that has been added. Primary key \u00b6 While ODMantic will by default populate the id field as a primary key, you can use any other field as the primary key. 1 2 3 4 5 6 7 8 9 10 11 12 13 from odmantic import AIOEngine , Field , Model class Player ( Model ): name : str = Field ( primary_field = True ) leeroy = Player ( name = \"Leeroy Jenkins\" ) print ( repr ( leeroy )) #> Player(name=\"Leeroy Jenkins\") engine = AIOEngine () await engine . save ( leeroy ) Resulting documents in the collection player after execution { \"_id\" : \"Leeroy Jenkins\" } Info The Mongo name of the primary field will be enforced to _id and you will not be able to change it. Warning Using mutable types (Set, List, ...) as primary field might result in inconsistent behaviors. Validation \u00b6 As ODMantic strongly relies on pydantic when it comes to data validation, most of the validation features provided by pydantic are available: Add field validation constraints by using the [Field descriptor][odmantic.field.Field] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from typing import List from odmantic import Field , Model class ExampleModel ( Model ): small_int : int = Field ( le = 10 ) big_int : int = Field ( gt = 1000 ) even_int : int = Field ( multiple_of = 2 ) small_float : float = Field ( lt = 10 ) big_float : float = Field ( ge = 1e10 ) short_string : str = Field ( max_length = 10 ) long_string : str = Field ( min_length = 100 ) string_starting_with_the : str = Field ( regex = r \"^The\" ) short_str_list : List [ str ] = Field ( max_items = 5 ) long_str_list : List [ str ] = Field ( min_items = 15 ) Use strict types to prevent to coercion from compatible types ( pydantic: Strict Types ) 1 2 3 4 5 6 7 8 9 from pydantic import StrictBool , StrictFloat , StrictStr from odmantic import Model class ExampleModel ( Model ): strict_bool : StrictBool strict_float : StrictFloat strict_str : StrictStr Define custom field validators ( pydantic: Validators ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 from typing import ClassVar from pydantic import ValidationError , validator from odmantic import Model class SmallRectangle ( Model ): MAX_SIDE_SIZE : ClassVar [ float ] = 10 length : float width : float @validator ( \"width\" , \"length\" ) def check_small_sides ( cls , v ): if v > cls . MAX_SIDE_SIZE : raise ValueError ( f \"side is greater than { cls . MAX_SIDE_SIZE } \" ) return v @validator ( \"width\" ) def check_width_length ( cls , width , values , ** kwargs ): length = values . get ( \"length\" ) if length is not None and width > length : raise ValueError ( \"width can't be greater than length\" ) return width print ( SmallRectangle ( length = 2 , width = 1 )) #> id=ObjectId('5f81e3c073103f509f97e374'), length=2.0, width=1.0 try : SmallRectangle ( length = 2 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width field required (type=value_error.missing) \"\"\" try : SmallRectangle ( length = 2 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width width can't be greater than length (type=value_error) \"\"\" try : SmallRectangle ( length = 40 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle length side is greater than 10 (type=value_error) \"\"\" Define custom model validators: more details Custom field types \u00b6 Exactly in the same way pydantic allows it, it's possible to define custom field types as well with ODMantic ( pydantic: Custom data types ). Sometimes, it might be required to customize as well the field BSON serialization. In order to do this, the field class will have to implement the __bson__ class method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from bson import Binary from odmantic import AIOEngine , Model class ASCIISerializedAsBinary ( str ): @classmethod def __get_validators__ ( cls ): yield cls . validate @classmethod def validate ( cls , v ): if isinstance ( v , bytes ): # Handle data coming from MongoDB return v . decode ( \"ascii\" ) if not isinstance ( v , str ): raise TypeError ( \"string required\" ) if not v . isascii (): raise ValueError ( \"Only ascii characters are allowed\" ) return v @classmethod def __bson__ ( cls , v : str ): # We can encode this string as ascii since it contains # only ascii characters bytes_ = v . encode ( \"ascii\" ) return bytes_ class Example ( Model ): field : ASCIISerializedAsBinary engine = AIOEngine () await engine . save ( Example ( field = \"hello world\" )) fetched = await engine . find_one ( Example ) print ( fetched . field ) #> hello world In this example, we decide to store string data manually encoded in the ASCII encoding. The encoding is handled in the __bson__ class method. On top of this, we handle the decoding by attempting to decode bytes object in the validate method. Resulting documents in the collection example after execution { \"_id\" : ObjectId( \"5f81fa5e8adaf4bf33f05035\" ) , \"field\" : BinData( 0 , \"aGVsbG8gd29ybGQ=\" ) } Warning When using custom bson serialization, it's important to handle as well the data validation for data retrieved from Mongo. In the previous example it's done by handling bytes objects in the validate method.","title":"Fields"},{"location":"fields/#fields","text":"","title":"Fields"},{"location":"fields/#the-id-field","text":"The ObjectId data type is the default primary key type used by MongoDB. An ObjectId comes with many information embedded into it (timestamp, machine identifier, ...). Since by default MongoDB will create a field _id containing an ObjectId primary key, ODMantic will bind it automatically to an implicit field named id . 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model class Player ( Model ): name : str leeroy = Player ( name = \"Leeroy Jenkins\" ) print ( leeroy . id ) #> ObjectId('5ed50fcad11d1975aa3d7a28') print ( repr ( leeroy )) #> Player(id=ObjectId('5ed50fcad11d1975aa3d7a28'), name=\"Leeroy Jenkins\") ObjectId creation This id field will be generated on instance creation, before saving the instance to the database. This helps to keep consistency between the instances persisted to the database and the ones only created locally. Even if this behavior is convenient, it is still possible to define custom primary keys .","title":"The id field"},{"location":"fields/#field-types","text":"","title":"Field types"},{"location":"fields/#optional-fields","text":"By default, every single field will be required. To specify a field as non-required, the easiest way is to use the typing.Optional generic type that will allow the field to take the None value as well (it will be stored as null in the database). 1 2 3 4 5 6 7 8 9 10 11 12 from typing import Optional from odmantic import Model class Person ( Model ): name : str age : Optional [ int ] john = Person ( name = \"John\" ) print ( john . age ) #> None","title":"Optional fields"},{"location":"fields/#union-fields","text":"As explained in the Python Typing documentation , Optional[X] is equivalent to Union[X, None] . That implies that the field type will be either X or None . It's possible to combine any kind of type using the typ\u00eeng.Union type constructor. For example if we want to allow both string and int in a field: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from typing import Union from odmantic import Model class Thing ( Model ): ref_id : Union [ int , str ] thing_1 = Thing ( ref_id = 42 ) print ( thing_1 . ref_id ) #> 42 thing_2 = Thing ( ref_id = \"i am a string\" ) print ( thing_2 . ref_id ) #> i am a string NoneType Internally python describes the type of the None object as NoneType but in practice, None is used directly in type annotations ( more details ).","title":"Union fields"},{"location":"fields/#enum-fields","text":"To define choices, it's possible to use the standard enum classes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from enum import Enum from odmantic import AIOEngine , Model class TreeKind ( str , Enum ): BIG = \"big\" SMALL = \"small\" class Tree ( Model ): name : str kind : TreeKind sequoia = Tree ( name = \"Sequoia\" , kind = TreeKind . BIG ) print ( sequoia . kind ) #> TreeKind.BIG print ( sequoia . kind == \"big\" ) #> True spruce = Tree ( name = \"Spruce\" , kind = \"small\" ) print ( spruce . kind ) #> TreeKind.SMALL print ( spruce . kind == TreeKind . SMALL ) #> True engine = AIOEngine () await engine . save_all ([ sequoia , spruce ]) Resulting documents in the collection tree after execution { \"_id\" : ObjectId( \"5f818f2dd5708527282c49b6\" ) , \"kind\" : \"big\" , \"name\" : \"Sequoia\" } { \"_id\" : ObjectId( \"5f818f2dd5708527282c49b7\" ) , \"kind\" : \"small\" , \"name\" : \"Spruce\" } If you try to use a value not present in the allowed choices, a ValidationError exception will be raised. Usage of enum.auto If you might add some values to an Enum , it's strongly recommended not to use the enum.auto value generator. Depending on the order you add choices, it could completely break the consistency with documents stored in the database. Unwanted behavior example 1 2 3 4 5 6 7 8 9 10 11 12 from enum import Enum , auto class Color ( Enum ): RED = auto () BLUE = auto () print ( Color . RED . value ) #> 1 print ( Color . BLUE . value ) #> 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from enum import Enum , auto class Color ( Enum ): RED = auto () GREEN = auto () BLUE = auto () print ( Color . RED . value ) #> 1 print ( Color . GREEN . value ) #> 2 print ( Color . BLUE . value ) #> 3","title":"Enum fields"},{"location":"fields/#container-fields","text":"","title":"Container fields"},{"location":"fields/#list","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from typing import List , Union from odmantic import Model class SimpleListModel ( Model ): field : list print ( SimpleListModel ( field = [ 1 , \"a\" , True ]) . field ) #> [1, 'a', True] print ( SimpleListModel ( field = ( 1 , \"a\" , True )) . field ) #> [1, 'a', True] class IntListModel ( Model ): field : List [ int ] print ( IntListModel ( field = [ 1 , 5 ]) . field ) #> [1, 5] print ( IntListModel ( field = ( 1 , 5 )) . field ) #> [1, 5] class IntStrListModel ( Model ): field : List [ Union [ int , str ]] print ( IntStrListModel ( field = [ 1 , \"b\" ]) . field ) #> [1, 'b'] print ( IntStrListModel ( field = ( 1 , \"b\" )) . field ) #> [1, 'b'] Tip It's possible to define element count constraints for a list field using the [Field][odmantic.field.Field] descriptor.","title":"List"},{"location":"fields/#tuple","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from typing import Tuple from odmantic import Model class SimpleTupleModel ( Model ): field : tuple print ( SimpleTupleModel ( field = [ 1 , \"a\" , True ]) . field ) #> (1, 'a', True) print ( SimpleTupleModel ( field = ( 1 , \"a\" , True )) . field ) #> (1, 'a', True) class TwoIntTupleModel ( Model ): field : Tuple [ int , int ] print ( SimpleTupleModel ( field = ( 1 , 10 )) . field ) #> (1, 10) print ( SimpleTupleModel ( field = [ 1 , 10 ]) . field ) #> (1, 10) class IntTupleModel ( Model ): field : Tuple [ int , ... ] print ( IntTupleModel ( field = ( 1 ,)) . field ) #> (1,) print ( IntTupleModel ( field = [ 1 , 2 , 3 , 10 ]) . field ) #> (1, 2, 3, 10)","title":"Tuple"},{"location":"fields/#dict","text":"Tip For mapping types with already known keys, you can see the embedded models section . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from typing import Dict , Union from odmantic import Model class SimpleDictModel ( Model ): field : dict print ( SimpleDictModel ( field = { 18 : \"a string\" , True : 42 , 18.3 : [ 1 , 2 , 3 ]}) . field ) #> {18: 'a string', True: 42, 18.3: [1, 2, 3]} class IntStrDictModel ( Model ): field : Dict [ int , str ] print ( IntStrDictModel ( field = { 1 : \"one\" , 2 : \"two\" }) . field ) #> {1: 'one', 2: 'two'} class IntBoolStrDictModel ( Model ): field : Dict [ int , Union [ bool , str ]] print ( IntBoolStrDictModel ( field = { 0 : False , 1 : True , 3 : \"three\" }) . field ) #> {0: False, 1: True, 3: 'three'} Performance tip Whenever possible, try to avoid mutable container types ( List , Set , ...) and prefer their Immutable alternatives ( Tuple , FrozenSet , ...). This will allow ODMantic to speedup database writes by only saving the modified container fields.","title":"Dict"},{"location":"fields/#bson-types-integration","text":"ODMantic supports native python BSON types ( bson package ). Those types can be used directly as field types: bson.ObjectId bson.Int64 bson.Decimal128 bson.Regex bson.Binary Generic python to BSON type map Python type BSON type Comment bson.ObjectId objectId bool bool int int value between -2^31 and 2^31 - 1 int long value not between -2^31 and 2^31 - 1 bson.Int64 long float double bson.Decimal128 decimal decimal.Decimal decimal str string typing.Pattern regex bson.Regex regex bytes binData bson.Binary binData datetime.datetime date microseconds are truncated, only naive datetimes are allowed typing.Dict object typing.List array typing.Sequence array typing.Tuple[T, ...] array","title":"BSON types integration"},{"location":"fields/#pydantic-fields","text":"Most of the types supported by pydantic are supported by ODMantic. See pydantic: Field Types for more field types. Unsupported fields: typing.Callable Fields with a specific behavior: datetime.datetime : Only naive datetime objects will be allowed as MongoDB doesn't store the timezone information. Also, the microsecond information will be truncated.","title":"Pydantic fields"},{"location":"fields/#customization","text":"The field customization can mainly be performed using the [Field][odmantic.field.Field] descriptor. This descriptor is here to define everything about the field except its type.","title":"Customization"},{"location":"fields/#default-values","text":"The easiest way to set a default value to a field is by assigning this default value directly while defining the model. 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Model class Player ( Model ): name : str level : int = 0 p = Player ( name = \"Dash\" ) print ( repr ( p )) #> Player(id=ObjectId('5f7cd4be16af832772f1615e'), name='Dash', level=0) You can combine default values and an existing [Field][odmantic.field.Field] descriptor using the default keyword argument. 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Field , Model class Player ( Model ): name : str level : int = Field ( default = 1 , ge = 1 ) p = Player ( name = \"Dash\" ) print ( repr ( p )) #> Player(id=ObjectId('5f7cdbfbb54a94e9e8717c77'), name='Dash', level=1) Default factory You may as well define a factory function instead of a value using the default_factory argument of the [Field][odmantic.field.Field] descriptor. Tip For typing.Optional fields, None is already set as the default value Default values validation Currently the default values are not validated yet during the model creation. An inconsistent default value might raise a ValidationError while building an instance.","title":"Default values"},{"location":"fields/#document-structure","text":"By default, the MongoDB documents fields will be named after the field name. It is possible to override this naming policy by using the key_name argument in the [Field][odmantic.field.Field] descriptor. 1 2 3 4 5 6 7 8 9 from odmantic import AIOEngine , Field , Model class Player ( Model ): name : str = Field ( key_name = \"username\" ) engine = AIOEngine () await engine . save ( Player ( name = \"Jack\" )) Resulting documents in the collection player after execution { \"_id\" : ObjectId( \"5ed50fcad11d1975aa3d7a28\" ) , \"username\" : \"Jack\" , } See this section for more details about the _id field that has been added.","title":"Document structure"},{"location":"fields/#primary-key","text":"While ODMantic will by default populate the id field as a primary key, you can use any other field as the primary key. 1 2 3 4 5 6 7 8 9 10 11 12 13 from odmantic import AIOEngine , Field , Model class Player ( Model ): name : str = Field ( primary_field = True ) leeroy = Player ( name = \"Leeroy Jenkins\" ) print ( repr ( leeroy )) #> Player(name=\"Leeroy Jenkins\") engine = AIOEngine () await engine . save ( leeroy ) Resulting documents in the collection player after execution { \"_id\" : \"Leeroy Jenkins\" } Info The Mongo name of the primary field will be enforced to _id and you will not be able to change it. Warning Using mutable types (Set, List, ...) as primary field might result in inconsistent behaviors.","title":"Primary key"},{"location":"fields/#validation","text":"As ODMantic strongly relies on pydantic when it comes to data validation, most of the validation features provided by pydantic are available: Add field validation constraints by using the [Field descriptor][odmantic.field.Field] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from typing import List from odmantic import Field , Model class ExampleModel ( Model ): small_int : int = Field ( le = 10 ) big_int : int = Field ( gt = 1000 ) even_int : int = Field ( multiple_of = 2 ) small_float : float = Field ( lt = 10 ) big_float : float = Field ( ge = 1e10 ) short_string : str = Field ( max_length = 10 ) long_string : str = Field ( min_length = 100 ) string_starting_with_the : str = Field ( regex = r \"^The\" ) short_str_list : List [ str ] = Field ( max_items = 5 ) long_str_list : List [ str ] = Field ( min_items = 15 ) Use strict types to prevent to coercion from compatible types ( pydantic: Strict Types ) 1 2 3 4 5 6 7 8 9 from pydantic import StrictBool , StrictFloat , StrictStr from odmantic import Model class ExampleModel ( Model ): strict_bool : StrictBool strict_float : StrictFloat strict_str : StrictStr Define custom field validators ( pydantic: Validators ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 from typing import ClassVar from pydantic import ValidationError , validator from odmantic import Model class SmallRectangle ( Model ): MAX_SIDE_SIZE : ClassVar [ float ] = 10 length : float width : float @validator ( \"width\" , \"length\" ) def check_small_sides ( cls , v ): if v > cls . MAX_SIDE_SIZE : raise ValueError ( f \"side is greater than { cls . MAX_SIDE_SIZE } \" ) return v @validator ( \"width\" ) def check_width_length ( cls , width , values , ** kwargs ): length = values . get ( \"length\" ) if length is not None and width > length : raise ValueError ( \"width can't be greater than length\" ) return width print ( SmallRectangle ( length = 2 , width = 1 )) #> id=ObjectId('5f81e3c073103f509f97e374'), length=2.0, width=1.0 try : SmallRectangle ( length = 2 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width field required (type=value_error.missing) \"\"\" try : SmallRectangle ( length = 2 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width width can't be greater than length (type=value_error) \"\"\" try : SmallRectangle ( length = 40 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle length side is greater than 10 (type=value_error) \"\"\" Define custom model validators: more details","title":"Validation"},{"location":"fields/#custom-field-types","text":"Exactly in the same way pydantic allows it, it's possible to define custom field types as well with ODMantic ( pydantic: Custom data types ). Sometimes, it might be required to customize as well the field BSON serialization. In order to do this, the field class will have to implement the __bson__ class method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from bson import Binary from odmantic import AIOEngine , Model class ASCIISerializedAsBinary ( str ): @classmethod def __get_validators__ ( cls ): yield cls . validate @classmethod def validate ( cls , v ): if isinstance ( v , bytes ): # Handle data coming from MongoDB return v . decode ( \"ascii\" ) if not isinstance ( v , str ): raise TypeError ( \"string required\" ) if not v . isascii (): raise ValueError ( \"Only ascii characters are allowed\" ) return v @classmethod def __bson__ ( cls , v : str ): # We can encode this string as ascii since it contains # only ascii characters bytes_ = v . encode ( \"ascii\" ) return bytes_ class Example ( Model ): field : ASCIISerializedAsBinary engine = AIOEngine () await engine . save ( Example ( field = \"hello world\" )) fetched = await engine . find_one ( Example ) print ( fetched . field ) #> hello world In this example, we decide to store string data manually encoded in the ASCII encoding. The encoding is handled in the __bson__ class method. On top of this, we handle the decoding by attempting to decode bytes object in the validate method. Resulting documents in the collection example after execution { \"_id\" : ObjectId( \"5f81fa5e8adaf4bf33f05035\" ) , \"field\" : BinData( 0 , \"aGVsbG8gd29ybGQ=\" ) } Warning When using custom bson serialization, it's important to handle as well the data validation for data retrieved from Mongo. In the previous example it's done by handling bytes objects in the validate method.","title":"Custom field types"},{"location":"modeling/","text":"Modeling \u00b6 Models \u00b6 To create a Model, simply inherit from the [Model][odmantic.model.Model] class and then specify the field types and eventually their descriptors. Collection \u00b6 Each Model will be linked to its own collection. By default, the collection name will be created from the chosen class name and converted to snake_case . For example a model class named CapitalCity will be stored in the collection named capital_city . If the class name ends with Model , ODMantic will remove it to create the collection name. For example, a model class named PersonModel will belong in the person collection. It's possible to customize the collection name of a model by specifying the collection option in the Config class. Custom collection name example from odmantic import Model class CapitalCity ( Model ): name : str population : int class Config : collection = \"city\" Now, when CapitalCity instances will be persisted to the database, they will belong in the city collection instead of capital_city . Warning Models and Embedded models inheritance is not supported yet. Custom model validators \u00b6 Exactly as done with pydantic, it's possible to define custom model validators as described in the pydantic: Root Validators documentation (this apply as well to Embedded Models). In the following example, we will define a rectangle class and add two validators: The first one will check that the height is greater than the width. The second one will ensure that the area of the rectangle is less or equal to 9. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 from typing import ClassVar from pydantic import ValidationError , root_validator from odmantic import Model class SmallRectangle ( Model ): MAX_AREA : ClassVar [ float ] = 9 length : float width : float @root_validator def check_width_length ( cls , values ): length = values . get ( \"length\" , 0 ) width = values . get ( \"width\" , 0 ) if width > length : raise ValueError ( \"width can't be greater than length\" ) return values @root_validator def check_area ( cls , values ): length = values . get ( \"length\" , 0 ) width = values . get ( \"width\" , 0 ) if length * width > cls . MAX_AREA : raise ValueError ( f \"area is greater than { cls . MAX_AREA } \" ) return values print ( SmallRectangle ( length = 2 , width = 1 )) #> id=ObjectId('5f81e3c073103f509f97e374'), length=2.0, width=1.0 try : SmallRectangle ( length = 2 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width field required (type=value_error.missing) \"\"\" try : SmallRectangle ( length = 2 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle __root__ width can't be greater than length (type=value_error) \"\"\" try : SmallRectangle ( length = 4 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle __root__ area is greater than 9 (type=value_error) \"\"\" Tip You can define class variables in the Models using the typing.ClassVar type construct, as done in this example with MAX_AREA . Those class variables will be completely ignored by ODMantic while persisting instances to the database. Advanced Configuration \u00b6 The model configuration is done in the same way as with Pydantic models: using a Config class defined in the model body. Available options : collection : str Customize the collection name associated to the model. see this section for more details about default collection naming. title : str (inherited from Pydantic) Title inferred in the JSON schema. Default: name of the model class anystr_strip_whitespace : bool (inherited from Pydantic) Whether to strip leading and trailing whitespaces for str & byte types. Default: False json_encoders : dict (inherited from Pydantic) Customize the way types used in the model are encoded to JSON. json_encoders example For example, in order to serialize datetime fields as timestamp values: class Event ( Model ): date : datetime class Config : json_encoders = { datetime : lambda v : v . timestamp () } json_loads (inherited from Pydantic) Function used to decode JSON data Default: json . loads json_dumps (inherited from Pydantic) Function used to encode JSON data Default: json . dumps For more details and examples about the options inherited from Pydantic, you can have a look to Pydantic: Model Config Warning Only the options described above are supported and other options from Pydantic can't be used with ODMantic. If you feel the need to have an additional option inherited from Pydantic, you can open an issue . Embedded Models \u00b6 Using an embedded model will store it directly in the root model it's integrated in. On the MongoDB side, the collection will contain the root documents and in inside each of them, the embedded models will be directly stored. Embedded models are especially useful while building one-to-one or one-to-many relationships. Note Since Embedded Models are directly embedded in the MongoDB collection of the root model, it will not be possible to query on them directly without specifying a root document. The creation of an Embedded model is done by inheriting the [EmbeddedModel][odmantic.model.EmbeddedModel] class. You can then define fields exactly as for the regular Models. One to One \u00b6 In this example, we will model the relation between a country and its capital city. Since one capital city can belong to one and only one country, we can model this relation as a One-to-One relationship. We will use an Embedded Model in this case. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from odmantic import AIOEngine , EmbeddedModel , Model class CapitalCity ( EmbeddedModel ): name : str population : int class Country ( Model ): name : str currency : str capital_city : CapitalCity countries = [ Country ( name = \"Switzerland\" , currency = \"Swiss franc\" , capital_city = CapitalCity ( name = \"Bern\" , population = 1035000 ), ), Country ( name = \"Sweden\" , currency = \"Swedish krona\" , capital_city = CapitalCity ( name = \"Stockholm\" , population = 975904 ), ), ] engine = AIOEngine () await engine . save_all ( countries ) Defining this relation is done in the same way as defining a new field. Here, the CapitalCity class will be considered as a field type during the model definition. The [Field][odmantic.field.Field] descriptor can be used as well for Embedded Models in order to bring more flexibility (default values, Mongo key name, ...). Content of the country collection after execution { \"_id\" : ObjectId( \"5f79d7e8b305f24ca43593e2\" ) , \"name\" : \"Sweden\" , \"currency\" : \"Swedish krona\" , \"capital_city\" : { \"name\" : \"Stockholm\" , \"population\" : 975904 } } { \"_id\" : ObjectId( \"5f79d7e8b305f24ca43593e1\" ) , \"name\" : \"Switzerland\" , \"currency\" : \"Swiss franc\" , \"capital_city\" : { \"name\" : \"Bern\" , \"population\" : 1035000 } } Tip It is possible as well to define query filters based on embedded documents content. await engine . find_one ( Country , Country . capital_city . name == \"Stockholm\" ) #> Country( #> id=ObjectId(\"5f79d7e8b305f24ca43593e2\"), #> name=\"Sweden\", #> currency=\"Swedish krona\", #> capital_city=CapitalCity(name=\"Stockholm\", population=975904), #> ) For more details, see the Querying section. One to Many \u00b6 Here, we will model the relation between a customer of an online shop and his shipping addresses. A single customer can have multiple addresses but these addresses belong only to the customer's account. He should be allowed to modify them without modifying others addresses (for example if two family members use the same address, their addresses should not be linked together). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from typing import List from odmantic import AIOEngine , EmbeddedModel , Model class Address ( EmbeddedModel ): street : str city : str state : str zipcode : str class Customer ( Model ): name : str addresses : List [ Address ] customer = Customer ( name = \"John Doe\" , addresses = [ Address ( street = \"1757 Birch Street\" , city = \"Greenwood\" , state = \"Indiana\" , zipcode = \"46142\" , ), Address ( street = \"262 Barnes Avenue\" , city = \"Cincinnati\" , state = \"Ohio\" , zipcode = \"45216\" , ), ], ) engine = AIOEngine () await engine . save ( customer ) As done previously for the One to One relation, defining a One to Many relationship with Embedded Models is done exactly as defining a field with its type being a sequence of Address objects. Content of the customer collection after execution { \"_id\" : ObjectId( \"5f79eb116371e09b16e4fae4\" ) , \"name\" : \"John Doe\" , \"addresses\" :[ { \"street\" : \"1757 Birch Street\" , \"city\" : \"Greenwood\" , \"state\" : \"Indiana\" , \"zipcode\" : \"46142\" }, { \"street\" : \"262 Barnes Avenue\" , \"city\" : \"Cincinnati\" , \"state\" : \"Ohio\" , \"zipcode\" : \"45216\" } ] } Tip To add conditions on the number of embedded elements, it's possible to use the min_items and max_items arguments of the [Field][odmantic.field.Field] descriptor. Another possibility is to use the typing.Tuple type. Note Building query filters based on the content of a sequence of embedded documents is not supported yet (but this feature is planned for an upcoming release ). Anyway, it's still possible to perform the filtering operation manually using Mongo Array Operators ( $all , $elemMatch , $size ). See the Raw query usage section for more details. Customization \u00b6 Since the Embedded Models are considered as types by ODMantic, most of the complex type constructs that could be imagined should be supported. Some ideas which could be useful: Combine two different embedded models in a single field using typing.Tuple . Allow multiple Embedded model types using a typing.Union type. Make an Embedded model not required using typing.Optional . Embed the documents in a dictionary (using the typing.Dict type) to provide an additional key-value mapping to the embedded documents. Nest embedded documents Referenced models \u00b6 Embedded models are really simple to use but sometimes it is needed as well to have many-to-one (i.e. multiple entities referring to another single one) or many-to-many relationships. This is not really possible to model those using embedded documents and in this case, references will come handy. Another use case where references are useful is for one-to-one/one-to-many relations but when the referenced model has to exist in its own collection, in order to be accessed on its own without any parent model specified. Many to One (Mapped) \u00b6 In this part, we will model the relation between books and publishers. Let's consider that each book has a single publisher. In this case, multiple books could be published by the same publisher. We can thus model this relation as a many-to-one relationship. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from odmantic import AIOEngine , Model , Reference class Publisher ( Model ): name : str founded : int location : str class Book ( Model ): title : str pages : int publisher : Publisher = Reference () hachette = Publisher ( name = \"Hachette Livre\" , founded = 1826 , location = \"FR\" ) harper = Publisher ( name = \"HarperCollins\" , founded = 1989 , location = \"US\" ) books = [ Book ( title = \"They Didn't See Us Coming\" , pages = 304 , publisher = hachette ), Book ( title = \"This Isn't Happening\" , pages = 256 , publisher = hachette ), Book ( title = \"Prodigal Summer\" , pages = 464 , publisher = harper ), ] engine = AIOEngine () await engine . save_all ( books ) The definition of a reference field requires the presence of the [Reference()][odmantic.reference.Reference] descriptor. Once the models are defined, linking two instances is done simply by assigning the reference field of referencing instance to the referenced instance. Why is it required to include the Reference descriptor ? The main goal behind enforcing the presence of the descriptor is to have a clear distinction between Embedded Models and References. In the future, a generic Reference[T] type will probably be included to make this distinction since it would make more sense than having to set a descriptor for each reference. Content of the publisher collection after execution { \"_id\" : ObjectId( \"5f7a0dc48a73b20f16e2a364\" ) , \"founded\" : 1826 , \"location\" : \"FR\" , \"name\" : \"Hachette Livre\" } { \"_id\" : ObjectId( \"5f7a0dc48a73b20f16e2a365\" ) , \"founded\" : 1989 , \"location\" : \"US\" , \"name\" : \"HarperCollins\" } We can see that the publishers have been persisted to their collection even if no explicit save has been perfomed. When calling the [engine.save][odmantic.engine.AIOEngine.save] method, the engine will persist automatically the referenced documents. While fetching instances, the engine will as well resolve every reference. Content of the book collection after execution { \"_id\" : ObjectId( \"5f7a0dc48a73b20f16e2a366\" ) , \"pages\" : 304 , \"publisher\" : ObjectId( \"5f7a0dc48a73b20f16e2a364\" ) , \"title\" : \"They Didn't See Us Coming\" } { \"_id\" : ObjectId( \"5f7a0dc48a73b20f16e2a367\" ) , \"pages\" : 256 , \"publisher\" : ObjectId( \"5f7a0dc48a73b20f16e2a364\" ) , \"title\" : \"This Isn't Happening\" } { \"_id\" : ObjectId( \"5f7a0dc48a73b20f16e2a368\" ) , \"pages\" : 464 , \"publisher\" : ObjectId( \"5f7a0dc48a73b20f16e2a365\" ) , \"title\" : \"Prodigal Summer\" } The resulting books in the collection contain the publisher reference directly as a document attribute (using the reference name as the document's key). Tip It's possible to customize the foreign key storage key using the key_name argument while building the [Reference][odmantic.reference.Reference] descriptor. Many to Many (Manual) \u00b6 Here, we will model the relation between books and their authors. Since a book can have multiple authors and an author can be authoring multiple books, we will model this relation as a many-to-many relationship. Note Currently, ODMantic does not support mapped multi-references yet. But we will still define the relationship in a manual way. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from typing import List from bson import ObjectId from odmantic import AIOEngine , Model class Author ( Model ): name : str class Book ( Model ): title : str pages : int author_ids : List [ ObjectId ] david = Author ( name = \"David Beazley\" ) brian = Author ( name = \"Brian K. Jones\" ) python_cookbook = Book ( title = \"Python Cookbook\" , pages = 706 , author_ids = [ david . id , brian . id ] ) python_essentials = Book ( title = \"Python Essential Reference\" , pages = 717 , author_ids = [ brian . id ] ) engine = AIOEngine () await engine . save_all (( david , brian )) await engine . save_all (( python_cookbook , python_essentials )) We defined an author_ids field which holds the list of unique ids of the authors (This id field in the Author model is generated implicitly by default). Since this multi-reference is not mapped by the ODM, we have to persist the authors manually. Content of the author collection after execution { \"_id\" : ObjectId( \"5f7a37dc7311be1362e1da4e\" ) , \"name\" : \"David Beazley\" } { \"_id\" : ObjectId( \"5f7a37dc7311be1362e1da4f\" ) , \"name\" : \"Brian K. Jones\" } Content of the book collection after execution { \"_id\" : ObjectId( \"5f7a37dc7311be1362e1da50\" ) , \"title\" : \"Python Cookbook\" \"pages\" : 706 , \"author_ids\" :[ ObjectId( \"5f7a37dc7311be1362e1da4e\" ) , ObjectId( \"5f7a37dc7311be1362e1da4f\" ) ], } { \"_id\" : ObjectId( \"5f7a37dc7311be1362e1da51\" ) , \"title\" : \"Python Essential Reference\" \"pages\" : 717 , \"author_ids\" :[ ObjectId( \"5f7a37dc7311be1362e1da4f\" ) ], } Retrieving the authors of the Python Cookbook First, it's required to fetch the ids of the authors. Then we can use the [in_][odmantic.query.in_] filter to select only the authors with the desired ids. 1 2 3 4 5 6 7 book = await engine . find_one ( Book , Book . title == \"Python Cookbook\" ) authors = await engine . find ( Author , Author . id . in_ ( book . author_ids )) print ( authors ) #> [ #> Author(id=ObjectId(\"5f7a37dc7311be1362e1da4e\"), name=\"David Beazley\"), #> Author(id=ObjectId(\"5f7a37dc7311be1362e1da4f\"), name=\"Brian K. Jones\"), #> ]","title":"Modeling"},{"location":"modeling/#modeling","text":"","title":"Modeling"},{"location":"modeling/#models","text":"To create a Model, simply inherit from the [Model][odmantic.model.Model] class and then specify the field types and eventually their descriptors.","title":"Models"},{"location":"modeling/#collection","text":"Each Model will be linked to its own collection. By default, the collection name will be created from the chosen class name and converted to snake_case . For example a model class named CapitalCity will be stored in the collection named capital_city . If the class name ends with Model , ODMantic will remove it to create the collection name. For example, a model class named PersonModel will belong in the person collection. It's possible to customize the collection name of a model by specifying the collection option in the Config class. Custom collection name example from odmantic import Model class CapitalCity ( Model ): name : str population : int class Config : collection = \"city\" Now, when CapitalCity instances will be persisted to the database, they will belong in the city collection instead of capital_city . Warning Models and Embedded models inheritance is not supported yet.","title":"Collection"},{"location":"modeling/#custom-model-validators","text":"Exactly as done with pydantic, it's possible to define custom model validators as described in the pydantic: Root Validators documentation (this apply as well to Embedded Models). In the following example, we will define a rectangle class and add two validators: The first one will check that the height is greater than the width. The second one will ensure that the area of the rectangle is less or equal to 9. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 from typing import ClassVar from pydantic import ValidationError , root_validator from odmantic import Model class SmallRectangle ( Model ): MAX_AREA : ClassVar [ float ] = 9 length : float width : float @root_validator def check_width_length ( cls , values ): length = values . get ( \"length\" , 0 ) width = values . get ( \"width\" , 0 ) if width > length : raise ValueError ( \"width can't be greater than length\" ) return values @root_validator def check_area ( cls , values ): length = values . get ( \"length\" , 0 ) width = values . get ( \"width\" , 0 ) if length * width > cls . MAX_AREA : raise ValueError ( f \"area is greater than { cls . MAX_AREA } \" ) return values print ( SmallRectangle ( length = 2 , width = 1 )) #> id=ObjectId('5f81e3c073103f509f97e374'), length=2.0, width=1.0 try : SmallRectangle ( length = 2 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width field required (type=value_error.missing) \"\"\" try : SmallRectangle ( length = 2 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle __root__ width can't be greater than length (type=value_error) \"\"\" try : SmallRectangle ( length = 4 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle __root__ area is greater than 9 (type=value_error) \"\"\" Tip You can define class variables in the Models using the typing.ClassVar type construct, as done in this example with MAX_AREA . Those class variables will be completely ignored by ODMantic while persisting instances to the database.","title":"Custom model validators"},{"location":"modeling/#advanced-configuration","text":"The model configuration is done in the same way as with Pydantic models: using a Config class defined in the model body. Available options : collection : str Customize the collection name associated to the model. see this section for more details about default collection naming. title : str (inherited from Pydantic) Title inferred in the JSON schema. Default: name of the model class anystr_strip_whitespace : bool (inherited from Pydantic) Whether to strip leading and trailing whitespaces for str & byte types. Default: False json_encoders : dict (inherited from Pydantic) Customize the way types used in the model are encoded to JSON. json_encoders example For example, in order to serialize datetime fields as timestamp values: class Event ( Model ): date : datetime class Config : json_encoders = { datetime : lambda v : v . timestamp () } json_loads (inherited from Pydantic) Function used to decode JSON data Default: json . loads json_dumps (inherited from Pydantic) Function used to encode JSON data Default: json . dumps For more details and examples about the options inherited from Pydantic, you can have a look to Pydantic: Model Config Warning Only the options described above are supported and other options from Pydantic can't be used with ODMantic. If you feel the need to have an additional option inherited from Pydantic, you can open an issue .","title":"Advanced Configuration"},{"location":"modeling/#embedded-models","text":"Using an embedded model will store it directly in the root model it's integrated in. On the MongoDB side, the collection will contain the root documents and in inside each of them, the embedded models will be directly stored. Embedded models are especially useful while building one-to-one or one-to-many relationships. Note Since Embedded Models are directly embedded in the MongoDB collection of the root model, it will not be possible to query on them directly without specifying a root document. The creation of an Embedded model is done by inheriting the [EmbeddedModel][odmantic.model.EmbeddedModel] class. You can then define fields exactly as for the regular Models.","title":"Embedded Models"},{"location":"modeling/#one-to-one","text":"In this example, we will model the relation between a country and its capital city. Since one capital city can belong to one and only one country, we can model this relation as a One-to-One relationship. We will use an Embedded Model in this case. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from odmantic import AIOEngine , EmbeddedModel , Model class CapitalCity ( EmbeddedModel ): name : str population : int class Country ( Model ): name : str currency : str capital_city : CapitalCity countries = [ Country ( name = \"Switzerland\" , currency = \"Swiss franc\" , capital_city = CapitalCity ( name = \"Bern\" , population = 1035000 ), ), Country ( name = \"Sweden\" , currency = \"Swedish krona\" , capital_city = CapitalCity ( name = \"Stockholm\" , population = 975904 ), ), ] engine = AIOEngine () await engine . save_all ( countries ) Defining this relation is done in the same way as defining a new field. Here, the CapitalCity class will be considered as a field type during the model definition. The [Field][odmantic.field.Field] descriptor can be used as well for Embedded Models in order to bring more flexibility (default values, Mongo key name, ...). Content of the country collection after execution { \"_id\" : ObjectId( \"5f79d7e8b305f24ca43593e2\" ) , \"name\" : \"Sweden\" , \"currency\" : \"Swedish krona\" , \"capital_city\" : { \"name\" : \"Stockholm\" , \"population\" : 975904 } } { \"_id\" : ObjectId( \"5f79d7e8b305f24ca43593e1\" ) , \"name\" : \"Switzerland\" , \"currency\" : \"Swiss franc\" , \"capital_city\" : { \"name\" : \"Bern\" , \"population\" : 1035000 } } Tip It is possible as well to define query filters based on embedded documents content. await engine . find_one ( Country , Country . capital_city . name == \"Stockholm\" ) #> Country( #> id=ObjectId(\"5f79d7e8b305f24ca43593e2\"), #> name=\"Sweden\", #> currency=\"Swedish krona\", #> capital_city=CapitalCity(name=\"Stockholm\", population=975904), #> ) For more details, see the Querying section.","title":"One to One"},{"location":"modeling/#one-to-many","text":"Here, we will model the relation between a customer of an online shop and his shipping addresses. A single customer can have multiple addresses but these addresses belong only to the customer's account. He should be allowed to modify them without modifying others addresses (for example if two family members use the same address, their addresses should not be linked together). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from typing import List from odmantic import AIOEngine , EmbeddedModel , Model class Address ( EmbeddedModel ): street : str city : str state : str zipcode : str class Customer ( Model ): name : str addresses : List [ Address ] customer = Customer ( name = \"John Doe\" , addresses = [ Address ( street = \"1757 Birch Street\" , city = \"Greenwood\" , state = \"Indiana\" , zipcode = \"46142\" , ), Address ( street = \"262 Barnes Avenue\" , city = \"Cincinnati\" , state = \"Ohio\" , zipcode = \"45216\" , ), ], ) engine = AIOEngine () await engine . save ( customer ) As done previously for the One to One relation, defining a One to Many relationship with Embedded Models is done exactly as defining a field with its type being a sequence of Address objects. Content of the customer collection after execution { \"_id\" : ObjectId( \"5f79eb116371e09b16e4fae4\" ) , \"name\" : \"John Doe\" , \"addresses\" :[ { \"street\" : \"1757 Birch Street\" , \"city\" : \"Greenwood\" , \"state\" : \"Indiana\" , \"zipcode\" : \"46142\" }, { \"street\" : \"262 Barnes Avenue\" , \"city\" : \"Cincinnati\" , \"state\" : \"Ohio\" , \"zipcode\" : \"45216\" } ] } Tip To add conditions on the number of embedded elements, it's possible to use the min_items and max_items arguments of the [Field][odmantic.field.Field] descriptor. Another possibility is to use the typing.Tuple type. Note Building query filters based on the content of a sequence of embedded documents is not supported yet (but this feature is planned for an upcoming release ). Anyway, it's still possible to perform the filtering operation manually using Mongo Array Operators ( $all , $elemMatch , $size ). See the Raw query usage section for more details.","title":"One to Many"},{"location":"modeling/#customization","text":"Since the Embedded Models are considered as types by ODMantic, most of the complex type constructs that could be imagined should be supported. Some ideas which could be useful: Combine two different embedded models in a single field using typing.Tuple . Allow multiple Embedded model types using a typing.Union type. Make an Embedded model not required using typing.Optional . Embed the documents in a dictionary (using the typing.Dict type) to provide an additional key-value mapping to the embedded documents. Nest embedded documents","title":"Customization"},{"location":"modeling/#referenced-models","text":"Embedded models are really simple to use but sometimes it is needed as well to have many-to-one (i.e. multiple entities referring to another single one) or many-to-many relationships. This is not really possible to model those using embedded documents and in this case, references will come handy. Another use case where references are useful is for one-to-one/one-to-many relations but when the referenced model has to exist in its own collection, in order to be accessed on its own without any parent model specified.","title":"Referenced models"},{"location":"modeling/#many-to-one-mapped","text":"In this part, we will model the relation between books and publishers. Let's consider that each book has a single publisher. In this case, multiple books could be published by the same publisher. We can thus model this relation as a many-to-one relationship. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from odmantic import AIOEngine , Model , Reference class Publisher ( Model ): name : str founded : int location : str class Book ( Model ): title : str pages : int publisher : Publisher = Reference () hachette = Publisher ( name = \"Hachette Livre\" , founded = 1826 , location = \"FR\" ) harper = Publisher ( name = \"HarperCollins\" , founded = 1989 , location = \"US\" ) books = [ Book ( title = \"They Didn't See Us Coming\" , pages = 304 , publisher = hachette ), Book ( title = \"This Isn't Happening\" , pages = 256 , publisher = hachette ), Book ( title = \"Prodigal Summer\" , pages = 464 , publisher = harper ), ] engine = AIOEngine () await engine . save_all ( books ) The definition of a reference field requires the presence of the [Reference()][odmantic.reference.Reference] descriptor. Once the models are defined, linking two instances is done simply by assigning the reference field of referencing instance to the referenced instance. Why is it required to include the Reference descriptor ? The main goal behind enforcing the presence of the descriptor is to have a clear distinction between Embedded Models and References. In the future, a generic Reference[T] type will probably be included to make this distinction since it would make more sense than having to set a descriptor for each reference. Content of the publisher collection after execution { \"_id\" : ObjectId( \"5f7a0dc48a73b20f16e2a364\" ) , \"founded\" : 1826 , \"location\" : \"FR\" , \"name\" : \"Hachette Livre\" } { \"_id\" : ObjectId( \"5f7a0dc48a73b20f16e2a365\" ) , \"founded\" : 1989 , \"location\" : \"US\" , \"name\" : \"HarperCollins\" } We can see that the publishers have been persisted to their collection even if no explicit save has been perfomed. When calling the [engine.save][odmantic.engine.AIOEngine.save] method, the engine will persist automatically the referenced documents. While fetching instances, the engine will as well resolve every reference. Content of the book collection after execution { \"_id\" : ObjectId( \"5f7a0dc48a73b20f16e2a366\" ) , \"pages\" : 304 , \"publisher\" : ObjectId( \"5f7a0dc48a73b20f16e2a364\" ) , \"title\" : \"They Didn't See Us Coming\" } { \"_id\" : ObjectId( \"5f7a0dc48a73b20f16e2a367\" ) , \"pages\" : 256 , \"publisher\" : ObjectId( \"5f7a0dc48a73b20f16e2a364\" ) , \"title\" : \"This Isn't Happening\" } { \"_id\" : ObjectId( \"5f7a0dc48a73b20f16e2a368\" ) , \"pages\" : 464 , \"publisher\" : ObjectId( \"5f7a0dc48a73b20f16e2a365\" ) , \"title\" : \"Prodigal Summer\" } The resulting books in the collection contain the publisher reference directly as a document attribute (using the reference name as the document's key). Tip It's possible to customize the foreign key storage key using the key_name argument while building the [Reference][odmantic.reference.Reference] descriptor.","title":"Many to One (Mapped)"},{"location":"modeling/#many-to-many-manual","text":"Here, we will model the relation between books and their authors. Since a book can have multiple authors and an author can be authoring multiple books, we will model this relation as a many-to-many relationship. Note Currently, ODMantic does not support mapped multi-references yet. But we will still define the relationship in a manual way. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from typing import List from bson import ObjectId from odmantic import AIOEngine , Model class Author ( Model ): name : str class Book ( Model ): title : str pages : int author_ids : List [ ObjectId ] david = Author ( name = \"David Beazley\" ) brian = Author ( name = \"Brian K. Jones\" ) python_cookbook = Book ( title = \"Python Cookbook\" , pages = 706 , author_ids = [ david . id , brian . id ] ) python_essentials = Book ( title = \"Python Essential Reference\" , pages = 717 , author_ids = [ brian . id ] ) engine = AIOEngine () await engine . save_all (( david , brian )) await engine . save_all (( python_cookbook , python_essentials )) We defined an author_ids field which holds the list of unique ids of the authors (This id field in the Author model is generated implicitly by default). Since this multi-reference is not mapped by the ODM, we have to persist the authors manually. Content of the author collection after execution { \"_id\" : ObjectId( \"5f7a37dc7311be1362e1da4e\" ) , \"name\" : \"David Beazley\" } { \"_id\" : ObjectId( \"5f7a37dc7311be1362e1da4f\" ) , \"name\" : \"Brian K. Jones\" } Content of the book collection after execution { \"_id\" : ObjectId( \"5f7a37dc7311be1362e1da50\" ) , \"title\" : \"Python Cookbook\" \"pages\" : 706 , \"author_ids\" :[ ObjectId( \"5f7a37dc7311be1362e1da4e\" ) , ObjectId( \"5f7a37dc7311be1362e1da4f\" ) ], } { \"_id\" : ObjectId( \"5f7a37dc7311be1362e1da51\" ) , \"title\" : \"Python Essential Reference\" \"pages\" : 717 , \"author_ids\" :[ ObjectId( \"5f7a37dc7311be1362e1da4f\" ) ], } Retrieving the authors of the Python Cookbook First, it's required to fetch the ids of the authors. Then we can use the [in_][odmantic.query.in_] filter to select only the authors with the desired ids. 1 2 3 4 5 6 7 book = await engine . find_one ( Book , Book . title == \"Python Cookbook\" ) authors = await engine . find ( Author , Author . id . in_ ( book . author_ids )) print ( authors ) #> [ #> Author(id=ObjectId(\"5f7a37dc7311be1362e1da4e\"), name=\"David Beazley\"), #> Author(id=ObjectId(\"5f7a37dc7311be1362e1da4f\"), name=\"Brian K. Jones\"), #> ]","title":"Many to Many (Manual)"},{"location":"querying/","text":"Querying \u00b6 Filtering \u00b6 ODMantic uses [QueryExpression][odmantic.query.QueryExpression] objects to handle filter expressions. These expressions can be built from the comparison operators. It's then possible to combine multiple expressions using the logical operators. To support the wide variety of operators provided by MongoDB, it's possible as well to define the filter 'manually'. Comparison operators \u00b6 There are multiple ways of building [QueryExpression][odmantic.query.QueryExpression] objects with comparisons operators: Using python comparison operators between the field of the model and the desired value == , != , <= , < , >= , > Using the functions provided by the odmantic.query module [query.eq][odmantic.query.eq] [query.ne][odmantic.query.ne] [query.gt][odmantic.query.gt] [query.gte][odmantic.query.gte] [query.lt][odmantic.query.lt] [query.lte][odmantic.query.lte] [query.in_][odmantic.query.in_] [query.not_in][odmantic.query.not_in] Using methods of the model's field and the desired value field.eq field.ne field.gte field.gt field.lte field.lte field.in_ field.not_in Type checkers Since there is currently not any type checker plugin, the third usage might create some errors with type checkers. Equal \u00b6 Filter the trees named \"Spruce\": 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name == \"Spruce\" #> QueryExpression({'name': {'$eq': 'Spruce'}}) Tree . name . eq ( \"Spruce\" ) #> QueryExpression({'name': {'$eq': 'Spruce'}}) query . eq ( Tree . name , \"Spruce\" ) #> QueryExpression({'name': {'$eq': 'Spruce'}}) Equivalent raw MongoDB filter: { \"name\" : \"Spruce\" } Using equality operators with Enum fields Building filters using Enum fields is possible as well. Example of filter built on an Enum field Filter the 'small' trees: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from enum import Enum from odmantic import Model , query class TreeKind ( str , Enum ): BIG = \"big\" SMALL = \"small\" class Tree ( Model ): name : str average_size : float kind : TreeKind Tree . kind == TreeKind . SMALL #> QueryExpression({'kind': {'$eq': 'small'}}) Tree . kind . eq ( TreeKind . SMALL ) #> QueryExpression({'kind': {'$eq': 'small'}}) query . eq ( Tree . kind , TreeKind . SMALL ) #> QueryExpression({'kind': {'$eq': 'small'}}) Equivalent raw MongoDB filter: { 'kind': 'small' } More details about Enum fields. Not Equal \u00b6 Filter the trees that are not named \"Spruce\": 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name != \"Spruce\" #> QueryExpression({'name': {'$ne': 'Spruce'}}) Tree . name . ne ( \"Spruce\" ) #> QueryExpression({'name': {'$ne': 'Spruce'}}) query . ne ( Tree . name , \"Spruce\" ) #> QueryExpression({'name': {'$ne': 'Spruce'}}) Equivalent raw MongoDB filter: { \"name\" : { \"$ne\" : \"Spruce\" }} Less than (or equal to) \u00b6 Filter the trees that have a size that is less than (or equal to) 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . average_size < 2 #> QueryExpression({'average_size': {'$lt': 2}}) Tree . average_size . lt ( 2 ) #> QueryExpression({'average_size': {'$lt': 2}}) query . lt ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$lt': 2}}) Tree . average_size <= 2 #> QueryExpression({'average_size': {'$lte': 2}}) Tree . average_size . lte ( 2 ) #> QueryExpression({'average_size': {'$lte': 2}}) query . lte ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$lte': 2}}) Equivalent raw MongoDB filter (less than): { \"average_size\" : { \"$lt\" : 2 }} Equivalent raw MongoDB filter (less than or equal to): { \"average_size\" : { \"$lte\" : 2 }} Greater than (or equal to) \u00b6 Filter the trees having a size that is greater than (or equal to) 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . average_size > 2 #> QueryExpression({'average_size': {'$gt': 2}}) Tree . average_size . gt ( 2 ) #> QueryExpression({'average_size': {'$gt': 2}}) query . gt ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$gt': 2}}) Tree . average_size >= 2 #> QueryExpression({'average_size': {'$gte': 2}}) Tree . average_size . gte ( 2 ) #> QueryExpression({'average_size': {'$gte': 2}}) query . gte ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$gte': 2}}) Equivalent raw MongoDB filter (greater than): { \"average_size\" : { \"$gt\" : 2 }} Equivalent raw MongoDB filter (greater than or equal to): { \"average_size\" : { \"$gte\" : 2 }} Included in \u00b6 Filter the trees named either \"Spruce\" or \"Pine\": 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name . in_ ([ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$in': ['Spruce', 'Pine']}}) query . in_ ( Tree . name , [ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$in': ['Spruce', 'Pine']}}) Equivalent raw MongoDB filter: { \"name\" : { \"$in\" : [ \"Spruce\" , \"Pine\" ]}} Not included in \u00b6 Filter the trees neither named \"Spruce\" nor \"Pine\": 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name . not_in ([ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) query . not_in ( Tree . name , [ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) Equivalent raw MongoDB filter: { \"name\" : { \"$nin\" : [ \"Spruce\" , \"Pine\" ]}} Evaluation operators \u00b6 Match (Regex) \u00b6 Filter the trees with a name starting with 'Spruce': 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Model , query class Tree ( Model ): name : str Tree . name . match ( r \"^Spruce\" ) #> QueryExpression({'name': re.compile('^Spruce')}) query . match ( Tree . name , r \"^Spruce\" ) #> QueryExpression({'name': re.compile('^Spruce')}) Equivalent raw MongoDB filter: { \"name\" : { \"$regex\" : \"^Spruce\" }} Logical operators \u00b6 There are two ways of combining [QueryExpression][odmantic.query.QueryExpression] objects with logical operators: Using python 'bitwise' operators between the field of the model and the desired value & , | Warning When using those operators make sure to correctly bracket the expressions to avoid python operator precedence issues. Using the functions provided by the odmantic.query module [query.and_][odmantic.query.and_] [query.or_][odmantic.query.or_] [query.nor_][odmantic.query.nor_] And \u00b6 Filter the trees named Spruce ( AND ) with a size less than 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import Model , query class Tree ( Model ): name : str size : float ( Tree . name == \"Spruce\" ) & ( Tree . size <= 2 ) #> QueryExpression( #> { #> \"$and\": ( #> QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}), #> QueryExpression({\"size\": {\"$lte\": 2}}), #> ) #> } #> ) query . and_ ( Tree . name == \"Spruce\" , Tree . size <= 2 ) #> ... same output ... Equivalent raw MongoDB filter: { \"name\" : \"Spruce\" , \"size\" : { \"$lte\" : 2 }} } Implicit AND When using [find][odmantic.engine.AIOEngine.find], [find_one][odmantic.engine.AIOEngine.find_one] or [count][odmantic.engine.AIOEngine.count], you can specify multiple queries as positional arguments and those will be implicitly combined with the AND operator. Or \u00b6 Filter the trees named Spruce OR the trees with a size greater than 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import Model , query class Tree ( Model ): name : str size : float ( Tree . name == \"Spruce\" ) | ( Tree . size > 2 ) #> QueryExpression( #> { #> \"$or\": ( #> QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}), #> QueryExpression({\"size\": {\"$gt\": 2}}), #> ) #> } #> ) query . or_ ( Tree . name == \"Spruce\" , Tree . size > 2 ) #> ... same output ... Equivalent raw MongoDB filter: { \"$or\" :[ { \"name\" : \"Spruce\" }, { \"size\" :{ \"$gt\" : 2 }} ] } Nor \u00b6 Filter the trees neither named Spruce NOR bigger than 2 (size): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from odmantic import Model , query class Tree ( Model ): name : str size : float query . nor_ ( Tree . name == \"Spruce\" , Tree . size > 2 ) # > QueryExpression( # > { # > \"$nor\": ( # > QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}), # > QueryExpression({\"size\": {\"$gt\": 2}}), # > ) # > } # > ) Equivalent raw MongoDB filter: { \"$nor\" :[ { \"name\" : \"Spruce\" }, { \"size\" :{ \"$gt\" : 2 }} ] } NOR Equivalence The following logical expressions are equivalent: A NOR B NOR C NOT(A OR B OR C) NOT(A) AND NOT(B) AND NOT(C) query.nor_ operator naming [query.and_][odmantic.query.and_] and [query.or_][odmantic.query.or_] require to add an extra underscore to avoid overlapping with the python keywords. While it could've been possible to name the NOR operator query.nor, the extra underscore has been kept for consistency in the naming of the logical operators. Manual filtering \u00b6 Raw MongoDB filter expressions can be used as well with the [find][odmantic.engine.AIOEngine.find], [find_one][odmantic.engine.AIOEngine.find_one] or [count][odmantic.engine.AIOEngine.count] methods. You can find more details about building raw query filters using the Model in the Raw query usage section. Embedded documents filters \u00b6 It's possible to build filter based on the content of embedded documents: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from odmantic import AIOEngine , EmbeddedModel , Model class CapitalCity ( EmbeddedModel ): name : str population : int class Country ( Model ): name : str currency : str capital_city : CapitalCity Country . capital_city . name == \"Paris\" #> QueryExpression({'capital_city.name': {'$eq': 'Paris'}}) Country . capital_city . population > 10 ** 6 #> QueryExpression({'capital_city.population': {'$gt': 1000000}}) Equivalent raw MongoDB filters: { \"capital_city.name\" : { \"$eq\" : \"Paris\" }} { \"capital_city.population\" : { \"$gt\" : 1000000 }} Filtering across References Currently, it is not possible to build filter based on referenced objects. Sorting \u00b6 ODMantic uses [SortExpression][odmantic.query.SortExpression] objects to handle sort expressions. There are multiple ways of building [SortExpression][odmantic.query.SortExpression] objects: Using implicit Model fields: Ascending sort To sort Publisher instances by ascending Publisher.founded : await engine . find ( Publisher , sort = Publisher . founded ) This example refers to the code showcased in the Overview . Using the functions provided by the odmantic.query module [query.asc][odmantic.query.asc] [query.desc][odmantic.query.desc] Using methods of the model's field and the desired value field.asc field.desc Type checkers Since there is currently not any type checker plugin, the third usage might create some errors with type checkers. Ascending \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from odmantic import AIOEngine , Model , query engine = AIOEngine () class Tree ( Model ): name : str average_size : float # The following queries are equivalent, # they will sort `Tree` by ascending `average_size` await engine . find ( Tree , sort = Tree . average_size ) await engine . find ( Tree , sort = Tree . average_size . asc ()) await engine . find ( Tree , sort = query . asc ( Tree . average_size )) Descending \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from odmantic import AIOEngine , Model , query engine = AIOEngine () class Tree ( Model ): name : str average_size : float # The following queries are equivalent, # they will sort `Tree` by descending `average_size` await engine . find ( Tree , sort = Tree . average_size . desc ()) await engine . find ( Tree , sort = query . desc ( Tree . average_size )) Sort on multiple fields \u00b6 We can pass a tuple to the sort kwarg, this will enable us to make a more complex sort query: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model , query engine = AIOEngine () class Tree ( Model ): name : str average_size : float # This query will first sort on ascending `average_size`, then # on descending `name` when `average_size` is the same await engine . find ( Tree , sort = ( Tree . average_size , Tree . name . desc ())) Embedded model field as a sort key \u00b6 We can sort instances based on the content of their embedded models. Sorting by an embedded model field We can sort the countries by descending order of the population of their capital city: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from odmantic import AIOEngine , EmbeddedModel , Model from odmantic.query import desc class CapitalCity ( EmbeddedModel ): name : str population : int class Country ( Model ): name : str currency : str capital_city : CapitalCity engine = AIOEngine () await engine . find ( Country , sort = desc ( Country . capital_city . population ))","title":"Querying"},{"location":"querying/#querying","text":"","title":"Querying"},{"location":"querying/#filtering","text":"ODMantic uses [QueryExpression][odmantic.query.QueryExpression] objects to handle filter expressions. These expressions can be built from the comparison operators. It's then possible to combine multiple expressions using the logical operators. To support the wide variety of operators provided by MongoDB, it's possible as well to define the filter 'manually'.","title":"Filtering"},{"location":"querying/#comparison-operators","text":"There are multiple ways of building [QueryExpression][odmantic.query.QueryExpression] objects with comparisons operators: Using python comparison operators between the field of the model and the desired value == , != , <= , < , >= , > Using the functions provided by the odmantic.query module [query.eq][odmantic.query.eq] [query.ne][odmantic.query.ne] [query.gt][odmantic.query.gt] [query.gte][odmantic.query.gte] [query.lt][odmantic.query.lt] [query.lte][odmantic.query.lte] [query.in_][odmantic.query.in_] [query.not_in][odmantic.query.not_in] Using methods of the model's field and the desired value field.eq field.ne field.gte field.gt field.lte field.lte field.in_ field.not_in Type checkers Since there is currently not any type checker plugin, the third usage might create some errors with type checkers.","title":"Comparison operators"},{"location":"querying/#equal","text":"Filter the trees named \"Spruce\": 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name == \"Spruce\" #> QueryExpression({'name': {'$eq': 'Spruce'}}) Tree . name . eq ( \"Spruce\" ) #> QueryExpression({'name': {'$eq': 'Spruce'}}) query . eq ( Tree . name , \"Spruce\" ) #> QueryExpression({'name': {'$eq': 'Spruce'}}) Equivalent raw MongoDB filter: { \"name\" : \"Spruce\" } Using equality operators with Enum fields Building filters using Enum fields is possible as well. Example of filter built on an Enum field Filter the 'small' trees: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from enum import Enum from odmantic import Model , query class TreeKind ( str , Enum ): BIG = \"big\" SMALL = \"small\" class Tree ( Model ): name : str average_size : float kind : TreeKind Tree . kind == TreeKind . SMALL #> QueryExpression({'kind': {'$eq': 'small'}}) Tree . kind . eq ( TreeKind . SMALL ) #> QueryExpression({'kind': {'$eq': 'small'}}) query . eq ( Tree . kind , TreeKind . SMALL ) #> QueryExpression({'kind': {'$eq': 'small'}}) Equivalent raw MongoDB filter: { 'kind': 'small' } More details about Enum fields.","title":"Equal"},{"location":"querying/#not-equal","text":"Filter the trees that are not named \"Spruce\": 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name != \"Spruce\" #> QueryExpression({'name': {'$ne': 'Spruce'}}) Tree . name . ne ( \"Spruce\" ) #> QueryExpression({'name': {'$ne': 'Spruce'}}) query . ne ( Tree . name , \"Spruce\" ) #> QueryExpression({'name': {'$ne': 'Spruce'}}) Equivalent raw MongoDB filter: { \"name\" : { \"$ne\" : \"Spruce\" }}","title":"Not Equal"},{"location":"querying/#less-than-or-equal-to","text":"Filter the trees that have a size that is less than (or equal to) 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . average_size < 2 #> QueryExpression({'average_size': {'$lt': 2}}) Tree . average_size . lt ( 2 ) #> QueryExpression({'average_size': {'$lt': 2}}) query . lt ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$lt': 2}}) Tree . average_size <= 2 #> QueryExpression({'average_size': {'$lte': 2}}) Tree . average_size . lte ( 2 ) #> QueryExpression({'average_size': {'$lte': 2}}) query . lte ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$lte': 2}}) Equivalent raw MongoDB filter (less than): { \"average_size\" : { \"$lt\" : 2 }} Equivalent raw MongoDB filter (less than or equal to): { \"average_size\" : { \"$lte\" : 2 }}","title":"Less than (or equal to)"},{"location":"querying/#greater-than-or-equal-to","text":"Filter the trees having a size that is greater than (or equal to) 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . average_size > 2 #> QueryExpression({'average_size': {'$gt': 2}}) Tree . average_size . gt ( 2 ) #> QueryExpression({'average_size': {'$gt': 2}}) query . gt ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$gt': 2}}) Tree . average_size >= 2 #> QueryExpression({'average_size': {'$gte': 2}}) Tree . average_size . gte ( 2 ) #> QueryExpression({'average_size': {'$gte': 2}}) query . gte ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$gte': 2}}) Equivalent raw MongoDB filter (greater than): { \"average_size\" : { \"$gt\" : 2 }} Equivalent raw MongoDB filter (greater than or equal to): { \"average_size\" : { \"$gte\" : 2 }}","title":"Greater than (or equal to)"},{"location":"querying/#included-in","text":"Filter the trees named either \"Spruce\" or \"Pine\": 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name . in_ ([ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$in': ['Spruce', 'Pine']}}) query . in_ ( Tree . name , [ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$in': ['Spruce', 'Pine']}}) Equivalent raw MongoDB filter: { \"name\" : { \"$in\" : [ \"Spruce\" , \"Pine\" ]}}","title":"Included in"},{"location":"querying/#not-included-in","text":"Filter the trees neither named \"Spruce\" nor \"Pine\": 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name . not_in ([ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) query . not_in ( Tree . name , [ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) Equivalent raw MongoDB filter: { \"name\" : { \"$nin\" : [ \"Spruce\" , \"Pine\" ]}}","title":"Not included in"},{"location":"querying/#evaluation-operators","text":"","title":"Evaluation operators"},{"location":"querying/#match-regex","text":"Filter the trees with a name starting with 'Spruce': 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Model , query class Tree ( Model ): name : str Tree . name . match ( r \"^Spruce\" ) #> QueryExpression({'name': re.compile('^Spruce')}) query . match ( Tree . name , r \"^Spruce\" ) #> QueryExpression({'name': re.compile('^Spruce')}) Equivalent raw MongoDB filter: { \"name\" : { \"$regex\" : \"^Spruce\" }}","title":"Match (Regex)"},{"location":"querying/#logical-operators","text":"There are two ways of combining [QueryExpression][odmantic.query.QueryExpression] objects with logical operators: Using python 'bitwise' operators between the field of the model and the desired value & , | Warning When using those operators make sure to correctly bracket the expressions to avoid python operator precedence issues. Using the functions provided by the odmantic.query module [query.and_][odmantic.query.and_] [query.or_][odmantic.query.or_] [query.nor_][odmantic.query.nor_]","title":"Logical operators"},{"location":"querying/#and","text":"Filter the trees named Spruce ( AND ) with a size less than 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import Model , query class Tree ( Model ): name : str size : float ( Tree . name == \"Spruce\" ) & ( Tree . size <= 2 ) #> QueryExpression( #> { #> \"$and\": ( #> QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}), #> QueryExpression({\"size\": {\"$lte\": 2}}), #> ) #> } #> ) query . and_ ( Tree . name == \"Spruce\" , Tree . size <= 2 ) #> ... same output ... Equivalent raw MongoDB filter: { \"name\" : \"Spruce\" , \"size\" : { \"$lte\" : 2 }} } Implicit AND When using [find][odmantic.engine.AIOEngine.find], [find_one][odmantic.engine.AIOEngine.find_one] or [count][odmantic.engine.AIOEngine.count], you can specify multiple queries as positional arguments and those will be implicitly combined with the AND operator.","title":"And"},{"location":"querying/#or","text":"Filter the trees named Spruce OR the trees with a size greater than 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import Model , query class Tree ( Model ): name : str size : float ( Tree . name == \"Spruce\" ) | ( Tree . size > 2 ) #> QueryExpression( #> { #> \"$or\": ( #> QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}), #> QueryExpression({\"size\": {\"$gt\": 2}}), #> ) #> } #> ) query . or_ ( Tree . name == \"Spruce\" , Tree . size > 2 ) #> ... same output ... Equivalent raw MongoDB filter: { \"$or\" :[ { \"name\" : \"Spruce\" }, { \"size\" :{ \"$gt\" : 2 }} ] }","title":"Or"},{"location":"querying/#nor","text":"Filter the trees neither named Spruce NOR bigger than 2 (size): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from odmantic import Model , query class Tree ( Model ): name : str size : float query . nor_ ( Tree . name == \"Spruce\" , Tree . size > 2 ) # > QueryExpression( # > { # > \"$nor\": ( # > QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}), # > QueryExpression({\"size\": {\"$gt\": 2}}), # > ) # > } # > ) Equivalent raw MongoDB filter: { \"$nor\" :[ { \"name\" : \"Spruce\" }, { \"size\" :{ \"$gt\" : 2 }} ] } NOR Equivalence The following logical expressions are equivalent: A NOR B NOR C NOT(A OR B OR C) NOT(A) AND NOT(B) AND NOT(C) query.nor_ operator naming [query.and_][odmantic.query.and_] and [query.or_][odmantic.query.or_] require to add an extra underscore to avoid overlapping with the python keywords. While it could've been possible to name the NOR operator query.nor, the extra underscore has been kept for consistency in the naming of the logical operators.","title":"Nor"},{"location":"querying/#manual-filtering","text":"Raw MongoDB filter expressions can be used as well with the [find][odmantic.engine.AIOEngine.find], [find_one][odmantic.engine.AIOEngine.find_one] or [count][odmantic.engine.AIOEngine.count] methods. You can find more details about building raw query filters using the Model in the Raw query usage section.","title":"Manual filtering"},{"location":"querying/#embedded-documents-filters","text":"It's possible to build filter based on the content of embedded documents: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from odmantic import AIOEngine , EmbeddedModel , Model class CapitalCity ( EmbeddedModel ): name : str population : int class Country ( Model ): name : str currency : str capital_city : CapitalCity Country . capital_city . name == \"Paris\" #> QueryExpression({'capital_city.name': {'$eq': 'Paris'}}) Country . capital_city . population > 10 ** 6 #> QueryExpression({'capital_city.population': {'$gt': 1000000}}) Equivalent raw MongoDB filters: { \"capital_city.name\" : { \"$eq\" : \"Paris\" }} { \"capital_city.population\" : { \"$gt\" : 1000000 }} Filtering across References Currently, it is not possible to build filter based on referenced objects.","title":"Embedded documents filters"},{"location":"querying/#sorting","text":"ODMantic uses [SortExpression][odmantic.query.SortExpression] objects to handle sort expressions. There are multiple ways of building [SortExpression][odmantic.query.SortExpression] objects: Using implicit Model fields: Ascending sort To sort Publisher instances by ascending Publisher.founded : await engine . find ( Publisher , sort = Publisher . founded ) This example refers to the code showcased in the Overview . Using the functions provided by the odmantic.query module [query.asc][odmantic.query.asc] [query.desc][odmantic.query.desc] Using methods of the model's field and the desired value field.asc field.desc Type checkers Since there is currently not any type checker plugin, the third usage might create some errors with type checkers.","title":"Sorting"},{"location":"querying/#ascending","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from odmantic import AIOEngine , Model , query engine = AIOEngine () class Tree ( Model ): name : str average_size : float # The following queries are equivalent, # they will sort `Tree` by ascending `average_size` await engine . find ( Tree , sort = Tree . average_size ) await engine . find ( Tree , sort = Tree . average_size . asc ()) await engine . find ( Tree , sort = query . asc ( Tree . average_size ))","title":"Ascending"},{"location":"querying/#descending","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from odmantic import AIOEngine , Model , query engine = AIOEngine () class Tree ( Model ): name : str average_size : float # The following queries are equivalent, # they will sort `Tree` by descending `average_size` await engine . find ( Tree , sort = Tree . average_size . desc ()) await engine . find ( Tree , sort = query . desc ( Tree . average_size ))","title":"Descending"},{"location":"querying/#sort-on-multiple-fields","text":"We can pass a tuple to the sort kwarg, this will enable us to make a more complex sort query: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model , query engine = AIOEngine () class Tree ( Model ): name : str average_size : float # This query will first sort on ascending `average_size`, then # on descending `name` when `average_size` is the same await engine . find ( Tree , sort = ( Tree . average_size , Tree . name . desc ()))","title":"Sort on multiple fields"},{"location":"querying/#embedded-model-field-as-a-sort-key","text":"We can sort instances based on the content of their embedded models. Sorting by an embedded model field We can sort the countries by descending order of the population of their capital city: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from odmantic import AIOEngine , EmbeddedModel , Model from odmantic.query import desc class CapitalCity ( EmbeddedModel ): name : str population : int class Country ( Model ): name : str currency : str capital_city : CapitalCity engine = AIOEngine () await engine . find ( Country , sort = desc ( Country . capital_city . population ))","title":"Embedded model field as a sort key"},{"location":"raw_query_usage/","text":"Raw query usage \u00b6 As ODMantic doesn't completely wrap the MongoDB API, some helpers are provided to be enhance the usability while building raw queries and interacting with raw documents. Raw query helpers \u00b6 Collection name \u00b6 You can get the collection name associated to a model by using the unary + operator on the model class. 1 2 3 4 5 6 7 8 9 10 from odmantic import Model class User ( Model ): name : str collection_name = + User print ( collection_name ) #> user Motor collection \u00b6 The [AIOEngine][odmantic.engine.AIOEngine] object can provide you directly the motor collection ( AsyncIOMotorCollection ) linked to the motor client used by the engine. To achieve this, you can use the [AIOEngine.get_collection][odmantic.engine.AIOEngine.get_collection] method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from odmantic import AIOEngine , Model class User ( Model ): name : str engine = AIOEngine () motor_collection = engine . get_collection ( User ) print ( motor_collection ) #> AsyncIOMotorCollection( #> Collection( #> Database( #> MongoClient( #> host=[\"localhost:27017\"], #> document_class=dict, #> tz_aware=False, #> connect=False, #> driver=DriverInfo(name=\"Motor\", version=\"2.2.0\", platform=\"asyncio\"), #> ), #> \"test\", #> ), #> \"user\", #> ) #> ) Key name of a field \u00b6 Since some field might have some customized key names , you can get the key name associated to a field by using the unary + operator on the model class. As well, to ease the use of aggregation pipelines where you might need to reference your field ( $field ), you can double the operator (i.e use ++ ) to get the field reference name. 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) print ( + User . name ) #> username print ( ++ User . name ) #> $username Creating instances from raw documents \u00b6 You can parse MongoDB document to instances using the [parse_doc][odmantic.model._BaseODMModel.parse_doc] method. Note If the provided documents contain extra fields, ODMantic will ignore them. This can be especially useful in aggregation pipelines. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from bson import ObjectId from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) document = { \"username\" : \"John\" , \"_id\" : ObjectId ( \"5f8352a87a733b8b18b0cb27\" )} user = User . parse_doc ( document ) print ( user ) #> id=ObjectId('5f8352a87a733b8b18b0cb27') name='John' Extract documents from existing instances \u00b6 You can generate a document from instances using the [doc][odmantic.model._BaseODMModel.doc] method. 1 2 3 4 5 6 7 8 9 10 from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) user = User ( name = \"John\" ) print ( user . doc ()) #> {'username': 'John', '_id': ObjectId('5f8352a87a733b8b18b0cb27')} Aggregation example \u00b6 In the following example, we will demonstrate the use of the previous helpers to build an aggregation pipeline. We will first consider a Rectangle model with two float fields ( height and length ). We will then fetch the rectangles with an area that is less than 10. To finish, we will reconstruct Rectangle instances from this query. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 from odmantic import AIOEngine , Model class Rectangle ( Model ): length : float width : float rectangles = [ Rectangle ( length = 0.1 , width = 1 ), Rectangle ( length = 3.5 , width = 1 ), Rectangle ( length = 2.87 , width = 5.19 ), Rectangle ( length = 1 , width = 10 ), Rectangle ( length = 0.1 , width = 100 ), ] engine = AIOEngine () await engine . save_all ( rectangles ) collection = engine . get_collection ( Rectangle ) pipeline = [] # Add an area field pipeline . append ( { \"$addFields\" : { \"area\" : { \"$multiply\" : [ ++ Rectangle . length , ++ Rectangle . width ] } # Compute the area remotely } } ) # Filter only rectanges with an area lower than 10 pipeline . append ({ \"$match\" : { \"area\" : { \"$lt\" : 10 }}}) # Project to keep only the defined fields (this step is optional) pipeline . append ( { \"$project\" : { + Rectangle . length : True , + Rectangle . width : True , } # Specifying \"area\": False is unnecessary here } ) documents = await collection . aggregate ( pipeline ) . to_list ( length = None ) small_rectangles = [ Rectangle . parse_doc ( doc ) for doc in documents ] print ( small_rectangles ) #> [ #> Rectangle(id=ObjectId(\"...\"), length=0.1, width=1.0), #> Rectangle(id=ObjectId(\"...\"), length=3.5, width=1.0), #> ]","title":"Raw query usage"},{"location":"raw_query_usage/#raw-query-usage","text":"As ODMantic doesn't completely wrap the MongoDB API, some helpers are provided to be enhance the usability while building raw queries and interacting with raw documents.","title":"Raw query usage"},{"location":"raw_query_usage/#raw-query-helpers","text":"","title":"Raw query helpers"},{"location":"raw_query_usage/#collection-name","text":"You can get the collection name associated to a model by using the unary + operator on the model class. 1 2 3 4 5 6 7 8 9 10 from odmantic import Model class User ( Model ): name : str collection_name = + User print ( collection_name ) #> user","title":"Collection name"},{"location":"raw_query_usage/#motor-collection","text":"The [AIOEngine][odmantic.engine.AIOEngine] object can provide you directly the motor collection ( AsyncIOMotorCollection ) linked to the motor client used by the engine. To achieve this, you can use the [AIOEngine.get_collection][odmantic.engine.AIOEngine.get_collection] method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from odmantic import AIOEngine , Model class User ( Model ): name : str engine = AIOEngine () motor_collection = engine . get_collection ( User ) print ( motor_collection ) #> AsyncIOMotorCollection( #> Collection( #> Database( #> MongoClient( #> host=[\"localhost:27017\"], #> document_class=dict, #> tz_aware=False, #> connect=False, #> driver=DriverInfo(name=\"Motor\", version=\"2.2.0\", platform=\"asyncio\"), #> ), #> \"test\", #> ), #> \"user\", #> ) #> )","title":"Motor collection"},{"location":"raw_query_usage/#key-name-of-a-field","text":"Since some field might have some customized key names , you can get the key name associated to a field by using the unary + operator on the model class. As well, to ease the use of aggregation pipelines where you might need to reference your field ( $field ), you can double the operator (i.e use ++ ) to get the field reference name. 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) print ( + User . name ) #> username print ( ++ User . name ) #> $username","title":"Key name of a field"},{"location":"raw_query_usage/#creating-instances-from-raw-documents","text":"You can parse MongoDB document to instances using the [parse_doc][odmantic.model._BaseODMModel.parse_doc] method. Note If the provided documents contain extra fields, ODMantic will ignore them. This can be especially useful in aggregation pipelines. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from bson import ObjectId from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) document = { \"username\" : \"John\" , \"_id\" : ObjectId ( \"5f8352a87a733b8b18b0cb27\" )} user = User . parse_doc ( document ) print ( user ) #> id=ObjectId('5f8352a87a733b8b18b0cb27') name='John'","title":"Creating instances from raw documents"},{"location":"raw_query_usage/#extract-documents-from-existing-instances","text":"You can generate a document from instances using the [doc][odmantic.model._BaseODMModel.doc] method. 1 2 3 4 5 6 7 8 9 10 from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) user = User ( name = \"John\" ) print ( user . doc ()) #> {'username': 'John', '_id': ObjectId('5f8352a87a733b8b18b0cb27')}","title":"Extract documents from existing instances"},{"location":"raw_query_usage/#aggregation-example","text":"In the following example, we will demonstrate the use of the previous helpers to build an aggregation pipeline. We will first consider a Rectangle model with two float fields ( height and length ). We will then fetch the rectangles with an area that is less than 10. To finish, we will reconstruct Rectangle instances from this query. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 from odmantic import AIOEngine , Model class Rectangle ( Model ): length : float width : float rectangles = [ Rectangle ( length = 0.1 , width = 1 ), Rectangle ( length = 3.5 , width = 1 ), Rectangle ( length = 2.87 , width = 5.19 ), Rectangle ( length = 1 , width = 10 ), Rectangle ( length = 0.1 , width = 100 ), ] engine = AIOEngine () await engine . save_all ( rectangles ) collection = engine . get_collection ( Rectangle ) pipeline = [] # Add an area field pipeline . append ( { \"$addFields\" : { \"area\" : { \"$multiply\" : [ ++ Rectangle . length , ++ Rectangle . width ] } # Compute the area remotely } } ) # Filter only rectanges with an area lower than 10 pipeline . append ({ \"$match\" : { \"area\" : { \"$lt\" : 10 }}}) # Project to keep only the defined fields (this step is optional) pipeline . append ( { \"$project\" : { + Rectangle . length : True , + Rectangle . width : True , } # Specifying \"area\": False is unnecessary here } ) documents = await collection . aggregate ( pipeline ) . to_list ( length = None ) small_rectangles = [ Rectangle . parse_doc ( doc ) for doc in documents ] print ( small_rectangles ) #> [ #> Rectangle(id=ObjectId(\"...\"), length=0.1, width=1.0), #> Rectangle(id=ObjectId(\"...\"), length=3.5, width=1.0), #> ]","title":"Aggregation example"},{"location":"usage_fastapi/","text":"Usage with FastAPI \u00b6 Example \u00b6 In this example, we create a minimalist REST API describing trees by their name, average size and discovery year. Requirements To run the following example, you'll need to install FastAPI and Uvicorn. pip install fastapi uvicorn 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from typing import List from fastapi import FastAPI , HTTPException from odmantic import AIOEngine , Model , ObjectId class Tree ( Model ): name : str average_size : float discovery_year : int app = FastAPI () engine = AIOEngine () @app . put ( \"/trees/\" , response_model = Tree ) async def create_tree ( tree : Tree ): await engine . save ( tree ) return tree @app . get ( \"/trees/\" , response_model = List [ Tree ]) async def get_trees (): trees = await engine . find ( Tree ) return trees @app . get ( \"/trees/count\" , response_model = int ) async def count_trees (): count = await engine . count ( Tree ) return count @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree You can then start the application. For example if you saved the file above in a file named tree_api.py : uvicorn tree_api : app Uvicorn should start serving the API locally: INFO: Started server process [21429] INFO: Waiting for application startup. INFO: Application startup complete. INFO: Uvicorn running on http://localhost:8080 (Press CTRL+C to quit) To try it out, you can simply access the interactive documentation generated by FastAPI at http://localhost:8080/docs . We'll now dive in the details of this example. Defining the model \u00b6 First, we create our Tree model. class Tree ( Model ): name : str average_size : float discovery_year : int This describes our Tree instances structure both for JSON serialization and for the storage in the MongoDB collection. Building the engine \u00b6 After having defined the model, we create the [AIOEngine][odmantic.engine.AIOEngine] object. This object will be responsible for performing database operations. engine = AIOEngine () It's possible as well to build the engine with custom parameters (mongo URI, database name). See this section for more details. Running the python file directly If you need to execute the python file directly with the interpreter (to use a debugger for example), some extra steps will be required. Run uvicorn using the default event loop (if the file is called directly): if __name__ == \"__main__\" : import asyncio import uvicorn loop = asyncio . get_event_loop () config = uvicorn . Config ( app = app , port = 8080 , loop = loop ) server = uvicorn . Server ( config ) loop . run_until_complete ( server . serve ()) uvicorn.run behavior with event loops (Advanced) The usual entrypoint uvicorn.run(app) for ASGI apps doesn't work because when called uvicorn will create and run a brand new event loop. Thus, the engine object will be bound to a different event loop that will not be running. In this case, you'll witness <Future pending> attached to a different loop errors because the app itself will be running in a different event loop than the engine's driver. Anyway, when running directly the app through the uvicorn CLI, the default event loop will be the one that will be running later, so no modifications are required. AIOEngineDependency deprecation (from v0.2.0) The AIOEngineDependency that was used to inject the engine in the API routes is now deprecated (it will be kept for few versions though). Using a global engine object should be preferred as it will dramatically reduce the required verbosity to use the engine in an endpoint. If you need to run your app directly from a python file, see the above Running the python file directly section. Creating a tree \u00b6 The next step is to define a route enabling us to create a new tree. To that end, we create a PUT route with the path /trees/ . This endpoint will receive a tree, persist it to the database and return the created object. @app . put ( \"/trees/\" , response_model = Tree ) async def create_tree ( tree : Tree ): await engine . save ( tree ) return tree First, the request body will be parsed to a Tree object (this is done by specifying the argument tree: Tree ). This mean that the model validation will be performed. Once the model is parsed to a Tree instance, we persist it to the database and we return it. Command line tool for interacting with JSON based HTTP APIs To interact with the API from the command line, we recommend to use the HTTPie CLI. The next examples are still provided with the curl syntax since the Swagger documentation generated by FastAPI will give you curl examples directly. Creating a Tree from the command line HTTPie Send the request: http PUT localhost:8080/trees/ name = \"Spruce\" discovery_year = 1995 average_size = 2 Output: HTTP/1.1 200 OK content-length: 90 content-type: application/json date: Sun, 18 Oct 2020 18:40:30 GMT server: uvicorn { \"average_size\": 2.0, \"discovery_year\": 1995, \"id\": \"5f8c8c1ff1d33aa1012f3086\", \"name\": \"Spruce\" } curl Send the request: curl -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Spruce\", \"discovery_year\":1995, \"average_size\":2}' Output: {\"name\":\"Spruce\",\"average_size\":2.0,\"discovery_year\":1995,\"id\":\"5f8c8c1ff1d33aa1012f3086\"} You can notice that the id field has been added automatically by ODMantic. This id field is actually not required since it's defined automatically by ODMantic with a default factory method ( more details ). You can still specify this field in the request body to predefine the id of the created instance or to overwrite an existing instance. Why PUT instead of POST ? Since the engine.save behave as an upsert operation ( more details ), you can overwrite instances stored in the database by creating a new instance with the same id and calling the engine.save method. Modifying the Tree from the command line To overwrite the tree with id=5f8c8c1ff1d33aa1012f3086 : HTTPie Send the request: http PUT localhost:8080/trees/ \\ name = \"Norway Spruce\" discovery_year = 1795 \\ average_size = 200 id = \"5f8c8c1ff1d33aa1012f3086\" Output: HTTP/1.1 200 OK content-length: 90 content-type: application/json date: Sun, 18 Oct 2020 18:40:30 GMT server: uvicorn { \"average_size\": 200.0, \"discovery_year\": 1795, \"id\": \"5f8c8c1ff1d33aa1012f3086\", \"name\": \"Norway Spruce\" } curl Send the request: curl -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Norway Spruce\", \"discovery_year\":1795, \"average_size\":200, \"id\":\"5f8c8c1ff1d33aa1012f3086\"}' Output: {\"name\":\"Norway Spruce\",\"average_size\":200.0,\"discovery_year\":1795,\"id\":\"5f8c8c1ff1d33aa1012f3086\"} Since we can modify an existing instance, it makes more sense to define the operation as a PUT instead of a POST that should create a new resource on each call. If the request body doesn't match our model schema, a 422 Unprocessable Entity error will be returned by the API, containing the details about the error. Invalid data while creating the Tree from the command line You can try by omitting the average_size field: HTTPie Send the request: http PUT localhost:8080/trees/ name = \"Spruce\" discovery_year = 1995 Output: HTTP/1.1 422 Unprocessable Entity content-length: 96 content-type: application/json date: Sun, 18 Oct 2020 16:42:18 GMT server: uvicorn { \"detail\": [ { \"loc\": [ \"body\", \"average_size\" ], \"msg\": \"field required\", \"type\": \"value_error.missing\" } ] } curl Send the request: curl -v -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Spruce\", \"discovery_year\":1995}' Output: * Trying 127.0.0.1... * TCP_NODELAY set * Connected to localhost (127.0.0.1) port 8080 (#0) > PUT /trees/ HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.58.0 > Accept: */* > Content-Type: application/json > Content-Length: 40 > * upload completely sent off: 40 out of 40 bytes < HTTP/1.1 422 Unprocessable Entity < date: Sun, 18 Oct 2020 18:51:33 GMT < server: uvicorn < content-length: 96 < content-type: application/json < * Connection #0 to host localhost left intact {\"detail\":[{\"loc\":[\"body\",\"average_size\"],\"msg\":\"field required\",\"type\":\"value_error.missing\"}]}% The validation error structure is the one that is defined by the Pydantic: ValidationError exception. Finally, specifying the response_model in the app.put decorator is not mandatory but it is strongly advised as it helps FastAPI to generate the documentation. Getting all the trees \u00b6 To get the trees stored in the database, we use the [AIOEngine.find][odmantic.engine.AIOEngine.find] method in its awaitable form ( more details ), this gives us directly the list of Tree instances that we can return directly: @app . get ( \"/trees/\" , response_model = List [ Tree ]) async def get_trees (): trees = await engine . find ( Tree ) return trees Creating and getting the trees from the command line HTTPie Create some trees: http PUT localhost:8080/trees/ name = \"Spruce\" discovery_year = 1995 average_size = 10 .2 http PUT localhost:8080/trees/ name = \"Pine\" discovery_year = 1850 average_size = 5 Get the trees: http localhost:8080/trees/ Output: HTTP/1.1 200 OK content-length: 270 content-type: application/json date: Sun, 18 Oct 2020 17:59:10 GMT server: uvicorn [ { \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\", \"name\": \"Spruce\" }, { \"average_size\": 5.0, \"discovery_year\": 1850, \"id\": \"5f8c8266f1d33aa1012f3083\", \"name\": \"Pine\" } ] curl Create some trees: curl -v -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Spruce\", \"discovery_year\":1995, \"average_size\":10.2}' curl -v -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Pine\", \"discovery_year\":1850, \"average_size\":5}' Get the trees: curl http://localhost:8080/trees/ | python -mjson.tool Output: [ { \"name\": \"Spruce\", \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\" }, { \"name\": \"Pine\", \"average_size\": 5.0, \"discovery_year\": 1850, \"id\": \"5f8c8266f1d33aa1012f3083\" } ] Pagination You can add pagination to this GET request by using the skip and limit arguments while calling the [AIOEngine.find][odmantic.engine.AIOEngine.find] method. Counting the trees \u00b6 To get the number of trees stored in the database, we use the [AIOEngine.count][odmantic.engine.AIOEngine.count] method without specifying any query parameters (to directly get the total count of instances). @app . get ( \"/trees/count\" , response_model = int ) async def count_trees (): count = await engine . count ( Tree ) return count Getting the tree count from the command line HTTPie Get the count: http localhost:8080/trees/count Output: HTTP/1.1 200 OK content-length: 1 content-type: application/json date: Sun, 18 Oct 2020 20:16:50 GMT server: uvicorn 2 curl Get the count: curl http://localhost:8080/trees/count Output: 2 Getting a tree by id \u00b6 @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId , ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree To return a tree from its id we add a path parameter id: ObjectId . Once this endpoint is called, FastAPI will try to validate this query parameter, thus inferring an ObjectId object. Using BSON objects as parameters While you can define ODMantic models directly using bson fields ( more details ), it's not possible to use those types directly with FastAPI, you'll need to get the equivalent objects from the odmantic.bson module. Those equivalent types implement the additional validation logic enabling FastAPI to work with them. from odmantic.bson import ObjectId For convenience reasons, the ObjectId type including the validation logic is as well available directly from the odmantic module. from odmantic import ObjectId With this ObjectId , we build a query that will filter only the instances having this exactly same id : Tree . id == id Then, we pass this query to the [AIOEngine.find_one][odmantic.engine.AIOEngine.find_one] method that will try to return an instance, otherwise None will be returned: tree = await engine . find_one ( Tree , Tree . id == id ) Now, if our tree object is None (i.e the instance has not been found), we need to return a 404 Not Found error: if tree is None : raise HTTPException ( 404 ) Otherwise, we found the requested instance. We can return it ! return tree Getting a tree from the command line HTTPie Get the tree 5f8c8266f1d33aa1012f3082 : http localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: HTTP/1.1 200 OK content-length: 91 content-type: application/json date: Sun, 18 Oct 2020 21:08:07 GMT server: uvicorn { \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\", \"name\": \"Spruce\" } curl Get the tree 5f8c8266f1d33aa1012f3082 : curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: {\"name\":\"Spruce\",\"average_size\":10.2,\"discovery_year\":1995,\"id\":\"5f8c8266f1d33aa1012f3082\"} Trying to get a tree not in the database from the command line HTTPie Try to get the tree f0f0f0f0f0f0f0f0f0f0f0f0 (it has not been created): http localhost:8080/trees/f0f0f0f0f0f0f0f0f0f0f0f0 Output: HTTP/1.1 404 Not Found content-length: 22 content-type: application/json date: Sun, 18 Oct 2020 21:11:48 GMT server: uvicorn { \"detail\": \"Not Found\" } curl Try to get the tree f0f0f0f0f0f0f0f0f0f0f0f0 (it has not been created): curl http://localhost:8080/trees/f0f0f0f0f0f0f0f0f0f0f0f0 Output: {\"detail\":\"Not Found\"} This id path parameter should be a 16 characters hexadecimal string (see MongoDB: ObjectId for more details). If the id specified in the path does not match this criteria, a 422 Unprocessable Entity error will be returned: Trying to get a tree with an invalid id from the command line HTTPie Get the tree identified by invalid_object_id : http localhost:8080/trees/invalid_object_id Output: HTTP/1.1 422 Unprocessable Entity content-length: 89 content-type: application/json date: Sun, 18 Oct 2020 20:50:25 GMT server: uvicorn { \"detail\": [ { \"loc\": [ \"path\", \"id\" ], \"msg\": \"invalid ObjectId specified\", \"type\": \"type_error\" } ] } curl Get the tree identified by invalid_object_id : curl http://localhost:8080/trees/invalid_object_id Output: {\"detail\":[{\"loc\":[\"path\",\"id\"],\"msg\":\"invalid ObjectId specified\",\"type\":\"type_error\"}]} Extending the example \u00b6 Deleting a tree \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import uvicorn from fastapi import FastAPI , HTTPException from odmantic import AIOEngine , Model , ObjectId class Tree ( Model ): name : str average_size : float discovery_year : int app = FastAPI () engine = AIOEngine () @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree @app . delete ( \"/trees/ {id} \" , response_model = Tree ) async def delete_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) await engine . delete ( tree ) return tree This new DELETE route is strongly inspired from the one used to get a tree from its id . Currently, ODMantic can only delete an instance and it's not possible to perform a delete operation from a query filter. Thus, we first need to get the associated instance. Once we have the instance, we call the [AIOEngine.delete][odmantic.engine.AIOEngine.delete] method to perform the deletion. Deleting a tree from the command line HTTPie Delete the tree identified by 5f8c8266f1d33aa1012f3082 : http DELETE localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: HTTP/1.1 200 OK content-length: 91 content-type: application/json date: Sun, 18 Oct 2020 21:35:22 GMT server: uvicorn { \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\", \"name\": \"Spruce\" } Check that the tree is not stored anymore: http localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: HTTP/1.1 404 Not Found content-length: 22 content-type: application/json date: Sun, 18 Oct 2020 21:36:45 GMT server: uvicorn { \"detail\": \"Not Found\" } curl Delete the tree identified by 5f8c8266f1d33aa1012f3082 : curl -X DELETE http://localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: {\"name\":\"Spruce\",\"average_size\":10.2,\"discovery_year\":1995,\"id\":\"5f8c8266f1d33aa1012f3082\"} Check that the tree is not stored anymore: curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: {\"detail\":\"Not Found\"} The tree has been removed successfully ! Updating a tree \u00b6 We already defined a PUT route that enables us to modify (replace) a tree instance. However, with this previopus implementation, it's not possible to specify only the fields that we want to change as the whole Tree instance is rebuilt from the request's body. In this example, we will define a PATCH method that will allow us to modify some fields of a Tree instance: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 from typing import Optional import uvicorn from fastapi import FastAPI , HTTPException from pydantic import BaseModel from odmantic import AIOEngine , Model , ObjectId class Tree ( Model ): name : str average_size : float discovery_year : int app = FastAPI () engine = AIOEngine () @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree class TreePatchSchema ( BaseModel ): name : Optional [ str ] average_size : Optional [ float ] discovery_year : Optional [ float ] @app . patch ( \"/trees/ {id} \" , response_model = Tree ) async def update_tree_by_id ( id : ObjectId , patch : TreePatchSchema ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) patch_dict = patch . dict ( exclude_unset = True ) for name , value in patch_dict . items (): setattr ( tree , name , value ) await engine . save ( tree ) return tree First, we define the TreePatchSchema this Pydantic model will contain the modifications that we need to apply on the instance. Since we want to be able to update each field independently, we make them all non required (i.e. Optional ) in the schema. Then, we configure a new PATCH endpoint by setting the id of the model to update as a path parameter and the TreePatchSchema as the request body parameter. Once all the parameters have been validated properly and the associated instance have been gathered, we can apply the modifications to the model. The first step is to create a dictionnary containing only the fields to modify (the exclude_unset argument helps us to gather only the fields that have been set from the request's body): patch_dict = patch . dict ( exclude_unset = True ) The next step is to iterate over this dictionary to apply the changes to the model iteratively: for name , value in patch_dict . items (): setattr ( tree , name , value ) Using setattr to update an instance Here we use the setattr builtin function to update the instance attributes. For example: setattr ( tree , \"average_size\" , 21.5 ) will have exactly the same effect as: tree . average_size = 21.5 Once our tree has been properly patched, we can save it and return it's updated version. await engine . save ( tree ) return tree Updating a tree from the command line HTTPie Update the tree identified by 5f8c8266f1d33aa1012f3083 : http PATCH localhost:8080/trees/5f8c8266f1d33aa1012f3083 \\ discovery_year = 1825 name = \"Stone Pine\" Output: HTTP/1.1 200 OK content-length: 94 content-type: application/json date: Sun, 18 Oct 2020 22:02:44 GMT server: uvicorn { \"average_size\": 5.0, \"discovery_year\": 1825, \"id\": \"5f8c8266f1d33aa1012f3083\", \"name\": \"Stone Pine\" } Check that the tree has been updated properly: http localhost:8080/trees/5f8c8266f1d33aa1012f3083 Output: HTTP/1.1 200 OK content-length: 94 content-type: application/json date: Sun, 18 Oct 2020 22:06:52 GMT server: uvicorn { \"average_size\": 5.0, \"discovery_year\": 1825, \"id\": \"5f8c8266f1d33aa1012f3083\", \"name\": \"Stone Pine\" } curl Update the tree identified by 5f8c8266f1d33aa1012f3083 : curl -X PATCH \"http://localhost:8080/trees/5f8c8266f1d33aa1012f3083\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Stone Pine\", \"discovery_year\":1825}' Output: {\"name\":\"Stone Pine\",\"average_size\":5.0,\"discovery_year\":1825,\"id\":\"5f8c8266f1d33aa1012f3083\"} Check that the tree has been updated properly: curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3083 Output: {\"name\":\"Stone Pine\",\"average_size\":5.0,\"discovery_year\":1825,\"id\":\"5f8c8266f1d33aa1012f3083\"} The tree has been updated successfully ! Upcoming features \u00b6 A lot of feature could still improve the ODMantic + FastAPI experience. Some ideas that should arrive soon: Add a not_found_exception argument to the AIOEngine.find_one method. Thus, if the document is not found an exception will be raised directly. Implement the equivalent of MongoDB insert method to be able to create document without overwriting existing ones. Implement a Model.update method to update the model fields from a dictionnary or from a Pydantic schema. Automatically generate CRUD endpoints directly from an ODMantic Model.","title":"Usage with FastAPI"},{"location":"usage_fastapi/#usage-with-fastapi","text":"","title":"Usage with FastAPI"},{"location":"usage_fastapi/#example","text":"In this example, we create a minimalist REST API describing trees by their name, average size and discovery year. Requirements To run the following example, you'll need to install FastAPI and Uvicorn. pip install fastapi uvicorn 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from typing import List from fastapi import FastAPI , HTTPException from odmantic import AIOEngine , Model , ObjectId class Tree ( Model ): name : str average_size : float discovery_year : int app = FastAPI () engine = AIOEngine () @app . put ( \"/trees/\" , response_model = Tree ) async def create_tree ( tree : Tree ): await engine . save ( tree ) return tree @app . get ( \"/trees/\" , response_model = List [ Tree ]) async def get_trees (): trees = await engine . find ( Tree ) return trees @app . get ( \"/trees/count\" , response_model = int ) async def count_trees (): count = await engine . count ( Tree ) return count @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree You can then start the application. For example if you saved the file above in a file named tree_api.py : uvicorn tree_api : app Uvicorn should start serving the API locally: INFO: Started server process [21429] INFO: Waiting for application startup. INFO: Application startup complete. INFO: Uvicorn running on http://localhost:8080 (Press CTRL+C to quit) To try it out, you can simply access the interactive documentation generated by FastAPI at http://localhost:8080/docs . We'll now dive in the details of this example.","title":"Example"},{"location":"usage_fastapi/#defining-the-model","text":"First, we create our Tree model. class Tree ( Model ): name : str average_size : float discovery_year : int This describes our Tree instances structure both for JSON serialization and for the storage in the MongoDB collection.","title":"Defining the model"},{"location":"usage_fastapi/#building-the-engine","text":"After having defined the model, we create the [AIOEngine][odmantic.engine.AIOEngine] object. This object will be responsible for performing database operations. engine = AIOEngine () It's possible as well to build the engine with custom parameters (mongo URI, database name). See this section for more details. Running the python file directly If you need to execute the python file directly with the interpreter (to use a debugger for example), some extra steps will be required. Run uvicorn using the default event loop (if the file is called directly): if __name__ == \"__main__\" : import asyncio import uvicorn loop = asyncio . get_event_loop () config = uvicorn . Config ( app = app , port = 8080 , loop = loop ) server = uvicorn . Server ( config ) loop . run_until_complete ( server . serve ()) uvicorn.run behavior with event loops (Advanced) The usual entrypoint uvicorn.run(app) for ASGI apps doesn't work because when called uvicorn will create and run a brand new event loop. Thus, the engine object will be bound to a different event loop that will not be running. In this case, you'll witness <Future pending> attached to a different loop errors because the app itself will be running in a different event loop than the engine's driver. Anyway, when running directly the app through the uvicorn CLI, the default event loop will be the one that will be running later, so no modifications are required. AIOEngineDependency deprecation (from v0.2.0) The AIOEngineDependency that was used to inject the engine in the API routes is now deprecated (it will be kept for few versions though). Using a global engine object should be preferred as it will dramatically reduce the required verbosity to use the engine in an endpoint. If you need to run your app directly from a python file, see the above Running the python file directly section.","title":"Building the engine"},{"location":"usage_fastapi/#creating-a-tree","text":"The next step is to define a route enabling us to create a new tree. To that end, we create a PUT route with the path /trees/ . This endpoint will receive a tree, persist it to the database and return the created object. @app . put ( \"/trees/\" , response_model = Tree ) async def create_tree ( tree : Tree ): await engine . save ( tree ) return tree First, the request body will be parsed to a Tree object (this is done by specifying the argument tree: Tree ). This mean that the model validation will be performed. Once the model is parsed to a Tree instance, we persist it to the database and we return it. Command line tool for interacting with JSON based HTTP APIs To interact with the API from the command line, we recommend to use the HTTPie CLI. The next examples are still provided with the curl syntax since the Swagger documentation generated by FastAPI will give you curl examples directly. Creating a Tree from the command line HTTPie Send the request: http PUT localhost:8080/trees/ name = \"Spruce\" discovery_year = 1995 average_size = 2 Output: HTTP/1.1 200 OK content-length: 90 content-type: application/json date: Sun, 18 Oct 2020 18:40:30 GMT server: uvicorn { \"average_size\": 2.0, \"discovery_year\": 1995, \"id\": \"5f8c8c1ff1d33aa1012f3086\", \"name\": \"Spruce\" } curl Send the request: curl -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Spruce\", \"discovery_year\":1995, \"average_size\":2}' Output: {\"name\":\"Spruce\",\"average_size\":2.0,\"discovery_year\":1995,\"id\":\"5f8c8c1ff1d33aa1012f3086\"} You can notice that the id field has been added automatically by ODMantic. This id field is actually not required since it's defined automatically by ODMantic with a default factory method ( more details ). You can still specify this field in the request body to predefine the id of the created instance or to overwrite an existing instance. Why PUT instead of POST ? Since the engine.save behave as an upsert operation ( more details ), you can overwrite instances stored in the database by creating a new instance with the same id and calling the engine.save method. Modifying the Tree from the command line To overwrite the tree with id=5f8c8c1ff1d33aa1012f3086 : HTTPie Send the request: http PUT localhost:8080/trees/ \\ name = \"Norway Spruce\" discovery_year = 1795 \\ average_size = 200 id = \"5f8c8c1ff1d33aa1012f3086\" Output: HTTP/1.1 200 OK content-length: 90 content-type: application/json date: Sun, 18 Oct 2020 18:40:30 GMT server: uvicorn { \"average_size\": 200.0, \"discovery_year\": 1795, \"id\": \"5f8c8c1ff1d33aa1012f3086\", \"name\": \"Norway Spruce\" } curl Send the request: curl -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Norway Spruce\", \"discovery_year\":1795, \"average_size\":200, \"id\":\"5f8c8c1ff1d33aa1012f3086\"}' Output: {\"name\":\"Norway Spruce\",\"average_size\":200.0,\"discovery_year\":1795,\"id\":\"5f8c8c1ff1d33aa1012f3086\"} Since we can modify an existing instance, it makes more sense to define the operation as a PUT instead of a POST that should create a new resource on each call. If the request body doesn't match our model schema, a 422 Unprocessable Entity error will be returned by the API, containing the details about the error. Invalid data while creating the Tree from the command line You can try by omitting the average_size field: HTTPie Send the request: http PUT localhost:8080/trees/ name = \"Spruce\" discovery_year = 1995 Output: HTTP/1.1 422 Unprocessable Entity content-length: 96 content-type: application/json date: Sun, 18 Oct 2020 16:42:18 GMT server: uvicorn { \"detail\": [ { \"loc\": [ \"body\", \"average_size\" ], \"msg\": \"field required\", \"type\": \"value_error.missing\" } ] } curl Send the request: curl -v -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Spruce\", \"discovery_year\":1995}' Output: * Trying 127.0.0.1... * TCP_NODELAY set * Connected to localhost (127.0.0.1) port 8080 (#0) > PUT /trees/ HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.58.0 > Accept: */* > Content-Type: application/json > Content-Length: 40 > * upload completely sent off: 40 out of 40 bytes < HTTP/1.1 422 Unprocessable Entity < date: Sun, 18 Oct 2020 18:51:33 GMT < server: uvicorn < content-length: 96 < content-type: application/json < * Connection #0 to host localhost left intact {\"detail\":[{\"loc\":[\"body\",\"average_size\"],\"msg\":\"field required\",\"type\":\"value_error.missing\"}]}% The validation error structure is the one that is defined by the Pydantic: ValidationError exception. Finally, specifying the response_model in the app.put decorator is not mandatory but it is strongly advised as it helps FastAPI to generate the documentation.","title":"Creating a tree"},{"location":"usage_fastapi/#getting-all-the-trees","text":"To get the trees stored in the database, we use the [AIOEngine.find][odmantic.engine.AIOEngine.find] method in its awaitable form ( more details ), this gives us directly the list of Tree instances that we can return directly: @app . get ( \"/trees/\" , response_model = List [ Tree ]) async def get_trees (): trees = await engine . find ( Tree ) return trees Creating and getting the trees from the command line HTTPie Create some trees: http PUT localhost:8080/trees/ name = \"Spruce\" discovery_year = 1995 average_size = 10 .2 http PUT localhost:8080/trees/ name = \"Pine\" discovery_year = 1850 average_size = 5 Get the trees: http localhost:8080/trees/ Output: HTTP/1.1 200 OK content-length: 270 content-type: application/json date: Sun, 18 Oct 2020 17:59:10 GMT server: uvicorn [ { \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\", \"name\": \"Spruce\" }, { \"average_size\": 5.0, \"discovery_year\": 1850, \"id\": \"5f8c8266f1d33aa1012f3083\", \"name\": \"Pine\" } ] curl Create some trees: curl -v -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Spruce\", \"discovery_year\":1995, \"average_size\":10.2}' curl -v -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Pine\", \"discovery_year\":1850, \"average_size\":5}' Get the trees: curl http://localhost:8080/trees/ | python -mjson.tool Output: [ { \"name\": \"Spruce\", \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\" }, { \"name\": \"Pine\", \"average_size\": 5.0, \"discovery_year\": 1850, \"id\": \"5f8c8266f1d33aa1012f3083\" } ] Pagination You can add pagination to this GET request by using the skip and limit arguments while calling the [AIOEngine.find][odmantic.engine.AIOEngine.find] method.","title":"Getting all the trees"},{"location":"usage_fastapi/#counting-the-trees","text":"To get the number of trees stored in the database, we use the [AIOEngine.count][odmantic.engine.AIOEngine.count] method without specifying any query parameters (to directly get the total count of instances). @app . get ( \"/trees/count\" , response_model = int ) async def count_trees (): count = await engine . count ( Tree ) return count Getting the tree count from the command line HTTPie Get the count: http localhost:8080/trees/count Output: HTTP/1.1 200 OK content-length: 1 content-type: application/json date: Sun, 18 Oct 2020 20:16:50 GMT server: uvicorn 2 curl Get the count: curl http://localhost:8080/trees/count Output: 2","title":"Counting the trees"},{"location":"usage_fastapi/#getting-a-tree-by-id","text":"@app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId , ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree To return a tree from its id we add a path parameter id: ObjectId . Once this endpoint is called, FastAPI will try to validate this query parameter, thus inferring an ObjectId object. Using BSON objects as parameters While you can define ODMantic models directly using bson fields ( more details ), it's not possible to use those types directly with FastAPI, you'll need to get the equivalent objects from the odmantic.bson module. Those equivalent types implement the additional validation logic enabling FastAPI to work with them. from odmantic.bson import ObjectId For convenience reasons, the ObjectId type including the validation logic is as well available directly from the odmantic module. from odmantic import ObjectId With this ObjectId , we build a query that will filter only the instances having this exactly same id : Tree . id == id Then, we pass this query to the [AIOEngine.find_one][odmantic.engine.AIOEngine.find_one] method that will try to return an instance, otherwise None will be returned: tree = await engine . find_one ( Tree , Tree . id == id ) Now, if our tree object is None (i.e the instance has not been found), we need to return a 404 Not Found error: if tree is None : raise HTTPException ( 404 ) Otherwise, we found the requested instance. We can return it ! return tree Getting a tree from the command line HTTPie Get the tree 5f8c8266f1d33aa1012f3082 : http localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: HTTP/1.1 200 OK content-length: 91 content-type: application/json date: Sun, 18 Oct 2020 21:08:07 GMT server: uvicorn { \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\", \"name\": \"Spruce\" } curl Get the tree 5f8c8266f1d33aa1012f3082 : curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: {\"name\":\"Spruce\",\"average_size\":10.2,\"discovery_year\":1995,\"id\":\"5f8c8266f1d33aa1012f3082\"} Trying to get a tree not in the database from the command line HTTPie Try to get the tree f0f0f0f0f0f0f0f0f0f0f0f0 (it has not been created): http localhost:8080/trees/f0f0f0f0f0f0f0f0f0f0f0f0 Output: HTTP/1.1 404 Not Found content-length: 22 content-type: application/json date: Sun, 18 Oct 2020 21:11:48 GMT server: uvicorn { \"detail\": \"Not Found\" } curl Try to get the tree f0f0f0f0f0f0f0f0f0f0f0f0 (it has not been created): curl http://localhost:8080/trees/f0f0f0f0f0f0f0f0f0f0f0f0 Output: {\"detail\":\"Not Found\"} This id path parameter should be a 16 characters hexadecimal string (see MongoDB: ObjectId for more details). If the id specified in the path does not match this criteria, a 422 Unprocessable Entity error will be returned: Trying to get a tree with an invalid id from the command line HTTPie Get the tree identified by invalid_object_id : http localhost:8080/trees/invalid_object_id Output: HTTP/1.1 422 Unprocessable Entity content-length: 89 content-type: application/json date: Sun, 18 Oct 2020 20:50:25 GMT server: uvicorn { \"detail\": [ { \"loc\": [ \"path\", \"id\" ], \"msg\": \"invalid ObjectId specified\", \"type\": \"type_error\" } ] } curl Get the tree identified by invalid_object_id : curl http://localhost:8080/trees/invalid_object_id Output: {\"detail\":[{\"loc\":[\"path\",\"id\"],\"msg\":\"invalid ObjectId specified\",\"type\":\"type_error\"}]}","title":"Getting a tree by id"},{"location":"usage_fastapi/#extending-the-example","text":"","title":"Extending the example"},{"location":"usage_fastapi/#deleting-a-tree","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import uvicorn from fastapi import FastAPI , HTTPException from odmantic import AIOEngine , Model , ObjectId class Tree ( Model ): name : str average_size : float discovery_year : int app = FastAPI () engine = AIOEngine () @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree @app . delete ( \"/trees/ {id} \" , response_model = Tree ) async def delete_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) await engine . delete ( tree ) return tree This new DELETE route is strongly inspired from the one used to get a tree from its id . Currently, ODMantic can only delete an instance and it's not possible to perform a delete operation from a query filter. Thus, we first need to get the associated instance. Once we have the instance, we call the [AIOEngine.delete][odmantic.engine.AIOEngine.delete] method to perform the deletion. Deleting a tree from the command line HTTPie Delete the tree identified by 5f8c8266f1d33aa1012f3082 : http DELETE localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: HTTP/1.1 200 OK content-length: 91 content-type: application/json date: Sun, 18 Oct 2020 21:35:22 GMT server: uvicorn { \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\", \"name\": \"Spruce\" } Check that the tree is not stored anymore: http localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: HTTP/1.1 404 Not Found content-length: 22 content-type: application/json date: Sun, 18 Oct 2020 21:36:45 GMT server: uvicorn { \"detail\": \"Not Found\" } curl Delete the tree identified by 5f8c8266f1d33aa1012f3082 : curl -X DELETE http://localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: {\"name\":\"Spruce\",\"average_size\":10.2,\"discovery_year\":1995,\"id\":\"5f8c8266f1d33aa1012f3082\"} Check that the tree is not stored anymore: curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: {\"detail\":\"Not Found\"} The tree has been removed successfully !","title":"Deleting a tree"},{"location":"usage_fastapi/#updating-a-tree","text":"We already defined a PUT route that enables us to modify (replace) a tree instance. However, with this previopus implementation, it's not possible to specify only the fields that we want to change as the whole Tree instance is rebuilt from the request's body. In this example, we will define a PATCH method that will allow us to modify some fields of a Tree instance: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 from typing import Optional import uvicorn from fastapi import FastAPI , HTTPException from pydantic import BaseModel from odmantic import AIOEngine , Model , ObjectId class Tree ( Model ): name : str average_size : float discovery_year : int app = FastAPI () engine = AIOEngine () @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree class TreePatchSchema ( BaseModel ): name : Optional [ str ] average_size : Optional [ float ] discovery_year : Optional [ float ] @app . patch ( \"/trees/ {id} \" , response_model = Tree ) async def update_tree_by_id ( id : ObjectId , patch : TreePatchSchema ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) patch_dict = patch . dict ( exclude_unset = True ) for name , value in patch_dict . items (): setattr ( tree , name , value ) await engine . save ( tree ) return tree First, we define the TreePatchSchema this Pydantic model will contain the modifications that we need to apply on the instance. Since we want to be able to update each field independently, we make them all non required (i.e. Optional ) in the schema. Then, we configure a new PATCH endpoint by setting the id of the model to update as a path parameter and the TreePatchSchema as the request body parameter. Once all the parameters have been validated properly and the associated instance have been gathered, we can apply the modifications to the model. The first step is to create a dictionnary containing only the fields to modify (the exclude_unset argument helps us to gather only the fields that have been set from the request's body): patch_dict = patch . dict ( exclude_unset = True ) The next step is to iterate over this dictionary to apply the changes to the model iteratively: for name , value in patch_dict . items (): setattr ( tree , name , value ) Using setattr to update an instance Here we use the setattr builtin function to update the instance attributes. For example: setattr ( tree , \"average_size\" , 21.5 ) will have exactly the same effect as: tree . average_size = 21.5 Once our tree has been properly patched, we can save it and return it's updated version. await engine . save ( tree ) return tree Updating a tree from the command line HTTPie Update the tree identified by 5f8c8266f1d33aa1012f3083 : http PATCH localhost:8080/trees/5f8c8266f1d33aa1012f3083 \\ discovery_year = 1825 name = \"Stone Pine\" Output: HTTP/1.1 200 OK content-length: 94 content-type: application/json date: Sun, 18 Oct 2020 22:02:44 GMT server: uvicorn { \"average_size\": 5.0, \"discovery_year\": 1825, \"id\": \"5f8c8266f1d33aa1012f3083\", \"name\": \"Stone Pine\" } Check that the tree has been updated properly: http localhost:8080/trees/5f8c8266f1d33aa1012f3083 Output: HTTP/1.1 200 OK content-length: 94 content-type: application/json date: Sun, 18 Oct 2020 22:06:52 GMT server: uvicorn { \"average_size\": 5.0, \"discovery_year\": 1825, \"id\": \"5f8c8266f1d33aa1012f3083\", \"name\": \"Stone Pine\" } curl Update the tree identified by 5f8c8266f1d33aa1012f3083 : curl -X PATCH \"http://localhost:8080/trees/5f8c8266f1d33aa1012f3083\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Stone Pine\", \"discovery_year\":1825}' Output: {\"name\":\"Stone Pine\",\"average_size\":5.0,\"discovery_year\":1825,\"id\":\"5f8c8266f1d33aa1012f3083\"} Check that the tree has been updated properly: curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3083 Output: {\"name\":\"Stone Pine\",\"average_size\":5.0,\"discovery_year\":1825,\"id\":\"5f8c8266f1d33aa1012f3083\"} The tree has been updated successfully !","title":"Updating a tree"},{"location":"usage_fastapi/#upcoming-features","text":"A lot of feature could still improve the ODMantic + FastAPI experience. Some ideas that should arrive soon: Add a not_found_exception argument to the AIOEngine.find_one method. Thus, if the document is not found an exception will be raised directly. Implement the equivalent of MongoDB insert method to be able to create document without overwriting existing ones. Implement a Model.update method to update the model fields from a dictionnary or from a Pydantic schema. Automatically generate CRUD endpoints directly from an ODMantic Model.","title":"Upcoming features"},{"location":"usage_pydantic/","text":"Usage with Pydantic \u00b6 Defining models with BSON Fields \u00b6 You might need to define pure Pydantic models which include BSON fields. To that end, you can use the [BaseBSONModel][odmantic.bson.BaseBSONModel] as the base class of your Pydantic models. This class adds the JSON encoders required to handle the BSON fields. Also, you will have to use the bson equivalent types defined in the odmantic.bson module. Those types, add a validation logic to the native types from the bson module. Custom json_encoders with BaseBSONModel If you want to specify additional json encoders, with a Pydantic model containing BSON fields, you will need to pass as well the ODMantic encoders ([BSON_TYPES_ENCODERS][odmantic.bson.BSON_TYPES_ENCODERS]). Custom encoders example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from datetime import datetime from odmantic.bson import BSON_TYPES_ENCODERS , BaseBSONModel , ObjectId class M ( BaseBSONModel ): id : ObjectId date : datetime class Config : json_encoders = { ** BSON_TYPES_ENCODERS , datetime : lambda dt : dt . year , } print ( M ( id = ObjectId (), date = datetime . utcnow ()) . json ()) #> {\"id\": \"5fa3378c8fde3766574d874d\", \"date\": 2020} An issue that would simplify this behavior has been opened: pydantic#2024 Accessing the underlying pydantic model \u00b6 Each ODMantic Model contain a pure version of the pydantic model used to build the ODMantic Model. This Pydantic model can be accessed in the __pydantic_model__ class attribute of the ODMantic Model/EmbeddedModel.","title":"Usage with Pydantic"},{"location":"usage_pydantic/#usage-with-pydantic","text":"","title":"Usage with Pydantic"},{"location":"usage_pydantic/#defining-models-with-bson-fields","text":"You might need to define pure Pydantic models which include BSON fields. To that end, you can use the [BaseBSONModel][odmantic.bson.BaseBSONModel] as the base class of your Pydantic models. This class adds the JSON encoders required to handle the BSON fields. Also, you will have to use the bson equivalent types defined in the odmantic.bson module. Those types, add a validation logic to the native types from the bson module. Custom json_encoders with BaseBSONModel If you want to specify additional json encoders, with a Pydantic model containing BSON fields, you will need to pass as well the ODMantic encoders ([BSON_TYPES_ENCODERS][odmantic.bson.BSON_TYPES_ENCODERS]). Custom encoders example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from datetime import datetime from odmantic.bson import BSON_TYPES_ENCODERS , BaseBSONModel , ObjectId class M ( BaseBSONModel ): id : ObjectId date : datetime class Config : json_encoders = { ** BSON_TYPES_ENCODERS , datetime : lambda dt : dt . year , } print ( M ( id = ObjectId (), date = datetime . utcnow ()) . json ()) #> {\"id\": \"5fa3378c8fde3766574d874d\", \"date\": 2020} An issue that would simplify this behavior has been opened: pydantic#2024","title":"Defining models with BSON Fields"},{"location":"usage_pydantic/#accessing-the-underlying-pydantic-model","text":"Each ODMantic Model contain a pure version of the pydantic model used to build the ODMantic Model. This Pydantic model can be accessed in the __pydantic_model__ class attribute of the ODMantic Model/EmbeddedModel.","title":"Accessing the underlying pydantic model"},{"location":"api_reference/bson/","text":"This module provides helpers to build Pydantic Models containing BSON objects. Pydantic model helpers \u00b6 odmantic.bson.BaseBSONModel \u00b6 Equivalent of pydantic.BaseModel supporting BSON types encoding. If you want to apply other custom JSON encoders, you'll need to use [BSON_TYPES_ENCODERS][odmantic.bson.BSON_TYPES_ENCODERS] directly. odmantic.bson.BSON_TYPES_ENCODERS \u00b6 Encoders required to encode BSON fields (can be used in the Pydantic Model's Config.json_encoders parameter). See pydantic: JSON Encoders for more details. Pydantic type helpers \u00b6 Those helpers inherit directly from their respective bson types. They add the field validation logic required by Pydantic to work with them. On top of this, the appropriate JSON schemas are generated for them. odmantic.bson.ObjectId \u00b6 odmantic.bson.Int64 \u00b6 odmantic.bson.Decimal128 \u00b6 odmantic.bson.Binary \u00b6 odmantic.bson.Regex \u00b6","title":"odmantic.bson"},{"location":"api_reference/bson/#pydantic-model-helpers","text":"","title":"Pydantic model helpers"},{"location":"api_reference/bson/#odmantic.bson.BaseBSONModel","text":"Equivalent of pydantic.BaseModel supporting BSON types encoding. If you want to apply other custom JSON encoders, you'll need to use [BSON_TYPES_ENCODERS][odmantic.bson.BSON_TYPES_ENCODERS] directly.","title":"BaseBSONModel"},{"location":"api_reference/bson/#odmantic.bson.BSON_TYPES_ENCODERS","text":"Encoders required to encode BSON fields (can be used in the Pydantic Model's Config.json_encoders parameter). See pydantic: JSON Encoders for more details.","title":"BSON_TYPES_ENCODERS"},{"location":"api_reference/bson/#pydantic-type-helpers","text":"Those helpers inherit directly from their respective bson types. They add the field validation logic required by Pydantic to work with them. On top of this, the appropriate JSON schemas are generated for them.","title":"Pydantic type helpers"},{"location":"api_reference/bson/#odmantic.bson.ObjectId","text":"","title":"ObjectId"},{"location":"api_reference/bson/#odmantic.bson.Int64","text":"","title":"Int64"},{"location":"api_reference/bson/#odmantic.bson.Decimal128","text":"","title":"Decimal128"},{"location":"api_reference/bson/#odmantic.bson.Binary","text":"","title":"Binary"},{"location":"api_reference/bson/#odmantic.bson.Regex","text":"","title":"Regex"},{"location":"api_reference/engine/","text":"odmantic.engine.AIOEngine \u00b6 The AIOEngine object is responsible for handling database operations with MongoDB in an asynchronous way using motor. __init__ ( self , motor_client = None , database = 'test' ) special \u00b6 Engine constructor. Parameters: Name Type Description Default motor_client AsyncIOMotorClient instance of an AsyncIO motor client. If None, a default one will be created None database str name of the database to use 'test' Source code in odmantic/engine.py def __init__ ( self , motor_client : AsyncIOMotorClient = None , database : str = \"test\" ): \"\"\"Engine constructor. Args: motor_client: instance of an AsyncIO motor client. If None, a default one will be created database: name of the database to use <!--- #noqa: DAR401 ValueError --> \"\"\" # https://docs.mongodb.com/manual/reference/limits/#naming-restrictions forbidden_characters = _FORBIDDEN_DATABASE_CHARACTERS . intersection ( set ( database ) ) if len ( forbidden_characters ) > 0 : raise ValueError ( f \"database name cannot contain: { ' ' . join ( forbidden_characters ) } \" ) if motor_client is None : motor_client = AsyncIOMotorClient () self . client = motor_client self . database_name = database self . database = motor_client [ self . database_name ] count ( self , model , * queries ) async \u00b6 Get the count of documents matching a query Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required queries Union[odmantic.query.QueryExpression, Dict, bool] query filters to apply () Returns: Type Description int number of document matching the query Source code in odmantic/engine.py async def count ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ] ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on queries: query filters to apply Returns: number of document matching the query <!--- #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call count with a Model class\" ) query = AIOEngine . _build_query ( * queries ) collection = self . database [ model . __collection__ ] count = await collection . count_documents ( query ) return int ( count ) delete ( self , instance ) async \u00b6 Delete an instance from the database Parameters: Name Type Description Default instance ~ModelType the instance to delete required Exceptions: Type Description DocumentNotFoundError the instance has not been persisted to the database Source code in odmantic/engine.py async def delete ( self , instance : ModelType ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete Raises: DocumentNotFoundError: the instance has not been persisted to the database \"\"\" # TODO handle cascade deletion collection = self . database [ instance . __collection__ ] pk_name = instance . __primary_field__ result = await collection . delete_many ({ \"_id\" : getattr ( instance , pk_name )}) count = int ( result . deleted_count ) if count == 0 : raise DocumentNotFoundError ( instance ) find ( self , model , * queries , * , sort = None , skip = 0 , limit = None ) \u00b6 Search for Model instances matching the query filter provided Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required queries Union[odmantic.query.QueryExpression, Dict, bool] query filter to apply () sort Optional[Any] sort expression None skip int number of document to skip 0 limit Optional[int] maximum number of instance fetched None Returns: Type Description odmantic.engine.AIOCursor[~ModelType] [odmantic.engine.AIOCursor][] of the query Source code in odmantic/engine.py def find ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , ) -> AIOCursor [ ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched Returns: [odmantic.engine.AIOCursor][] of the query <!--- #noqa: DAR401 ValueError #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find with a Model class\" ) sort_expression = self . _validate_sort_argument ( sort ) if limit is not None and limit <= 0 : raise ValueError ( \"limit has to be a strict positive value or None\" ) if skip < 0 : raise ValueError ( \"skip has to be a positive integer\" ) query = AIOEngine . _build_query ( * queries ) collection = self . get_collection ( model ) pipeline : List [ Dict ] = [{ \"$match\" : query }] if sort_expression is not None : pipeline . append ({ \"$sort\" : sort_expression }) if skip > 0 : pipeline . append ({ \"$skip\" : skip }) if limit is not None and limit > 0 : pipeline . append ({ \"$limit\" : limit }) pipeline . extend ( AIOEngine . _cascade_find_pipeline ( model )) motor_cursor = collection . aggregate ( pipeline ) return AIOCursor ( model , motor_cursor ) find_one ( self , model , * queries , * , sort = None ) async \u00b6 Search for a Model instance matching the query filter provided Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required queries Union[odmantic.query.QueryExpression, Dict, bool] query filter to apply () sort Optional[Any] sort expression None Returns: Type Description Optional[~ModelType] the fetched instance if found otherwise None Source code in odmantic/engine.py async def find_one ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin, sort : Optional [ Any ] = None , ) -> Optional [ ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on queries: query filter to apply sort: sort expression Returns: the fetched instance if found otherwise None <!--- #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) results = await self . find ( model , * queries , sort = sort , limit = 1 ) if len ( results ) == 0 : return None return results [ 0 ] get_collection ( self , model ) \u00b6 Get the motor collection associated to a Model. Parameters: Name Type Description Default model Type[~ModelType] model class required Returns: Type Description AsyncIOMotorCollection the AsyncIO motor collection object Source code in odmantic/engine.py def get_collection ( self , model : Type [ ModelType ]) -> AsyncIOMotorCollection : \"\"\"Get the motor collection associated to a Model. Args: model: model class Returns: the AsyncIO motor collection object \"\"\" return self . database [ model . __collection__ ] save ( self , instance ) async \u00b6 Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Parameters: Name Type Description Default instance ~ModelType instance to persist required Returns: Type Description ~ModelType the saved instance Note The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. Source code in odmantic/engine.py async def save ( self , instance : ModelType ) -> ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist Returns: the saved instance NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. <!--- #noqa: DAR401 TypeError --> \"\"\" if not isinstance ( instance , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) async with await self . client . start_session () as s : async with s . start_transaction (): await self . _save ( instance , s ) object . __setattr__ ( instance , \"__fields_modified__\" , set ()) return instance save_all ( self , instances ) async \u00b6 Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Parameters: Name Type Description Default instances Sequence[~ModelType] instances to persist required Returns: Type Description List[~ModelType] the saved instances Note The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. Source code in odmantic/engine.py async def save_all ( self , instances : Sequence [ ModelType ]) -> List [ ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist Returns: the saved instances NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. \"\"\" async with await self . client . start_session () as s : async with s . start_transaction (): added_instances = await asyncio . gather ( * [ self . _save ( instance , s ) for instance in instances ] ) return added_instances odmantic.engine.AIOCursor \u00b6 This object has to be built from the [odmantic.engine.AIOEngine.find][] method. An AIOCursor object support multiple async operations: async for : asynchronously iterate over the query results await : when awaited it will return a list of the fetched models","title":"odmantic.engine"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine","text":"The AIOEngine object is responsible for handling database operations with MongoDB in an asynchronous way using motor.","title":"AIOEngine"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.__init__","text":"Engine constructor. Parameters: Name Type Description Default motor_client AsyncIOMotorClient instance of an AsyncIO motor client. If None, a default one will be created None database str name of the database to use 'test' Source code in odmantic/engine.py def __init__ ( self , motor_client : AsyncIOMotorClient = None , database : str = \"test\" ): \"\"\"Engine constructor. Args: motor_client: instance of an AsyncIO motor client. If None, a default one will be created database: name of the database to use <!--- #noqa: DAR401 ValueError --> \"\"\" # https://docs.mongodb.com/manual/reference/limits/#naming-restrictions forbidden_characters = _FORBIDDEN_DATABASE_CHARACTERS . intersection ( set ( database ) ) if len ( forbidden_characters ) > 0 : raise ValueError ( f \"database name cannot contain: { ' ' . join ( forbidden_characters ) } \" ) if motor_client is None : motor_client = AsyncIOMotorClient () self . client = motor_client self . database_name = database self . database = motor_client [ self . database_name ]","title":"__init__()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.count","text":"Get the count of documents matching a query Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required queries Union[odmantic.query.QueryExpression, Dict, bool] query filters to apply () Returns: Type Description int number of document matching the query Source code in odmantic/engine.py async def count ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ] ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on queries: query filters to apply Returns: number of document matching the query <!--- #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call count with a Model class\" ) query = AIOEngine . _build_query ( * queries ) collection = self . database [ model . __collection__ ] count = await collection . count_documents ( query ) return int ( count )","title":"count()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.delete","text":"Delete an instance from the database Parameters: Name Type Description Default instance ~ModelType the instance to delete required Exceptions: Type Description DocumentNotFoundError the instance has not been persisted to the database Source code in odmantic/engine.py async def delete ( self , instance : ModelType ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete Raises: DocumentNotFoundError: the instance has not been persisted to the database \"\"\" # TODO handle cascade deletion collection = self . database [ instance . __collection__ ] pk_name = instance . __primary_field__ result = await collection . delete_many ({ \"_id\" : getattr ( instance , pk_name )}) count = int ( result . deleted_count ) if count == 0 : raise DocumentNotFoundError ( instance )","title":"delete()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.find","text":"Search for Model instances matching the query filter provided Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required queries Union[odmantic.query.QueryExpression, Dict, bool] query filter to apply () sort Optional[Any] sort expression None skip int number of document to skip 0 limit Optional[int] maximum number of instance fetched None Returns: Type Description odmantic.engine.AIOCursor[~ModelType] [odmantic.engine.AIOCursor][] of the query Source code in odmantic/engine.py def find ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , ) -> AIOCursor [ ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched Returns: [odmantic.engine.AIOCursor][] of the query <!--- #noqa: DAR401 ValueError #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find with a Model class\" ) sort_expression = self . _validate_sort_argument ( sort ) if limit is not None and limit <= 0 : raise ValueError ( \"limit has to be a strict positive value or None\" ) if skip < 0 : raise ValueError ( \"skip has to be a positive integer\" ) query = AIOEngine . _build_query ( * queries ) collection = self . get_collection ( model ) pipeline : List [ Dict ] = [{ \"$match\" : query }] if sort_expression is not None : pipeline . append ({ \"$sort\" : sort_expression }) if skip > 0 : pipeline . append ({ \"$skip\" : skip }) if limit is not None and limit > 0 : pipeline . append ({ \"$limit\" : limit }) pipeline . extend ( AIOEngine . _cascade_find_pipeline ( model )) motor_cursor = collection . aggregate ( pipeline ) return AIOCursor ( model , motor_cursor )","title":"find()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.find_one","text":"Search for a Model instance matching the query filter provided Parameters: Name Type Description Default model Type[~ModelType] model to perform the operation on required queries Union[odmantic.query.QueryExpression, Dict, bool] query filter to apply () sort Optional[Any] sort expression None Returns: Type Description Optional[~ModelType] the fetched instance if found otherwise None Source code in odmantic/engine.py async def find_one ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin, sort : Optional [ Any ] = None , ) -> Optional [ ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on queries: query filter to apply sort: sort expression Returns: the fetched instance if found otherwise None <!--- #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) results = await self . find ( model , * queries , sort = sort , limit = 1 ) if len ( results ) == 0 : return None return results [ 0 ]","title":"find_one()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.get_collection","text":"Get the motor collection associated to a Model. Parameters: Name Type Description Default model Type[~ModelType] model class required Returns: Type Description AsyncIOMotorCollection the AsyncIO motor collection object Source code in odmantic/engine.py def get_collection ( self , model : Type [ ModelType ]) -> AsyncIOMotorCollection : \"\"\"Get the motor collection associated to a Model. Args: model: model class Returns: the AsyncIO motor collection object \"\"\" return self . database [ model . __collection__ ]","title":"get_collection()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.save","text":"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Parameters: Name Type Description Default instance ~ModelType instance to persist required Returns: Type Description ~ModelType the saved instance Note The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. Source code in odmantic/engine.py async def save ( self , instance : ModelType ) -> ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist Returns: the saved instance NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. <!--- #noqa: DAR401 TypeError --> \"\"\" if not isinstance ( instance , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) async with await self . client . start_session () as s : async with s . start_transaction (): await self . _save ( instance , s ) object . __setattr__ ( instance , \"__fields_modified__\" , set ()) return instance","title":"save()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.save_all","text":"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Parameters: Name Type Description Default instances Sequence[~ModelType] instances to persist required Returns: Type Description List[~ModelType] the saved instances Note The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. Source code in odmantic/engine.py async def save_all ( self , instances : Sequence [ ModelType ]) -> List [ ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist Returns: the saved instances NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. \"\"\" async with await self . client . start_session () as s : async with s . start_transaction (): added_instances = await asyncio . gather ( * [ self . _save ( instance , s ) for instance in instances ] ) return added_instances","title":"save_all()"},{"location":"api_reference/engine/#odmantic.engine.AIOCursor","text":"This object has to be built from the [odmantic.engine.AIOEngine.find][] method. An AIOCursor object support multiple async operations: async for : asynchronously iterate over the query results await : when awaited it will return a list of the fetched models","title":"AIOCursor"},{"location":"api_reference/exceptions/","text":"odmantic.exceptions.BaseEngineException \u00b6 Base Exception raised by the engine while operating on a model. odmantic.exceptions.DocumentNotFoundError \u00b6 The targetted document has not been found by the engine. Attributes: Name Type Description instance Model the instance that has not been found","title":"odmantic.exceptions"},{"location":"api_reference/exceptions/#odmantic.exceptions.BaseEngineException","text":"Base Exception raised by the engine while operating on a model.","title":"BaseEngineException"},{"location":"api_reference/exceptions/#odmantic.exceptions.DocumentNotFoundError","text":"The targetted document has not been found by the engine. Attributes: Name Type Description instance Model the instance that has not been found","title":"DocumentNotFoundError"},{"location":"api_reference/fastapi/","text":"odmantic.fastapi.AIOEngineDependency \u00b6 AIOEngine FastAPI Dependency. Warning Deprecated since v0.2.0, more details . Internally caches the AIOEngine instance to avoid creating a new client on each request. Sample usage: app = FastAPI () EngineD = AIOEngineDependency () @app . get ( \"/\" ) async def get ( engine : AIOEngine = EngineD ): await engine . find ( ... ) await engine . save ( ... ) __init__ ( self , mongo_uri = None , database = 'test' ) special \u00b6 Dependency initializer for AIOEngine. Parameters: Name Type Description Default mongo_uri Optional[str] mongo_uri that should be used for creating the motor client None database str database to use 'test' Source code in odmantic/fastapi.py def __init__ ( self , mongo_uri : Optional [ str ] = None , database : str = \"test\" ) -> None : \"\"\"Dependency initializer for AIOEngine. Args: mongo_uri: mongo_uri that should be used for creating the motor client database: database to use \"\"\" super () . __init__ ( dependency = self ) self . mongo_uri = mongo_uri self . database = database self . engine : Optional [ AIOEngine ] = None warnings . warn ( \"the AIOEngineDependency object is deprecated, see \" \"https://art049.github.io/odmantic/usage_fastapi/#building-the-engine \" \"for more details.\" , DeprecationWarning , )","title":"odmantic.fastapi"},{"location":"api_reference/fastapi/#odmantic.fastapi.AIOEngineDependency","text":"AIOEngine FastAPI Dependency. Warning Deprecated since v0.2.0, more details . Internally caches the AIOEngine instance to avoid creating a new client on each request. Sample usage: app = FastAPI () EngineD = AIOEngineDependency () @app . get ( \"/\" ) async def get ( engine : AIOEngine = EngineD ): await engine . find ( ... ) await engine . save ( ... )","title":"AIOEngineDependency"},{"location":"api_reference/fastapi/#odmantic.fastapi.AIOEngineDependency.__init__","text":"Dependency initializer for AIOEngine. Parameters: Name Type Description Default mongo_uri Optional[str] mongo_uri that should be used for creating the motor client None database str database to use 'test' Source code in odmantic/fastapi.py def __init__ ( self , mongo_uri : Optional [ str ] = None , database : str = \"test\" ) -> None : \"\"\"Dependency initializer for AIOEngine. Args: mongo_uri: mongo_uri that should be used for creating the motor client database: database to use \"\"\" super () . __init__ ( dependency = self ) self . mongo_uri = mongo_uri self . database = database self . engine : Optional [ AIOEngine ] = None warnings . warn ( \"the AIOEngineDependency object is deprecated, see \" \"https://art049.github.io/odmantic/usage_fastapi/#building-the-engine \" \"for more details.\" , DeprecationWarning , )","title":"__init__()"},{"location":"api_reference/field/","text":"odmantic.field.Field ( default = PydanticUndefined , * , key_name = None , primary_field = False , default_factory = None , title = None , description = None , const = None , gt = None , ge = None , lt = None , le = None , multiple_of = None , min_items = None , max_items = None , min_length = None , max_length = None , regex = None , ** extra ) \u00b6 Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields ( int , float , Decimal ) and some apply only to str . Tip The main additions of ODMantic to the regular pydantic Field are the key_name and the primary_field options. Warning If both default and default_factory are set, an error is raised. Warning primary_field can't be used along with key_name since the key_name will be set to _id . Parameters: Name Type Description Default default Any since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis ( ... ) to indicate the field has no default value PydanticUndefined key_name Optional[str] the name to use in the the mongo document structure None primary_field bool this field should be considered as a primary key. False default_factory Optional[Callable[[], Any]] callable that will be called when a default value is needed for this field. None title Optional[str] can be any string, used in the schema None description Optional[str] can be any string, used in the schema None const Optional[bool] this field is required and must take it's default value None gt Optional[float] only applies to numbers, requires the field to be \"greater than\". The schema will have an exclusiveMinimum validation keyword None ge Optional[float] only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a minimum validation keyword None lt Optional[float] only applies to numbers, requires the field to be \"less than\". The schema will have an exclusiveMaximum validation keyword None le Optional[float] only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a maximum validation keyword None multiple_of Optional[float] only applies to numbers, requires the field to be \"a multiple of \". The schema will have a multipleOf validation keyword None min_items Optional[int] only applies to sequences, requires the field to have a minimum item count. None max_items Optional[int] only applies to sequences, requires the field to have a maximum item count. None min_length Optional[int] only applies to strings, requires the field to have a minimum length. The schema will have a maximum validation keyword None max_length Optional[int] only applies to strings, requires the field to have a maximum length. The schema will have a maxLength validation keyword None regex Optional[str] only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a pattern validation keyword None **extra Any any additional keyword arguments will be added as is to the schema {} Source code in odmantic/field.py def Field ( default : Any = Undefined , * , key_name : Optional [ str ] = None , primary_field : bool = False , default_factory : Optional [ NoArgAnyCallable ] = None , # alias: str = None, # FIXME not supported yet title : Optional [ str ] = None , description : Optional [ str ] = None , const : Optional [ bool ] = None , gt : Optional [ float ] = None , ge : Optional [ float ] = None , lt : Optional [ float ] = None , le : Optional [ float ] = None , multiple_of : Optional [ float ] = None , min_items : Optional [ int ] = None , max_items : Optional [ int ] = None , min_length : Optional [ int ] = None , max_length : Optional [ int ] = None , regex : Optional [ str ] = None , ** extra : Any , ) -> Any : \"\"\"Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str``. Tip: The main additions of ODMantic to the regular pydantic `Field` are the `key_name` and the `primary_field` options. Warning: If both `default` and `default_factory` are set, an error is raised. Warning: `primary_field` can't be used along with `key_name` since the key_name will be set to `_id`. Args: default: since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis (``...``) to indicate the field has no default value key_name: the name to use in the the mongo document structure primary_field: this field should be considered as a primary key. default_factory: callable that will be called when a default value is needed for this field. title: can be any string, used in the schema description: can be any string, used in the schema const: this field is required and *must* take it's default value gt: only applies to numbers, requires the field to be \"greater than\". The schema will have an ``exclusiveMinimum`` validation keyword ge: only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a ``minimum`` validation keyword lt: only applies to numbers, requires the field to be \"less than\". The schema will have an ``exclusiveMaximum`` validation keyword le: only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a ``maximum`` validation keyword multiple_of: only applies to numbers, requires the field to be \"a multiple of \". The schema will have a ``multipleOf`` validation keyword min_items: only applies to sequences, requires the field to have a minimum item count. max_items: only applies to sequences, requires the field to have a maximum item count. min_length: only applies to strings, requires the field to have a minimum length. The schema will have a ``maximum`` validation keyword max_length: only applies to strings, requires the field to have a maximum length. The schema will have a ``maxLength`` validation keyword regex: only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a ``pattern`` validation keyword **extra: any additional keyword arguments will be added as is to the schema <!--- # noqa: DAR201 # noqa: DAR003 # noqa: DAR401 # noqa: DAR101 --> \"\"\" # Perform casts on optional fields to avoid incompatibility due to the strict # optional mypy setting pydantic_field = PDField ( default , default_factory = default_factory , # alias=alias, # FIXME check aliases compatibility title = cast ( str , title ), description = cast ( str , description ), const = cast ( bool , const ), gt = cast ( float , gt ), ge = cast ( float , ge ), lt = cast ( float , lt ), le = cast ( float , le ), multiple_of = cast ( float , multiple_of ), min_items = cast ( int , min_items ), max_items = cast ( int , max_items ), min_length = cast ( int , min_length ), max_length = cast ( int , max_length ), regex = cast ( str , regex ), ** extra , ) if primary_field : if key_name is not None and key_name != \"_id\" : raise ValueError ( \"cannot specify a primary field with a custom key_name,\" \"key_name='_id' enforced\" ) else : key_name = \"_id\" elif key_name == \"_id\" : raise ValueError ( \"cannot specify key_name='_id' without defining the field as primary\" ) return ODMFieldInfo ( pydantic_field_info = pydantic_field , primary_field = primary_field , key_name = key_name , )","title":"odmantic.field"},{"location":"api_reference/field/#odmantic.field.Field","text":"Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields ( int , float , Decimal ) and some apply only to str . Tip The main additions of ODMantic to the regular pydantic Field are the key_name and the primary_field options. Warning If both default and default_factory are set, an error is raised. Warning primary_field can't be used along with key_name since the key_name will be set to _id . Parameters: Name Type Description Default default Any since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis ( ... ) to indicate the field has no default value PydanticUndefined key_name Optional[str] the name to use in the the mongo document structure None primary_field bool this field should be considered as a primary key. False default_factory Optional[Callable[[], Any]] callable that will be called when a default value is needed for this field. None title Optional[str] can be any string, used in the schema None description Optional[str] can be any string, used in the schema None const Optional[bool] this field is required and must take it's default value None gt Optional[float] only applies to numbers, requires the field to be \"greater than\". The schema will have an exclusiveMinimum validation keyword None ge Optional[float] only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a minimum validation keyword None lt Optional[float] only applies to numbers, requires the field to be \"less than\". The schema will have an exclusiveMaximum validation keyword None le Optional[float] only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a maximum validation keyword None multiple_of Optional[float] only applies to numbers, requires the field to be \"a multiple of \". The schema will have a multipleOf validation keyword None min_items Optional[int] only applies to sequences, requires the field to have a minimum item count. None max_items Optional[int] only applies to sequences, requires the field to have a maximum item count. None min_length Optional[int] only applies to strings, requires the field to have a minimum length. The schema will have a maximum validation keyword None max_length Optional[int] only applies to strings, requires the field to have a maximum length. The schema will have a maxLength validation keyword None regex Optional[str] only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a pattern validation keyword None **extra Any any additional keyword arguments will be added as is to the schema {} Source code in odmantic/field.py def Field ( default : Any = Undefined , * , key_name : Optional [ str ] = None , primary_field : bool = False , default_factory : Optional [ NoArgAnyCallable ] = None , # alias: str = None, # FIXME not supported yet title : Optional [ str ] = None , description : Optional [ str ] = None , const : Optional [ bool ] = None , gt : Optional [ float ] = None , ge : Optional [ float ] = None , lt : Optional [ float ] = None , le : Optional [ float ] = None , multiple_of : Optional [ float ] = None , min_items : Optional [ int ] = None , max_items : Optional [ int ] = None , min_length : Optional [ int ] = None , max_length : Optional [ int ] = None , regex : Optional [ str ] = None , ** extra : Any , ) -> Any : \"\"\"Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str``. Tip: The main additions of ODMantic to the regular pydantic `Field` are the `key_name` and the `primary_field` options. Warning: If both `default` and `default_factory` are set, an error is raised. Warning: `primary_field` can't be used along with `key_name` since the key_name will be set to `_id`. Args: default: since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis (``...``) to indicate the field has no default value key_name: the name to use in the the mongo document structure primary_field: this field should be considered as a primary key. default_factory: callable that will be called when a default value is needed for this field. title: can be any string, used in the schema description: can be any string, used in the schema const: this field is required and *must* take it's default value gt: only applies to numbers, requires the field to be \"greater than\". The schema will have an ``exclusiveMinimum`` validation keyword ge: only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a ``minimum`` validation keyword lt: only applies to numbers, requires the field to be \"less than\". The schema will have an ``exclusiveMaximum`` validation keyword le: only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a ``maximum`` validation keyword multiple_of: only applies to numbers, requires the field to be \"a multiple of \". The schema will have a ``multipleOf`` validation keyword min_items: only applies to sequences, requires the field to have a minimum item count. max_items: only applies to sequences, requires the field to have a maximum item count. min_length: only applies to strings, requires the field to have a minimum length. The schema will have a ``maximum`` validation keyword max_length: only applies to strings, requires the field to have a maximum length. The schema will have a ``maxLength`` validation keyword regex: only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a ``pattern`` validation keyword **extra: any additional keyword arguments will be added as is to the schema <!--- # noqa: DAR201 # noqa: DAR003 # noqa: DAR401 # noqa: DAR101 --> \"\"\" # Perform casts on optional fields to avoid incompatibility due to the strict # optional mypy setting pydantic_field = PDField ( default , default_factory = default_factory , # alias=alias, # FIXME check aliases compatibility title = cast ( str , title ), description = cast ( str , description ), const = cast ( bool , const ), gt = cast ( float , gt ), ge = cast ( float , ge ), lt = cast ( float , lt ), le = cast ( float , le ), multiple_of = cast ( float , multiple_of ), min_items = cast ( int , min_items ), max_items = cast ( int , max_items ), min_length = cast ( int , min_length ), max_length = cast ( int , max_length ), regex = cast ( str , regex ), ** extra , ) if primary_field : if key_name is not None and key_name != \"_id\" : raise ValueError ( \"cannot specify a primary field with a custom key_name,\" \"key_name='_id' enforced\" ) else : key_name = \"_id\" elif key_name == \"_id\" : raise ValueError ( \"cannot specify key_name='_id' without defining the field as primary\" ) return ODMFieldInfo ( pydantic_field_info = pydantic_field , primary_field = primary_field , key_name = key_name , )","title":"Field()"},{"location":"api_reference/model/","text":"odmantic.model._BaseODMModel private \u00b6 Base class for [Model][odmantic.model.Model] and [EmbeddedModel][odmantic.model.EmbeddedModel]. Warning This internal class should never be instanciated directly. doc ( self , include = None ) \u00b6 Generate a document representation of the instance (as a dictionary). Parameters: Name Type Description Default include Optional[AbstractSetIntStr] field that should be included; if None, all the field will be included None Returns: Type Description Dict[str, Any] the document associated to the instance Source code in odmantic/model.py def doc ( self , include : Optional [ \"AbstractSetIntStr\" ] = None ) -> Dict [ str , Any ]: \"\"\"Generate a document representation of the instance (as a dictionary). Args: include: field that should be included; if None, all the field will be included Returns: the document associated to the instance \"\"\" raw_doc = self . dict () doc : Dict [ str , Any ] = {} for field_name , field in self . __odm_fields__ . items (): if include is not None and field_name not in include : continue if isinstance ( field , ODMReference ): doc [ field . key_name ] = raw_doc [ field_name ][ \"id\" ] else : if field_name in self . __bson_serialized_fields__ : doc [ field . key_name ] = self . __fields__ [ field_name ] . type_ . __bson__ ( raw_doc [ field_name ] ) else : doc [ field . key_name ] = raw_doc [ field_name ] return doc parse_doc ( raw_doc ) classmethod \u00b6 Parse a BSON document into an instance of the Model Parameters: Name Type Description Default raw_doc Dict document to parse (as Dict) required Returns: Type Description ~TBase an instance of the Model class this method is called on. Source code in odmantic/model.py @classmethod def parse_doc ( cls : Type [ TBase ], raw_doc : Dict ) -> TBase : \"\"\"Parse a BSON document into an instance of the Model Args: raw_doc: document to parse (as Dict) Returns: an instance of the Model class this method is called on. \"\"\" doc : Dict [ str , Any ] = {} for field_name , field in cls . __odm_fields__ . items (): if isinstance ( field , ODMReference ): doc [ field_name ] = field . model . parse_doc ( raw_doc [ field . key_name ]) else : doc [ field_name ] = raw_doc [ field . key_name ] instance = cls . parse_obj ( doc ) return instance odmantic.model.Model \u00b6 Class that can be extended to create an ODMantic Model. Each model will be bound to a MongoDB collection. You can customize the collection name by setting the __collection__ class variable in the model classes. odmantic.model.EmbeddedModel \u00b6 Class that can be extended to create an ODMantic Embedded Model. An embedded document cannot be persisted directly to the database but should be integrated in a regular ODMantic Model.","title":"odmantic.model"},{"location":"api_reference/model/#odmantic.model._BaseODMModel","text":"Base class for [Model][odmantic.model.Model] and [EmbeddedModel][odmantic.model.EmbeddedModel]. Warning This internal class should never be instanciated directly.","title":"_BaseODMModel"},{"location":"api_reference/model/#odmantic.model._BaseODMModel.doc","text":"Generate a document representation of the instance (as a dictionary). Parameters: Name Type Description Default include Optional[AbstractSetIntStr] field that should be included; if None, all the field will be included None Returns: Type Description Dict[str, Any] the document associated to the instance Source code in odmantic/model.py def doc ( self , include : Optional [ \"AbstractSetIntStr\" ] = None ) -> Dict [ str , Any ]: \"\"\"Generate a document representation of the instance (as a dictionary). Args: include: field that should be included; if None, all the field will be included Returns: the document associated to the instance \"\"\" raw_doc = self . dict () doc : Dict [ str , Any ] = {} for field_name , field in self . __odm_fields__ . items (): if include is not None and field_name not in include : continue if isinstance ( field , ODMReference ): doc [ field . key_name ] = raw_doc [ field_name ][ \"id\" ] else : if field_name in self . __bson_serialized_fields__ : doc [ field . key_name ] = self . __fields__ [ field_name ] . type_ . __bson__ ( raw_doc [ field_name ] ) else : doc [ field . key_name ] = raw_doc [ field_name ] return doc","title":"doc()"},{"location":"api_reference/model/#odmantic.model._BaseODMModel.parse_doc","text":"Parse a BSON document into an instance of the Model Parameters: Name Type Description Default raw_doc Dict document to parse (as Dict) required Returns: Type Description ~TBase an instance of the Model class this method is called on. Source code in odmantic/model.py @classmethod def parse_doc ( cls : Type [ TBase ], raw_doc : Dict ) -> TBase : \"\"\"Parse a BSON document into an instance of the Model Args: raw_doc: document to parse (as Dict) Returns: an instance of the Model class this method is called on. \"\"\" doc : Dict [ str , Any ] = {} for field_name , field in cls . __odm_fields__ . items (): if isinstance ( field , ODMReference ): doc [ field_name ] = field . model . parse_doc ( raw_doc [ field . key_name ]) else : doc [ field_name ] = raw_doc [ field . key_name ] instance = cls . parse_obj ( doc ) return instance","title":"parse_doc()"},{"location":"api_reference/model/#odmantic.model.Model","text":"Class that can be extended to create an ODMantic Model. Each model will be bound to a MongoDB collection. You can customize the collection name by setting the __collection__ class variable in the model classes.","title":"Model"},{"location":"api_reference/model/#odmantic.model.EmbeddedModel","text":"Class that can be extended to create an ODMantic Embedded Model. An embedded document cannot be persisted directly to the database but should be integrated in a regular ODMantic Model.","title":"EmbeddedModel"},{"location":"api_reference/query/","text":"odmantic.query.QueryExpression \u00b6 Base object used to build queries. All comparison and logical operators returns QueryExpression objects. The | and & operators are supported for respectively the [or][odmantic.query.or_] and the [and][odmantic.query.and_] logical operators. Warning When using those operators make sure to correctly bracket the expressions to avoid python operator precedence issues. Logical Operators \u00b6 odmantic.query.and_ ( * elements ) \u00b6 Logical AND operation between multiple QueryExpression objects. Source code in odmantic/query.py def and_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **AND** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$and\" : elements }) odmantic.query.or_ ( * elements ) \u00b6 Logical OR operation between multiple QueryExpression objects. Source code in odmantic/query.py def or_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **OR** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$or\" : elements }) odmantic.query.nor_ ( * elements ) \u00b6 Logical NOR operation between multiple QueryExpression objects. Source code in odmantic/query.py def nor_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **NOR** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$nor\" : elements }) Comparison Operators \u00b6 odmantic.query.eq ( field , value ) \u00b6 Equality comparison operator. Source code in odmantic/query.py def eq ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Equality comparison operator.\"\"\" return _cmp_expression ( field , \"$eq\" , value ) odmantic.query.ne ( field , value ) \u00b6 Inequality comparison operator (includes documents not containing the field). Source code in odmantic/query.py def ne ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Inequality comparison operator (includes documents not containing the field).\"\"\" return _cmp_expression ( field , \"$ne\" , value ) odmantic.query.gt ( field , value ) \u00b6 Greater than (strict) comparison operator (i.e. >). Source code in odmantic/query.py def gt ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Greater than (strict) comparison operator (i.e. >).\"\"\" return _cmp_expression ( field , \"$gt\" , value ) odmantic.query.gte ( field , value ) \u00b6 Greater than or equal comparison operator (i.e. >=). Source code in odmantic/query.py def gte ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Greater than or equal comparison operator (i.e. >=).\"\"\" return _cmp_expression ( field , \"$gte\" , value ) odmantic.query.lt ( field , value ) \u00b6 Less than (strict) comparison operator (i.e. <). Source code in odmantic/query.py def lt ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Less than (strict) comparison operator (i.e. <).\"\"\" return _cmp_expression ( field , \"$lt\" , value ) odmantic.query.lte ( field , value ) \u00b6 Less than or equal comparison operator (i.e. <=). Source code in odmantic/query.py def lte ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Less than or equal comparison operator (i.e. <=).\"\"\" return _cmp_expression ( field , \"$lte\" , value ) odmantic.query.in_ ( field , sequence ) \u00b6 Select instances where field is contained in sequence . Source code in odmantic/query.py def in_ ( field : FieldProxyAny , sequence : Sequence ) -> QueryExpression : \"\"\"Select instances where `field` is contained in `sequence`.\"\"\" return _cmp_expression ( field , \"$in\" , sequence ) odmantic.query.not_in ( field , sequence ) \u00b6 Select instances where field is not contained in sequence . Source code in odmantic/query.py def not_in ( field : FieldProxyAny , sequence : Sequence ) -> QueryExpression : \"\"\"Select instances where `field` is **not** contained in `sequence`.\"\"\" return _cmp_expression ( field , \"$nin\" , sequence ) odmantic.query.match ( field , pattern ) \u00b6 Select instances where field matches the pattern regular expression. Source code in odmantic/query.py def match ( field : FieldProxyAny , pattern : Union [ Pattern , str ]) -> QueryExpression : \"\"\"Select instances where `field` matches the `pattern` regular expression.\"\"\" # FIXME might create incompatibilities # https://docs.mongodb.com/manual/reference/operator/query/regex/#regex-and-not if isinstance ( pattern , str ): r = re . compile ( pattern ) else : r = pattern return QueryExpression ({ + field : r }) Sort helpers \u00b6 odmantic.query.SortExpression \u00b6 Base object used to build sort queries. odmantic.query.asc ( field ) \u00b6 Sort by ascending field . Source code in odmantic/query.py def asc ( field : FieldProxyAny ) -> SortExpression : \"\"\"Sort by ascending `field`.\"\"\" return _build_sort_expression ( field , 1 ) odmantic.query.desc ( field ) \u00b6 Sort by descending field . Source code in odmantic/query.py def desc ( field : FieldProxyAny ) -> SortExpression : \"\"\"Sort by descending `field`.\"\"\" return _build_sort_expression ( field , - 1 )","title":"odmantic.query"},{"location":"api_reference/query/#odmantic.query.QueryExpression","text":"Base object used to build queries. All comparison and logical operators returns QueryExpression objects. The | and & operators are supported for respectively the [or][odmantic.query.or_] and the [and][odmantic.query.and_] logical operators. Warning When using those operators make sure to correctly bracket the expressions to avoid python operator precedence issues.","title":"QueryExpression"},{"location":"api_reference/query/#logical-operators","text":"","title":"Logical Operators"},{"location":"api_reference/query/#odmantic.query.and_","text":"Logical AND operation between multiple QueryExpression objects. Source code in odmantic/query.py def and_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **AND** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$and\" : elements })","title":"and_()"},{"location":"api_reference/query/#odmantic.query.or_","text":"Logical OR operation between multiple QueryExpression objects. Source code in odmantic/query.py def or_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **OR** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$or\" : elements })","title":"or_()"},{"location":"api_reference/query/#odmantic.query.nor_","text":"Logical NOR operation between multiple QueryExpression objects. Source code in odmantic/query.py def nor_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **NOR** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$nor\" : elements })","title":"nor_()"},{"location":"api_reference/query/#comparison-operators","text":"","title":"Comparison Operators"},{"location":"api_reference/query/#odmantic.query.eq","text":"Equality comparison operator. Source code in odmantic/query.py def eq ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Equality comparison operator.\"\"\" return _cmp_expression ( field , \"$eq\" , value )","title":"eq()"},{"location":"api_reference/query/#odmantic.query.ne","text":"Inequality comparison operator (includes documents not containing the field). Source code in odmantic/query.py def ne ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Inequality comparison operator (includes documents not containing the field).\"\"\" return _cmp_expression ( field , \"$ne\" , value )","title":"ne()"},{"location":"api_reference/query/#odmantic.query.gt","text":"Greater than (strict) comparison operator (i.e. >). Source code in odmantic/query.py def gt ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Greater than (strict) comparison operator (i.e. >).\"\"\" return _cmp_expression ( field , \"$gt\" , value )","title":"gt()"},{"location":"api_reference/query/#odmantic.query.gte","text":"Greater than or equal comparison operator (i.e. >=). Source code in odmantic/query.py def gte ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Greater than or equal comparison operator (i.e. >=).\"\"\" return _cmp_expression ( field , \"$gte\" , value )","title":"gte()"},{"location":"api_reference/query/#odmantic.query.lt","text":"Less than (strict) comparison operator (i.e. <). Source code in odmantic/query.py def lt ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Less than (strict) comparison operator (i.e. <).\"\"\" return _cmp_expression ( field , \"$lt\" , value )","title":"lt()"},{"location":"api_reference/query/#odmantic.query.lte","text":"Less than or equal comparison operator (i.e. <=). Source code in odmantic/query.py def lte ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Less than or equal comparison operator (i.e. <=).\"\"\" return _cmp_expression ( field , \"$lte\" , value )","title":"lte()"},{"location":"api_reference/query/#odmantic.query.in_","text":"Select instances where field is contained in sequence . Source code in odmantic/query.py def in_ ( field : FieldProxyAny , sequence : Sequence ) -> QueryExpression : \"\"\"Select instances where `field` is contained in `sequence`.\"\"\" return _cmp_expression ( field , \"$in\" , sequence )","title":"in_()"},{"location":"api_reference/query/#odmantic.query.not_in","text":"Select instances where field is not contained in sequence . Source code in odmantic/query.py def not_in ( field : FieldProxyAny , sequence : Sequence ) -> QueryExpression : \"\"\"Select instances where `field` is **not** contained in `sequence`.\"\"\" return _cmp_expression ( field , \"$nin\" , sequence )","title":"not_in()"},{"location":"api_reference/query/#odmantic.query.match","text":"Select instances where field matches the pattern regular expression. Source code in odmantic/query.py def match ( field : FieldProxyAny , pattern : Union [ Pattern , str ]) -> QueryExpression : \"\"\"Select instances where `field` matches the `pattern` regular expression.\"\"\" # FIXME might create incompatibilities # https://docs.mongodb.com/manual/reference/operator/query/regex/#regex-and-not if isinstance ( pattern , str ): r = re . compile ( pattern ) else : r = pattern return QueryExpression ({ + field : r })","title":"match()"},{"location":"api_reference/query/#sort-helpers","text":"","title":"Sort helpers"},{"location":"api_reference/query/#odmantic.query.SortExpression","text":"Base object used to build sort queries.","title":"SortExpression"},{"location":"api_reference/query/#odmantic.query.asc","text":"Sort by ascending field . Source code in odmantic/query.py def asc ( field : FieldProxyAny ) -> SortExpression : \"\"\"Sort by ascending `field`.\"\"\" return _build_sort_expression ( field , 1 )","title":"asc()"},{"location":"api_reference/query/#odmantic.query.desc","text":"Sort by descending field . Source code in odmantic/query.py def desc ( field : FieldProxyAny ) -> SortExpression : \"\"\"Sort by descending `field`.\"\"\" return _build_sort_expression ( field , - 1 )","title":"desc()"},{"location":"api_reference/reference/","text":"odmantic.reference.Reference ( * , key_name = None ) \u00b6 Used to define reference fields. Parameters: Name Type Description Default key_name Optional[str] name of the Mongo key that stores the foreign key None Source code in odmantic/reference.py def Reference ( * , key_name : Optional [ str ] = None ) -> Any : \"\"\"Used to define reference fields. Args: key_name: name of the Mongo key that stores the foreign key <!-- #noqa: DAR201 --> \"\"\" return ODMReferenceInfo ( key_name = key_name )","title":"odmantic.reference"},{"location":"api_reference/reference/#odmantic.reference.Reference","text":"Used to define reference fields. Parameters: Name Type Description Default key_name Optional[str] name of the Mongo key that stores the foreign key None Source code in odmantic/reference.py def Reference ( * , key_name : Optional [ str ] = None ) -> Any : \"\"\"Used to define reference fields. Args: key_name: name of the Mongo key that stores the foreign key <!-- #noqa: DAR201 --> \"\"\" return ODMReferenceInfo ( key_name = key_name )","title":"Reference()"}]}