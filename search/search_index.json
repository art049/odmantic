{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>ODMantic</p> <p> </p> <p>Documentation: https://art049.github.io/odmantic/</p> <p>Sync and Async ODM (Object Document Mapper) for MongoDB based on standard Python type hints. Built on top of Pydantic for model definition and validation.</p> <p>Core features:</p> <ul> <li> <p>Simple: define your model by typing your fields using Python types, build queries   using Python comparison operators</p> </li> <li> <p>Developer experience: field/method autocompletion, type hints, data validation,   performing database operations with a functional API</p> </li> <li> <p>Fully typed: leverage static analysis to reduce runtime issues</p> </li> <li> <p>AsyncIO support: works well with ASGI frameworks (FastAPI, quart, sanic, Starlette, ...) but works also perfectly in synchronous environments</p> </li> <li> <p>Serialization: built-in JSON serialization and JSON schema generation</p> </li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<p>Python: 3.8 and later (tested against 3.8, 3.9, 3.10 and 3.11)</p> <p>Pydantic: 2.5 and later</p> <p>MongoDB: 4.0 and later</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install odmantic\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>To enjoy an async context without any code boilerplate, you can reproduce the following steps using the AsyncIO REPL (only for Python 3.8+).</p> <pre><code>python3.8 -m asyncio\n</code></pre> <p>If you are using an earlier version of Python, you can use IPython which provide an Autoawait feature (starting from Python 3.6).</p>"},{"location":"#define-your-first-model","title":"Define your first model","text":"<pre><code>from typing import Optional\n\nfrom odmantic import Field, Model\n\n\nclass Publisher(Model):\n    name: str\n    founded: int = Field(ge=1440)\n    location: Optional[str] = None\n</code></pre> <p>By defining the <code>Publisher</code> class, we've just created an ODMantic model \ud83c\udf89. In this example, the model will represent book publishers.</p> <p>This model contains three fields:</p> <ul> <li> <p><code>name</code>: This is the name of the Publisher. This is a simple string field without any   specific validation, but it will be required to build a new Publisher.</p> </li> <li> <p><code>founded</code>: This is the year of foundation of the Publisher. Since the printing press was invented in 1440, it would be handy to allow only values above 1440. The   <code>ge</code> keyword argument passed to the Field is exactly doing this. The model will   require a founded value greater or equal than 1440.</p> </li> <li> <p><code>location</code>: This field will contain the country code of the Publisher. Defining this   field as <code>Optional</code> with a <code>None</code> default value makes it a non required field that   will be set automatically when not specified.</p> </li> </ul> <p>The collection name has been defined by ODMantic as well. In this case it will be <code>publisher</code>.</p>"},{"location":"#create-some-instances","title":"Create some instances","text":"<pre><code>instances = [\n    Publisher(name=\"HarperCollins\", founded=1989, location=\"US\"),\n    Publisher(name=\"Hachette Livre\", founded=1826, location=\"FR\"),\n    Publisher(name=\"Lulu\", founded=2002)\n]\n</code></pre> <p>We defined three instances of the Publisher model. They all have a <code>name</code> property as it was required. All the foundations years are later than 1440. The last publisher has no location specified so by default this field is set to <code>None</code> (it will be stored as <code>null</code> in the database).</p> <p>For now, those instances only exists locally. We will persist them in a database in the next step.</p>"},{"location":"#populate-the-database-with-your-instances","title":"Populate the database with your instances","text":"<p>For the next steps, you'll need to start a local MongoDB server.The easiest way is to use docker. Simply run the next command in a terminal (closing the terminal will terminate the MongoDB instance and remove the container).</p> <pre><code>docker run --rm -p 27017:27017 mongo\n</code></pre> <p>First, let's connect to the database using the engine. In ODMantic, every database operation is performed using the engine object.</p> <pre><code>from odmantic import AIOEngine\n\nengine = AIOEngine()\n</code></pre> <p>By default, the <code>AIOEngine</code> (stands for AsyncIOEngine) automatically tries to connect to a MongoDB instance running locally (on port 27017). Since we didn't provide any database name, it will use the database named <code>test</code> by default.</p> <p>The next step is to persist the instances we created before. We can perform this operation using the <code>AIOEngine.save_all</code> method.</p> <pre><code>await engine.save_all(instances)\n</code></pre> <p>Most of the engine I/O methods are asynchronous, hence the <code>await</code> keyword used here. Once the operation is complete, we should be able to see our created documents in the database. You can use Compass or RoboMongo if you'd like to have a graphical interface.</p> <p>Another possibility is to use <code>mongo</code> CLI directly:</p> <pre><code>mongo --eval \"db.publisher.find({})\"\n</code></pre> <p>Output:</p> <pre><code>connecting to: mongodb://127.0.0.1:27017\n{\n  \"_id\": ObjectId(\"5f67b331514d6855bc5c54c9\"),\n  \"founded\": 1989,\n  \"location\": \"US\",\n  \"name\": \"HarperCollins\"\n},\n{\n  \"_id\": ObjectId(\"5f67b331514d6855bc5c54ca\"),\n  \"founded\":1826,\n  \"location\": \"FR\",\n  \"name\": \"Hachette Livre\"\n},\n{\n  \"_id\": ObjectId(\"5f67b331514d6855bc5c54cb\"),\n  \"founded\": 2002,\n  \"location\": null,\n  \"name\": \"Lulu\"\n}\n</code></pre> <p>The created instances are stored in the <code>test</code> database under the <code>publisher</code> collection.</p> <p>We can see that an <code>_id</code> field has been added to each document. MongoDB need this field to act as a primary key. Actually, this field is added by ODMantic and you can access it under the name <code>id</code>.</p> <pre><code>print(instances[0].id)\n#&gt; ObjectId(\"5f67b331514d6855bc5c54c9\")\n</code></pre>"},{"location":"#find-instances-matching-a-criteria","title":"Find instances matching a criteria","text":"<p>Since we now have some documents in the database, we can start building some queries.</p> <p>First, let's find publishers created before the 2000s:</p> <pre><code>early_publishers = await engine.find(Publisher, Publisher.founded &lt;= 2000)\nprint(early_publishers)\n#&gt; [Publisher(name=\"HarperCollins\", founded=1989, location=\"US),\n#&gt;  Publisher(name=\"Hachette Livre\", founded=1826, location=\"FR\")]\n</code></pre> <p>Here, we called the <code>engine.find</code> method. The first argument we need to specify is the Model class we want to query on (in our case <code>Publisher</code>). The second argument is the actual query. Similarly to SQLAlchemy, you can build ODMantic queries using the regular python operators.</p> <p>When awaited, the <code>engine.find</code> method will return the list of matching instances stored in the database.</p> <p>Another possibility is to query for at most one instance. For example, if we want to retrieve a publisher from Canada (CA):</p> <pre><code>ca_publisher = await engine.find_one(Publisher, Publisher.location == \"CA\")\nprint(ca_publisher)\n#&gt; None\n</code></pre> <p>Here the result is <code>None</code> because no matching instances have been found in the database. The <code>engine.find_one</code> method returns an instance if one exists in the database otherwise, it will return <code>None</code>.</p>"},{"location":"#modify-an-instance","title":"Modify an instance","text":"<p>Finally, let's edit some instances. For example, we can set the <code>location</code> for the publisher named <code>Lulu</code>. First, we need to gather the instance from the database:</p> <pre><code>lulu = await engine.find_one(Publisher, Publisher.name == \"Lulu\")\nprint(lulu)\n#&gt; Publisher(name=\"Lulu\", founded=2002, location=None)\n</code></pre> <p>We still have the same instance, with no location set. We can change this field:</p> <pre><code>lulu.location = \"US\"\nprint(lulu)\n#&gt; Publisher(name=\"Lulu\", founded=2002, location=\"US)\n</code></pre> <p>The location has been changed locally but the last step to persist this change is to save the document:</p> <pre><code>await engine.save(lulu)\n</code></pre> <p>We can now check the database state:</p> <pre><code>mongo --eval \"db.publisher.find({name: 'Lulu'})\"\n</code></pre> <p>Output:</p> <pre><code>connecting to: mongodb://127.0.0.1:27017\n{\n  \"_id\": ObjectId(\"5f67b331514d6855bc5c54cb\"),\n  \"founded\": 2002,\n  \"location\": \"US\",\n  \"name\": \"Lulu\"\n}\n</code></pre> <p>The document have been successfully updated !</p> <p>Now, what if we would like to change the foundation date with an invalid one (before 1440) ?</p> <pre><code>lulu.founded = 1000\n#&gt; ValidationError: 1 validation error for Publisher\n#&gt; founded\n#&gt;   ensure this value is greater than 1440\n#&gt;   (type=value_error.number.not_gt; limit_value=1440)\n</code></pre> <p>This will raise an exception as it's not matching the model definition.</p>"},{"location":"#next-steps","title":"Next steps","text":"<p>If you already have experience with Pydantic and FastAPI, the Usage with FastAPI example sould be interesting for you to get kickstarted.</p> <p>Otherwise, to get started on more advanced practices like relations and building more advanced queries, you can directly check the other sections of the documentation.</p> <p>If you wish to contribute to the project (Thank you! ), you can have a look to the Contributing section of the documentation.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the ISC license.</p>"},{"location":"changelog/","title":"Changelog","text":"<p><sub>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</sub></p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#101-2024-03-18","title":"1.0.1 - 2024-03-18","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li> <p>Optional and Union generic types definition issues (#416 by @netomi)</p> </li> <li> <p>Remove continuously changing example for DateTime objects (#406 by @Mokto)</p> </li> </ul>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Support the <code>examples</code> property in Field descriptors (#404 by @Mokto)</li> </ul>"},{"location":"changelog/#internals","title":"Internals","text":"<ul> <li> <p>Fix Pydantic docs URLs (#366 by @aminalaee)</p> </li> <li> <p>Add a test with a model when defining multiple optional fields (#426 by @art049)</p> </li> <li> <p>Bump ruff and use ruff format (#425 by @art049)</p> </li> </ul>"},{"location":"changelog/#100-2023-12-13","title":"1.0.0 - 2023-12-13","text":"<p>I'm excited to announce ODMantic v1.0.0, with Pydantic v2 support! \ud83c\udf89</p> <p>This release brings a range of changes that are aligned with the new Pydantic architecture. Keeping a maintainable and healthy codebase was especially important. Thus from now on, ODMantic will not support Python 3.7, Pydantic V1, and Motor 2.x anymore.</p> <p>Overall, integrating with Pydantic v2 brings around 30% performance improvements on common operations. \u26a1\ufe0f\u26a1\ufe0f\u26a1\ufe0f</p> <p>We have a lot of room to improve the performance further now that we only support Pydantic v2. There is also a 300% \ud83d\udc40 improvement on the bulk saves crafted by @tiangolo that will be merged soon! \ud83d\ude80</p> <p>Special thanks to @tiangolo for his help on this release and for saving me a lot of time figuring out a particularly annoying bug!</p> <p>Check out the migration guide to upgrade your codebase and enjoy this new release!</p>"},{"location":"changelog/#breaking-changes","title":"Breaking changes","text":"<ul> <li> <p>Support for Python 3.7, Pydantic v1 and Motor 2.x has been dropped</p> </li> <li> <p><code>Optional[T]</code> doesn't have a <code>None</code> implicit default value anymore</p> </li> <li> <p><code>Model.copy</code> doesn't support the <code>exclude</code> and <code>include</code> kwargs anymore</p> </li> <li> <p><code>odmantic.Field</code> doesn't accept extra kwargs anymore since it's slated to be removed in Pydantic</p> </li> <li> <p>The <code>Config</code> class is no longer supported and the <code>model_config</code> dict should be used instead</p> </li> <li> <p><code>DocumentParsingError</code> is no longer a subclass of <code>ValidationError</code></p> </li> <li> <p>The <code>__bson__</code> class method is no longer supported to define BSON encoders on custom types. The new method to customize BSON encoding is to use the <code>WithBSONSerializer</code> annotation.</p> </li> <li> <p>Decimals (<code>decimal.Decimal</code> and <code>bson.Decimal128</code>) are now serialized as strings in JSON documents</p> </li> <li> <p>Custom JSON encoders(defined with the <code>json_encoders</code> config option) are no longer effective on <code>odmantic.bson</code> types. Annotated types with <code>pydantic.PlainSerializer</code> should be used instead.</p> </li> </ul>"},{"location":"changelog/#removals","title":"Removals","text":"<ul> <li> <p><code>AIOEngineDependency</code> has been removed since it was deprecated in v0.2.0 in favor of a global engine object</p> </li> <li> <p>Defining the collection with <code>__collection__</code> has been removed since it was deprecated in v0.3.0 in favor of the <code>collection</code> config option</p> </li> </ul>"},{"location":"changelog/#deprecations","title":"Deprecations","text":"<p>We comply with the new Pydantic method naming, prefixing them with <code>model_</code></p> <ul> <li> <p><code>Model.dict</code> has been deprecated in favor of <code>Model.model_dump</code></p> </li> <li> <p><code>Model.doc</code> has been deprecated in favor of <code>Model.model_dump_doc</code></p> </li> <li> <p><code>Model.parse_doc</code> has been deprecated in favor of <code>Model.model_validate_doc</code></p> </li> <li> <p><code>Model.update</code> has been deprecated in favor of <code>Model.model_update</code></p> </li> <li> <p><code>Model.copy</code> has been deprecated in favor of <code>Model.model_copy</code></p> </li> </ul>"},{"location":"changelog/#details","title":"Details","text":"<ul> <li> <p>Integrate with Pydantic V2(#361 and #377 by @art049)</p> </li> <li> <p>Update CI to use GitHub Actions matrix instead of tox, upgrade minimum Pydantic to 1.10.8 as needed by the tests (#376 by @tiangolo)</p> </li> <li> <p>Add benchmarks on common sync operations (#362 by @art049)</p> </li> </ul>"},{"location":"changelog/#092-2023-01-03","title":"0.9.2 - 2023-01-03","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Properly handle literals among generic types (#313 by @art049)</li> </ul>"},{"location":"changelog/#internals_1","title":"Internals","text":"<ul> <li>Pin tox to fix CI (#308 by @tiangolo)</li> </ul>"},{"location":"changelog/#091-2022-11-24","title":"0.9.1 - 2022-11-24","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Bump motor version (#296 by @valeriiduz)</li> </ul>"},{"location":"changelog/#internals_2","title":"Internals","text":"<ul> <li>Migrate to ruff (#299 by @art049)</li> </ul>"},{"location":"changelog/#090-2022-09-25","title":"0.9.0 - 2022-09-25","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Create new generic types to support generic collection types (#240 by @erny &amp; @art049)</li> </ul> <p>Thus, it's now possible to define models like this in python 3.9+ \ud83d\ude80:     <pre><code>class User(Model):\n    scopes: list[str]\n    friendsIds: list[ObjectId]\n    skills: set[str]\n</code></pre></p> <ul> <li>Allow using generators with <code>in_</code> and <code>not_in</code>  (#270 by @art049)</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li> <p>Fix <code>EmbeddedModel</code> generics definition with a custom <code>key_name</code> (#269 by @art049)</p> </li> <li> <p>Raise a <code>TypeError</code> when defining a <code>Reference</code> in a generic(List, Dict, Tuple, ...) containing EmbeddedModels (#269 by @art049)</p> </li> </ul>"},{"location":"changelog/#080-2022-09-09","title":"0.8.0 - 2022-09-09","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li> <p>Allow Index definition (feature documentation) (#255 by @art049)</p> </li> <li> <p>Allow using the <code>Config.extra</code> attribute from pydantic (#259 by @art049)</p> </li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li> <p>Fix embedded models parsing with custom <code>key_name</code>  (#262 by @iXB3)</p> </li> <li> <p>Fix <code>engine.save</code> using an embedded model as a primary key (#258 by @art049)</p> </li> <li> <p>Fix engine creation typo in the documentation (#257 by @art049)</p> </li> </ul>"},{"location":"changelog/#071-2022-09-02","title":"0.7.1 - 2022-09-02","text":""},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Fix dataclass transform constructor type hints (#249 by @art049)</li> </ul>"},{"location":"changelog/#internals_3","title":"Internals","text":"<ul> <li>Update Mongo version in the CI build matrix (#247 by @art049)</li> </ul>"},{"location":"changelog/#070-2022-08-30","title":"0.7.0 - 2022-08-30","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li> <p>Add new SyncEngine, support async and sync code (#231 by  @tiangolo)</p> </li> <li> <p>Sync engine documentation (#238 by @art049)</p> </li> <li> <p>Friendly interface for session and transactions (#244 by @art049)</p> </li> <li> <p>Implement the <code>engine.remove</code> method to allow instance deletion from a query (#147 &amp; #237 by @joeriddles &amp; @art049)</p> </li> </ul>"},{"location":"changelog/#internals_4","title":"Internals","text":"<ul> <li> <p>Remove unnecessary Python 3.6 type fixes (#243 by @art049)</p> </li> <li> <p>Switch Mongo action to art049/mongodb-cluster-action (#245 by @art049)</p> </li> <li> <p>Add Realworld API integrated test (#246 by @art049)</p> </li> </ul>"},{"location":"changelog/#060-2022-08-24","title":"0.6.0 - 2022-08-24","text":""},{"location":"changelog/#breaking-changes_1","title":"Breaking Changes","text":"<ul> <li>Drop support for Python 3.6 (#230 by @tiangolo)</li> </ul>"},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li> <p>Upgrade types and add support for instance autocompletion with <code>dataclass_transform</code> (VS Code autocompletion) (#230 by @tiangolo)</p> </li> <li> <p>Support Python 3.10 (#235 by @art049)</p> </li> </ul>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li> <p>Fix using the shared session when updating a document (#227 by @tiangolo)</p> </li> <li> <p>Fix <code>EmbeddedModel</code> deep copy mutability (#239 by @art049)</p> </li> <li> <p>Allow models to contain string-based datetime fields that indicate UTC (#136 by @kfox)</p> </li> <li> <p>Fix <code>Reference</code> usage with non the non default primary key (#184 by @dynalz)</p> </li> <li> <p>Fix <code>key_name</code> use on EmbeddedModels (#195 by @jvanegmond)</p> </li> </ul>"},{"location":"changelog/#internals_5","title":"Internals","text":"<ul> <li> <p>Support Python 3.10 in tox (#236 by @art049)</p> </li> <li> <p>Fix missing f string in an exception message (#222 by @voglster)</p> </li> <li> <p>Finalize flit migration (#232 by @art049)</p> </li> </ul>"},{"location":"changelog/#050-2022-06-01","title":"0.5.0 - 2022-06-01","text":"<ul> <li> <p>Support motor 3.0 (#224 by @art049)</p> </li> <li> <p>Support pydantic 1.9.0 (#218 by @art049)</p> </li> </ul>"},{"location":"changelog/#040-2022-04-23","title":"0.4.0 - 2022-04-23","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li> <p>Update and copy methods:</p> <ul> <li>Updating multiple fields at once is now directly possible from a pydantic model or   a dictionary (feature documentation,   sample use case with FastAPI)</li> <li>Changing the primary field of an instance is now easier   (documentation)</li> </ul> </li> <li> <p>Patch and copy Model instances (#39 by @art049)</p> </li> </ul>"},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li> <p>Update example in README (#192 by @jasper-moment)</p> </li> <li> <p>Update README.md (#129 by @Kludex)</p> </li> </ul>"},{"location":"changelog/#internals_6","title":"Internals","text":"<ul> <li> <p>\u2b06\ufe0f Update motor requirement from &gt;=2.1.0,&lt;2.5.0 to &gt;=2.1.0,&lt;2.6.0 (#160 by @dependabot[bot])</p> </li> <li> <p>\u2b06\ufe0f Update typer requirement from ^0.3.2 to ^0.4.1 (#214 by @dependabot[bot])</p> </li> <li> <p>\u2b06\ufe0f Update mypy requirement from ^0.910 to ^0.942 (#215 by @dependabot[bot])</p> </li> <li> <p>\u2b06\ufe0f Update fastapi requirement from &gt;=0.61.1,&lt;0.67.0 to &gt;=0.61.1,&lt;0.69.0 (#166 by @dependabot[bot])</p> </li> <li> <p>\u2b06\ufe0f Update fastapi requirement from &gt;=0.61.1,&lt;0.64.0 to &gt;=0.61.1,&lt;0.67.0 (#150 by @dependabot[bot])</p> </li> <li> <p>\u2b06\ufe0f Update mypy requirement from ^0.812 to ^0.910 (#142 by @dependabot[bot])</p> </li> <li> <p>\u2b06\ufe0f Update pytest-asyncio requirement from ^0.14.0 to ^0.15.0 (#125 by @dependabot[bot])</p> </li> <li> <p>\u2b06\ufe0f Update motor requirement from &gt;=2.1.0,&lt;2.4.0 to &gt;=2.1.0,&lt;2.5.0 (#124 by @dependabot[bot])</p> </li> <li> <p>\u2b06\ufe0f Update importlib-metadata requirement from &gt;=1,&lt;4 to &gt;=1,&lt;5 (#126 by @dependabot[bot])</p> </li> <li> <p>\u2b06\ufe0f Update pydocstyle requirement from ^5.1.1 to ^6.0.0 (#119 by @dependabot[bot])</p> </li> <li> <p>\u2b06\ufe0f Update isort requirement from ~=5.7.0 to ~=5.8.0 (#122 by @dependabot[bot])</p> </li> <li> <p>\u2b06\ufe0f Update flake8 requirement from ~=3.8.4 to ~=3.9.0 (#116 by @dependabot[bot])</p> </li> </ul>"},{"location":"changelog/#035-2021-05-12","title":"0.3.5 - 2021-05-12","text":""},{"location":"changelog/#security","title":"Security","text":"<ul> <li>Change allowed pydantic versions to handle CVE-2021-29510 by @art049</li> </ul>"},{"location":"changelog/#034-2021-03-04","title":"0.3.4 - 2021-03-04","text":""},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li> <p>Fix modified mark clearing on save for nested models (#88 by @Olegt0rr)</p> </li> <li> <p>Don't replace default field description for ObjectId (#82 by @Olegt0rr)</p> </li> </ul>"},{"location":"changelog/#internals_7","title":"Internals","text":"<ul> <li> <p>Support pydantic 1.8 (#113 by @art049)</p> </li> <li> <p>Add nightly builds (#114 by @art049)</p> </li> <li> <p>CI Matrix with Standalone instances, ReplicaSets and Sharded clusters (#91 by @art049)</p> </li> <li> <p>Update mkdocstrings requirement from ^0.14.0 to ^0.15.0 (#110 by @dependabot[bot])</p> </li> <li> <p>Update mkdocs-material requirement from ^6.0.2 to ^7.0.3 (#111 by @dependabot[bot])</p> </li> <li> <p>Update mypy requirement from ^0.800 to ^0.812 (#106 by @dependabot[bot])</p> </li> </ul>"},{"location":"changelog/#033-2021-02-13","title":"0.3.3 - 2021-02-13","text":""},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li> <p>Remove <code>bypass_document_validation</code> save option to avoid <code>Not Authorized</code> errors (#85 by @Olegt0rr)</p> </li> <li> <p>Fix microseconds issue: use truncation instead of round (#100 by @erny)</p> </li> <li> <p>Add py.typed to ship typing information for mypy (#101 by @art049)</p> </li> <li> <p>Fix datetime field default example value naiveness (#103 by @art049)</p> </li> </ul>"},{"location":"changelog/#internals_8","title":"Internals","text":"<ul> <li> <p>Update pytz requirement from ^2020.1 to ^2021.1 (#98 by @dependabot[bot])</p> </li> <li> <p>Update mkdocstrings requirement from ^0.13.2 to ^0.14.0 (#92 by @dependabot[bot])</p> </li> <li> <p>Update mypy requirement from ^0.790 to ^0.800 (#97 by @dependabot[bot])</p> </li> <li> <p>Update isort requirement from ~=5.6.4 to ~=5.7.0 (#90 by @dependabot[bot])</p> </li> <li> <p>Update fastapi requirement from &gt;=0.61.1,&lt;0.63.0 to &gt;=0.61.1,&lt;0.64.0 (#84 by @dependabot[bot])</p> </li> </ul>"},{"location":"changelog/#032-2020-12-15","title":"0.3.2 - 2020-12-15","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li> <p>Fix embedded model field update (#77 by @art049)</p> </li> <li> <p>Fix <code>datetime</code> bson inheritance issue (#78 by @Olegt0rr)</p> </li> </ul>"},{"location":"changelog/#internals_9","title":"Internals","text":"<ul> <li> <p>Migrate to the updated prettier precommit hook (#74 by @art049)</p> </li> <li> <p>Fix tox dependency install (#72 by @art049)</p> </li> <li> <p>Update uvicorn requirement from ^0.12.1 to ^0.13.0 (#67 by @dependabot[bot])</p> </li> <li> <p>Update mypy requirement from ^0.782 to ^0.790 (#48 by @dependabot[bot])</p> </li> <li> <p>Update importlib-metadata requirement from ^1.0 to &gt;=1,&lt;4 (#54 by @dependabot[bot])</p> </li> <li> <p>Update flake8 requirement from ==3.8.3 to ==3.8.4 (#47 by @dependabot[bot])</p> </li> <li> <p>Update fastapi requirement from ^0.61.1 to &gt;=0.61.1,&lt;0.63.0 (#59 by @dependabot[bot])</p> </li> </ul>"},{"location":"changelog/#031-2020-11-16","title":"0.3.1 - 2020-11-16","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Add <code>schema_extra</code> config option (#41 by @art049)</li> </ul>"},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>Fix <code>setattr</code> error on a manually initialized EmbeddedModel (#40 by @art049)</li> </ul>"},{"location":"changelog/#030-2020-11-09","title":"0.3.0 - 2020-11-09","text":""},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li>Deprecate usage of <code>__collection__</code> to customize the collection name. Prefer the   <code>collection</code> Config option (more   details)</li> </ul>"},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li> <p>Allow parsing document with unset fields defaults (documentation) (#28 by @art049)</p> </li> <li> <p>Integration with Pydantic <code>Config</code> class (#37 by @art049):</p> <ul> <li>It's now possible to define custom <code>json_encoders</code> on the Models</li> <li>Some other <code>Config</code> options provided by Pydantic are now available (more   details)</li> </ul> </li> <li> <p>Support CPython 3.9 (#32 by   @art049)</p> </li> <li> <p>Unpin pydantic to support 1.7.0 (#29 by   @art049)</p> </li> </ul>"},{"location":"changelog/#021-2020-10-25","title":"0.2.1 - 2020-10-25","text":""},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li>Fix combined use of <code>skip</code> and <code>limit</code> with <code>engine.find</code> (#25 by @art049)</li> </ul>"},{"location":"changelog/#020-2020-10-25","title":"0.2.0 - 2020-10-25","text":""},{"location":"changelog/#deprecated_1","title":"Deprecated","text":"<ul> <li>Deprecate <code>AIOEngineDependency</code> to prefer a global engine object, more   details (#21 by   @art049)</li> </ul>"},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>Add sorting support (#17 by @adriencaccia)</li> <li>Support motor 2.3.0 (#20 by @art049)</li> </ul>"},{"location":"changelog/#fixed_12","title":"Fixed","text":"<ul> <li>Fix FastAPI usage with References (#19 by @art049)</li> </ul>"},{"location":"changelog/#docs","title":"Docs","text":"<ul> <li>Adding a CONTRIBUTING.md file to the root directory with link to docs (#8 by @sanders41)</li> <li>Raw Query Usage Documentation Fix (#10 by @adeelsohailahmed)</li> <li>Update Filtering to include Bitwise Operator Warning (#24 by @adeelsohailahmed)</li> </ul>"},{"location":"changelog/#010-2020-10-19","title":"0.1.0 - 2020-10-19","text":""},{"location":"changelog/#initial-release","title":"Initial Release","text":""},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#sharing-feedback","title":"Sharing feedback","text":"<p>This project is still quite new and therefore having your feedback will really help to prioritize relevant feature developments .</p> <p>The easiest way to share feedback and discuss about the project is to join the Gitter chatroom.</p> <p>If you want to contribute (thanks a lot ! ), you can open an issue on Github.</p> <p>Before creating a non obvious (typo, documentation fix) Pull Request, please make sure to open an issue.</p>"},{"location":"contributing/#developing-locally","title":"Developing locally","text":""},{"location":"contributing/#with-the-vscodes-devcontainer-feature","title":"With the VSCode's devcontainer feature","text":"<p>This feature will make the tools/environment installation very simple as you will develop in a container that has already been configured to run this project.</p> <p>Here are the steps:</p> <ol> <li>Clone the repository and open it with Visual Studio    Code.</li> <li>Make sure that the Remote -     Containers     (<code>ms-vscode-remote.remote-containers</code>) extension is installed.</li> <li>Run the <code>Remote-Container: Reopen in Container</code> command (press <code>Ctrl</code>+<code>Shift</code>+<code>P</code> and    then type the command).</li> <li>After the setup script completes, the environment is ready. You can start the local    development .</li> </ol> <p>You can go to the development tasks section to see the    available <code>task</code> commands.</p> <p>MongoDB container</p> <p>In this containerized development environment, a MongoDB instance should already be running as a part of the development <code>docker-compose.yml</code> file internally used by VSCode.</p>"},{"location":"contributing/#regular-environment-setup","title":"Regular environment setup","text":""},{"location":"contributing/#installing-the-tools","title":"Installing the tools","text":"<ul> <li>Git LFS: used to store documentation assets in the repository</li> <li>Docker: used to run a local MongoDB instance</li> <li>Docker Compose (Optional): used to run a local MongoDB cluster (replica set or shards)</li> <li>Task: task manager</li> </ul> <p>Installing python based development tools</p> <p>In order to install the devtools written in python, it's recommended to use pipx.</p> <pre><code>python3 -m pip install --user pipx\npython3 -m pipx ensurepath\n</code></pre> <ul> <li> <p>flit: packaging system and dependency   manager   <pre><code>pipx install flit\n</code></pre></p> </li> <li> <p>tox: multi-environment test runner   <pre><code>pipx install tox\n</code></pre></p> </li> <li> <p>pre-commit: pre commit hook manager   <pre><code>pipx install pre-commit\n</code></pre></p> </li> </ul> <p>Python versions</p> <p>If you want to test the project with multiple python versions, you'll need to install them manually.</p> <p>You can use pyenv to  install them easily.</p> <pre><code># Install the versions\npyenv install \"3.7.9\"\npyenv install \"3.8.9\"\npyenv install \"3.9.0\"\n# Make the versions available locally in the project\npyenv local 3.8.6 3.7.9 3.9.0\n</code></pre>"},{"location":"contributing/#configuring-the-local-environment","title":"Configuring the local environment","text":"<pre><code>task setup\n</code></pre>"},{"location":"contributing/#running-development-tasks","title":"Running development tasks","text":"<p>The following tasks are available for the project:</p> <ul> <li> <p><code>task setup</code>: Configure the development environment.</p> </li> <li> <p><code>task lint</code>: Run the linting checks.</p> </li> <li> <p><code>task format</code>: Format the code (and imports).</p> </li> <li> <p><code>mongodb:standalone-docker</code>: Start a standalone MongoDB instance using a docker container</p> </li> <li> <p><code>mongodb:standalone-docker:down</code>: Stop the standalone instance</p> </li> <li> <p><code>mongodb:replica-compose</code>: Start a replica set MongoDB cluster using docker-compose</p> </li> <li> <p><code>mongodb:replica-compose:down</code>: Stop the replica set cluster</p> </li> <li> <p><code>mongodb:sharded-compose</code>: Start a sharded MongoDB cluster using docker-compose</p> </li> <li> <p><code>mongodb:sharded-compose:down</code>: Stop the sharded MongoDB cluster</p> </li> <li> <p><code>task test</code>: Run the tests with the current version.</p> </li> <li> <p><code>task full-test</code>: Run the tests against all supported versions.</p> </li> <li> <p><code>task coverage</code>: Get the test coverage (xml and html) with the current version.</p> </li> <li> <p><code>task docs</code>: Start the local documentation server.</p> </li> </ul>"},{"location":"engine/","title":"Engine","text":"<p>This engine documentation present how to work with both the Sync (SyncEngine) and the Async (AIOEngine) engines. The methods available for both are very close but the main difference is that the Async engine exposes coroutines instead of functions for the Sync engine.</p>"},{"location":"engine/#creating-the-engine","title":"Creating the engine","text":"<p>In the previous examples, we created the engine using default parameters:</p> <ul> <li> <p>MongoDB: running on <code>localhost</code> port <code>27017</code></p> </li> <li> <p>Database name: <code>test</code></p> </li> </ul> <p>It's possible to provide a custom client (AsyncIOMotorClient or PyMongoClient) to the engine constructor. In the same way, the database name can be changed using the <code>database</code> keyword argument.</p> AsyncSync <pre><code>from motor.motor_asyncio import AsyncIOMotorClient\n\nfrom odmantic import AIOEngine\n\nclient = AsyncIOMotorClient(\"mongodb://localhost:27017/\")\nengine = AIOEngine(client=client, database=\"example_db\")\n</code></pre> <pre><code>from pymongo import MongoClient\n\nfrom odmantic import SyncEngine\n\nclient = MongoClient(\"mongodb://localhost:27017/\")\nengine = SyncEngine(client=client, database=\"example_db\")\n</code></pre> <p>For additional information about the MongoDB connection strings, see this section of the MongoDB documentation.</p> <p>Usage with DNS SRV records</p> <p>If you decide to use the DNS Seed List Connection Format (i.e <code>mongodb+srv://...</code>), you will need to install the dnspython package.</p>"},{"location":"engine/#create","title":"Create","text":"<p>There are two ways of persisting instances to the database (i.e creating new documents):</p> <ul> <li> <p><code>engine.save</code>: to save a single instance</p> </li> <li> <p><code>engine.save_all</code>: to save multiple instances at   once</p> </li> </ul> AsyncSync <pre><code>from odmantic import AIOEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = AIOEngine()\n\nleeroy = Player(name=\"Leeroy Jenkins\", game=\"World of Warcraft\")\nawait engine.save(leeroy)\n\nplayers = [\n    Player(name=\"Shroud\", game=\"Counter-Strike\"),\n    Player(name=\"Serral\", game=\"Starcraft\"),\n    Player(name=\"TLO\", game=\"Starcraft\"),\n]\nawait engine.save_all(players)\n</code></pre> <pre><code>from odmantic import SyncEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = SyncEngine()\n\nleeroy = Player(name=\"Leeroy Jenkins\", game=\"World of Warcraft\")\nengine.save(leeroy)\n\nplayers = [\n    Player(name=\"Shroud\", game=\"Counter-Strike\"),\n    Player(name=\"Serral\", game=\"Starcraft\"),\n    Player(name=\"TLO\", game=\"Starcraft\"),\n]\nengine.save_all(players)\n</code></pre> Resulting documents in the <code>player</code> collection <pre><code>{\n  \"_id\": ObjectId(\"5f85f36d6dfecacc68428a46\"),\n  \"game\": \"World of Warcraft\",\n  \"name\": \"Leeroy Jenkins\"\n}\n{\n  \"_id\": ObjectId(\"5f85f36d6dfecacc68428a47\"),\n  \"game\": \"Counter-Strike\",\n  \"name\": \"Shroud\"\n}\n{\n  \"_id\": ObjectId(\"5f85f36d6dfecacc68428a49\"),\n  \"game\": \"Starcraft\",\n  \"name\": \"TLO\"\n}\n{\n  \"_id\": ObjectId(\"5f85f36d6dfecacc68428a48\"),\n  \"game\": \"Starcraft\",\n  \"name\": \"Serral\"\n}\n</code></pre> <p>Referenced instances</p> <p>When calling <code>engine.save</code> or <code>engine.save_all</code>, the referenced models will are persisted as well.</p> <p>Upsert behavior</p> <p>The <code>save</code> and <code>save_all</code> methods behave as upsert operations (more details). Hence, you might overwrite documents if you save instances with an existing primary key already existing in the database.</p>"},{"location":"engine/#read","title":"Read","text":"<p>Examples database content</p> <p>The next examples will consider that you have a <code>player</code> collection populated with the documents previously created.</p>"},{"location":"engine/#fetch-a-single-instance","title":"Fetch a single instance","text":"<p>As with regular MongoDB driver, you can use the <code>engine.find_one</code> method to get at most one instance of a specific Model. This method will either return an instance matching the specified criteriums or <code>None</code> if no instances have been found.</p> AsyncSync <pre><code>from odmantic import AIOEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = AIOEngine()\n\nplayer = await engine.find_one(Player, Player.name == \"Serral\")\nprint(repr(player))\n#&gt; Player(id=ObjectId(...), name=\"Serral\", game=\"Starcraft\")\n\nanother_player = await engine.find_one(\n    Player, Player.name == \"Player_Not_Stored_In_Database\"\n)\nprint(another_player)\n#&gt; None\n</code></pre> <pre><code>from odmantic import Model, SyncEngine\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = SyncEngine()\n\nplayer = engine.find_one(Player, Player.name == \"Serral\")\nprint(repr(player))\n#&gt; Player(id=ObjectId(...), name=\"Serral\", game=\"Starcraft\")\n\nanother_player = engine.find_one(\n    Player, Player.name == \"Player_Not_Stored_In_Database\"\n)\nprint(another_player)\n#&gt; None\n</code></pre> <p>Missing values in documents</p> <p>While parsing the MongoDB documents into Model instances, ODMantic will use the provided default values to populate the missing fields.</p> <p>See this section for more details about document parsing.</p> <p>Fetch using <code>sort</code></p> <p>We can use the <code>sort</code> parameter to fetch the <code>Player</code> instance with the first <code>name</code> in ascending order: <pre><code>await engine.find_one(Player, sort=Player.name)\n</code></pre> Find out more on <code>sort</code> in the dedicated section.</p>"},{"location":"engine/#fetch-multiple-instances","title":"Fetch multiple instances","text":"<p>To get more than one instance from the database at once, you can use the <code>engine.find</code> method.</p> <p>This method will return a cursor: an AIOCursor object for the AIOEngine and a SyncCursor object for the SyncEngine.</p> <p>Those cursors can mainly be used in two different ways:</p>"},{"location":"engine/#usage-as-an-iterator","title":"Usage as an iterator","text":"AsyncSync <pre><code>from odmantic import AIOEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = AIOEngine()\n\nasync for player in engine.find(Player, Player.game == \"Starcraft\"):\n    print(repr(player))\n\n#&gt; Player(id=ObjectId(...), name='TLO', game='Starcraft')\n#&gt; Player(id=ObjectId(...), name='Serral', game='Starcraft')\n</code></pre> <pre><code>from odmantic import Model, SyncEngine\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = SyncEngine()\n\nfor player in engine.find(Player, Player.game == \"Starcraft\"):\n    print(repr(player))\n\n#&gt; Player(id=ObjectId(...), name='TLO', game='Starcraft')\n#&gt; Player(id=ObjectId(...), name='Serral', game='Starcraft')\n</code></pre> <p>Ordering instances</p> <p>The <code>sort</code> parameter allows to order the query in ascending or descending order on a single or multiple fields. <pre><code>engine.find(Player, sort=(Player.name, Player.game.desc()))\n</code></pre> Find out more on <code>sort</code> in the dedicated section.</p>"},{"location":"engine/#usage-as-an-awaitablelist","title":"Usage as an awaitable/list","text":"<p>Even if the iterator usage should be preferred, in some cases it might be required to gather all the documents from the database before processing them.</p> AsyncSync <pre><code>from odmantic import AIOEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = AIOEngine()\n\nplayers = await engine.find(Player, Player.game != \"Starcraft\")\nprint(players)\n#&gt; [\n#&gt;     Player(id=ObjectId(...), name=\"Leeroy Jenkins\", game=\"World of Warcraft\"),\n#&gt;     Player(id=ObjectId(...), name=\"Shroud\", game=\"Counter-Strike\"),\n#&gt; ]\n</code></pre> <pre><code>from odmantic import SyncEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = SyncEngine()\n\nplayers = list(engine.find(Player, Player.game != \"Starcraft\"))\nprint(players)\n#&gt; [\n#&gt;     Player(id=ObjectId(...), name=\"Leeroy Jenkins\", game=\"World of Warcraft\"),\n#&gt;     Player(id=ObjectId(...), name=\"Shroud\", game=\"Counter-Strike\"),\n#&gt; ]\n</code></pre> <p>Pagination</p> <p>When using AIOEngine.find or SyncEngine.find you can as well use the <code>skip</code> and <code>limit</code> keyword arguments , respectively to skip a specified number of instances and to limit the number of fetched instances.</p> <p>Referenced instances</p> <p>When calling <code>engine.find</code> or <code>engine.find_one</code>, the referenced models will be recursively resolved as well by design.</p> <p>Passing the model class to <code>find</code> and <code>find_one</code></p> <p>When using the method to retrieve instances from the database, you have to specify the Model you want to query on as the first positional parameter. Internally, this enables ODMantic to properly type the results.</p>"},{"location":"engine/#count-instances","title":"Count instances","text":"<p>You can count instances in the database by using the <code>engine.count</code> method and as with other read methods, it's still possible to use this method with filtering queries.</p> AsyncSync <pre><code>from odmantic import AIOEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = AIOEngine()\n\nplayer_count = await engine.count(Player)\nprint(player_count)\n#&gt; 4\ncs_count = await engine.count(Player, Player.game == \"Counter-Strike\")\nprint(cs_count)\n#&gt; 1\nvalorant_count = await engine.count(Player, Player.game == \"Valorant\")\nprint(valorant_count)\n#&gt; 0\n</code></pre> <pre><code>from odmantic import Model, SyncEngine\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = SyncEngine()\n\nplayer_count = engine.count(Player)\nprint(player_count)\n#&gt; 4\ncs_count = engine.count(Player, Player.game == \"Counter-Strike\")\nprint(cs_count)\n#&gt; 1\nvalorant_count = engine.count(Player, Player.game == \"Valorant\")\nprint(valorant_count)\n#&gt; 0\n</code></pre> <p>Combining multiple queries in read operations</p> <p>While using find, find_one or count, you may pass as many queries as you want as positional arguments. Those will be implicitly combined as single and_ query.</p>"},{"location":"engine/#update","title":"Update","text":"<p>Updating an instance in the database can be done by modifying the instance locally and saving it again to the database.</p> <p>The <code>engine.save</code> and <code>engine.save_all</code> methods are actually behaving as <code>upsert</code> operations. In other words, if the instance already exists it will be updated. Otherwise, the related document will be created in the database.</p>"},{"location":"engine/#modifying-one-field","title":"Modifying one field","text":"<p>Modifying a single field can be achieved by directly changing the instance attribute and saving the instance.</p> AsyncSync <pre><code>from odmantic import AIOEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = AIOEngine()\nshroud = await engine.find_one(Player, Player.name == \"Shroud\")\nprint(shroud.game)\n#&gt; Counter-Strike\nshroud.game = \"Valorant\"\nawait engine.save(shroud)\n</code></pre> <pre><code>from odmantic import SyncEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = SyncEngine()\nshroud = engine.find_one(Player, Player.name == \"Shroud\")\nprint(shroud.game)\n#&gt; Counter-Strike\nshroud.game = \"Valorant\"\nengine.save(shroud)\n</code></pre> Resulting documents in the <code>player</code> collection <pre><code>{\n  \"_id\": ObjectId(\"5f85f36d6dfecacc68428a46\"),\n  \"game\": \"World of Warcraft\",\n  \"name\": \"Leeroy Jenkins\"\n}\n{\n  \"_id\": ObjectId(\"5f85f36d6dfecacc68428a47\"),\n  \"game\": \"Valorant\",\n  \"name\": \"Shroud\"\n}\n{\n  \"_id\": ObjectId(\"5f85f36d6dfecacc68428a49\"),\n  \"game\": \"Starcraft\",\n  \"name\": \"TLO\"\n}\n{\n  \"_id\": ObjectId(\"5f85f36d6dfecacc68428a48\"),\n  \"game\": \"Starcraft\",\n  \"name\": \"Serral\"\n}\n</code></pre>"},{"location":"engine/#patching-multiple-fields-at-once","title":"Patching multiple fields at once","text":"<p>The easiest way to change multiple fields at once is to use the Model.model_update method. This method will take either a Pydantic object or a dictionary and update the matching fields of the instance.</p>"},{"location":"engine/#from-a-pydantic-model","title":"From a Pydantic Model","text":"AsyncSync <pre><code>from pydantic import BaseModel\n\nfrom odmantic import AIOEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = AIOEngine()\n\n\nplayer_tlo = await engine.find_one(Player, Player.name == \"TLO\")\nprint(repr(player_tlo))\n#&gt; Player(id=ObjectId(...), name='TLO', game='Starcraft')\n\n# Create the structure of the patch object with pydantic\nclass PatchPlayerSchema(BaseModel):\n    name: str\n    game: str\n\n\n# Create the patch object containing the new values\npatch_object = PatchPlayerSchema(name=\"TheLittleOne\", game=\"Starcraft II\")\n# Apply the patch to the instance\nplayer_tlo.model_update(patch_object)\n\nprint(repr(player_tlo))\n#&gt; Player(id=ObjectId(...), name='TheLittleOne', game='Starcraft II')\n\n# Finally persist again the new instance\nawait engine.save(player_tlo)\n</code></pre> <pre><code>from pydantic import BaseModel\n\nfrom odmantic import Model, SyncEngine\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = SyncEngine()\n\n\nplayer_tlo = engine.find_one(Player, Player.name == \"TLO\")\nprint(repr(player_tlo))\n#&gt; Player(id=ObjectId(...), name='TLO', game='Starcraft')\n\n# Create the structure of the patch object with pydantic\nclass PatchPlayerSchema(BaseModel):\n    name: str\n    game: str\n\n\n# Create the patch object containing the new values\npatch_object = PatchPlayerSchema(name=\"TheLittleOne\", game=\"Starcraft II\")\n# Apply the patch to the instance\nplayer_tlo.model_update(patch_object)\n\nprint(repr(player_tlo))\n#&gt; Player(id=ObjectId(...), name='TheLittleOne', game='Starcraft II')\n\n# Finally persist again the new instance\nengine.save(player_tlo)\n</code></pre>"},{"location":"engine/#from-a-dictionary","title":"From a dictionary","text":"AsyncSync <pre><code>from odmantic import AIOEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = AIOEngine()\n\nplayer_tlo = await engine.find_one(Player, Player.name == \"TLO\")\nprint(repr(player_tlo))\n#&gt; Player(id=ObjectId(...), name='TLO', game='Starcraft')\n\n# Create the patch dictionary containing the new values\npatch_object = {\"name\": \"TheLittleOne\", \"game\": \"Starcraft II\"}\n# Update the local instance\nplayer_tlo.model_update(patch_object)\n\nprint(repr(player_tlo))\n#&gt; Player(id=ObjectId(...), name='TheLittleOne', game='Starcraft II')\n\n# Finally persist the instance\nawait engine.save(player_tlo)\n</code></pre> <pre><code>from odmantic import Model, SyncEngine\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = SyncEngine()\n\nplayer_tlo = engine.find_one(Player, Player.name == \"TLO\")\nprint(repr(player_tlo))\n#&gt; Player(id=ObjectId(...), name='TLO', game='Starcraft')\n\n# Create the patch dictionary containing the new values\npatch_object = {\"name\": \"TheLittleOne\", \"game\": \"Starcraft II\"}\n# Update the local instance\nplayer_tlo.model_update(patch_object)\n\nprint(repr(player_tlo))\n#&gt; Player(id=ObjectId(...), name='TheLittleOne', game='Starcraft II')\n\n# Finally persist the instance\nengine.save(player_tlo)\n</code></pre> <p>Resulting document associated to the player</p> <pre><code>{\n  \"_id\": ObjectId(\"5f85f36d6dfecacc68428a49\"),\n  \"game\": \"Starcraft II\",\n  \"name\": \"TheLittleOne\"\n}\n</code></pre>"},{"location":"engine/#changing-the-primary-field","title":"Changing the primary field","text":"<p>Directly changing the primary field value as explained above is not possible and a <code>NotImplementedError</code> exception will be raised if you try to do so.</p> <p>The easiest way to change an instance primary field is to perform a local copy of the instance using the Model.copy method.</p> AsyncSync <pre><code>from bson import ObjectId\n\nfrom odmantic import AIOEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = AIOEngine()\n\nshroud = await engine.find_one(Player, Player.name == \"Shroud\")\nprint(shroud.id)\n#&gt; 5f86074f6dfecacc68428a62\nnew_id = ObjectId(\"ffffffffffffffffffffffff\")\n# Copy the player instance with a new primary key\nnew_shroud = shroud.copy(update={\"id\": new_id})\n# Delete the initial player instance\nawait engine.delete(shroud)\n# Finally persist again the new instance\nawait engine.save(new_shroud)\n</code></pre> <pre><code>from bson import ObjectId\n\nfrom odmantic import SyncEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = SyncEngine()\n\nshroud = engine.find_one(Player, Player.name == \"Shroud\")\nprint(shroud.id)\n#&gt; 5f86074f6dfecacc68428a62\nnew_id = ObjectId(\"ffffffffffffffffffffffff\")\n# Copy the player instance with a new primary key\nnew_shroud = shroud.copy(update={\"id\": new_id})\n# Delete the initial player instance\nengine.delete(shroud)\n# Finally persist again the new instance\nengine.save(new_shroud)\n</code></pre> <p>Resulting document associated to the player</p> <pre><code>{\n    \"_id\": ObjectId(\"ffffffffffffffffffffffff\"),\n    \"game\": \"Valorant\",\n    \"name\": \"Shroud\"\n}\n</code></pre> <p>Update data used with the copy</p> <p>The data updated by the copy method is not validated: you should absolutely trust this data.</p>"},{"location":"engine/#delete","title":"Delete","text":""},{"location":"engine/#delete-a-single-instance","title":"Delete a single instance","text":"<p>You can delete instance by passing them to the <code>engine.delete</code> method.</p> AsyncSync <pre><code>from odmantic import AIOEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = AIOEngine()\n\nplayers = await engine.find(Player)\n\nfor player in players:\n    await engine.delete(player)\n</code></pre> <pre><code>from odmantic import SyncEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = SyncEngine()\n\nplayers = engine.find(Player)\n\nfor player in players:\n    engine.delete(player)\n</code></pre>"},{"location":"engine/#remove","title":"Remove","text":"<p>You can delete instances that match a filter by using the <code>engine.remove</code> method.</p> AsyncSync <pre><code>from odmantic import AIOEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = AIOEngine()\n\ndelete_count = await engine.remove(Player, Player.game == \"Warzone\")\nprint(delete_count)\n#&gt; 2\n</code></pre> <pre><code>from odmantic import SyncEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = SyncEngine()\n\ndelete_count = engine.remove(Player, Player.game == \"Warzone\")\nprint(delete_count)\n#&gt; 2\n</code></pre>"},{"location":"engine/#just-one","title":"Just one","text":"<p>You can limit <code>engine.remove</code> to removing only one instance by passing <code>just_one</code>.</p> AsyncSync <pre><code>from odmantic import AIOEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = AIOEngine()\n\ndelete_count = await engine.remove(\n    Player, Player.game == \"Warzone\", just_one=True\n)\nprint(delete_count)\n#&gt; 1\n</code></pre> <pre><code>from odmantic import Model, SyncEngine\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = SyncEngine()\n\ndelete_count = engine.remove(\n    Player, Player.game == \"Warzone\", just_one=True\n)\nprint(delete_count)\n#&gt; 1\n</code></pre>"},{"location":"engine/#consistency","title":"Consistency","text":""},{"location":"engine/#using-a-session","title":"Using a Session","text":"<p>Why are sessions needed ?</p> <p>A session is a way to guarantee that the data you read is consistent with the data you write. This is especially useful when you need to perform multiple operations on the same data.</p> <p>See this document for more details on causal consistency.</p> <p>You can create a session by using the <code>engine.session</code> method. This method will return either a SyncSession or an AIOSession object, depending on the type of engine used. Those session objects are context manager and can be used along with the <code>with</code> or the <code>async with</code> keywords. Once the context is entered the <code>session</code> object exposes the same database operation methods as the related <code>engine</code> object but execute each operation in the session context.</p> AsyncSync <pre><code>from odmantic import AIOEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = AIOEngine()\n\nleeroy = Player(name=\"Leeroy Jenkins\", game=\"World of Warcraft\")\n\nasync with engine.session() as session:\n    await session.save_all(\n        [\n            Player(name=\"Shroud\", game=\"Counter-Strike\"),\n            Player(name=\"Serral\", game=\"Starcraft\"),\n            Player(name=\"TLO\", game=\"Starcraft\"),\n        ]\n    )\n    player_count = await session.count(Player)\n    print(player_count)\n    #&gt; 3\n</code></pre> <pre><code>from odmantic import SyncEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = SyncEngine()\n\nleeroy = Player(name=\"Leeroy Jenkins\", game=\"World of Warcraft\")\n\nwith engine.session() as session:\n    session.save_all(\n        [\n            Player(name=\"Shroud\", game=\"Counter-Strike\"),\n            Player(name=\"Serral\", game=\"Starcraft\"),\n            Player(name=\"TLO\", game=\"Starcraft\"),\n        ]\n    )\n    player_count = session.count(Player)\n    print(player_count)\n    #&gt; 3\n</code></pre> <p>Directly using driver sessions</p> <p>Every single engine method also accepts a <code>session</code> parameter. You can use this parameter to provide an existing driver (motor or PyMongo) session that you created manually.</p> <p>Accessing the underlying driver session object</p> <p>The <code>session.get_driver_session</code> method exposes the underlying driver session. This is useful if you want to use the driver session directly to perform raw operations.</p>"},{"location":"engine/#using-a-transaction","title":"Using a Transaction","text":"<p>Why are transactions needed ?</p> <p>A transaction is a mechanism that allows you to execute multiple operations in a single atomic operation. This is useful when you want to ensure that a set of operations is atomicly performed on a specific document.</p> <p>MongoDB transaction support</p> <p>Transactions are only supported in a replica sets (Mongo 4.0+) or sharded clusters with replication enabled (Mongo 4.2+), if you use them in a standalone MongoDB instance an error will be raised.</p> <p>You can create a transaction directly from the engine by using the <code>engine.transaction</code> method. This methods will either return a SyncTransaction or an AIOTransaction object. As for sessions, transaction objects exposes the same database operation methods as the related <code>engine</code> object but execute each operation in a transactional context.</p> <p>In order to terminate a transaction you must either call the <code>commit</code> method to persist all the changes or call the <code>abort</code> method to drop the changes introduced in the transaction.</p> AsyncSync <pre><code>from odmantic import AIOEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = AIOEngine()\n\nasync with engine.transaction() as transaction:\n    await transaction.save(Player(name=\"Leeroy Jenkins\", game=\"WoW\"))\n    await transaction.commit()\n\nprint(engine.count(Player))\n#&gt; 1\n\nasync with engine.transaction() as transaction:\n    await transaction.save(Player(name=\"Shroud\", game=\"Counter-Strike\"))\n    await transaction.save(Player(name=\"Serral\", game=\"Starcraft\"))\n    await transaction.abort()\n\nprint(engine.count(Player))\n#&gt; 1\n</code></pre> <pre><code>from odmantic import Model, SyncEngine\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = SyncEngine()\n\nwith engine.transaction() as transaction:\n    transaction.save(Player(name=\"Leeroy Jenkins\", game=\"WoW\"))\n    transaction.commit()\n\nprint(engine.count(Player))\n#&gt; 1\n\nwith engine.transaction() as transaction:\n    transaction.save(Player(name=\"Shroud\", game=\"Counter-Strike\"))\n    transaction.save(Player(name=\"Serral\", game=\"Starcraft\"))\n    transaction.abort()\n\nprint(engine.count(Player))\n#&gt; 1\n</code></pre> <p>It is also possible to create a transaction within an existing session by using the <code>session.transaction</code> method:</p> AsyncSync <pre><code>from odmantic import AIOEngine, Model\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = AIOEngine()\n\nasync with engine.session() as session:\n    leeroy = await session.save(Player(name=\"Leeroy Jenkins\", game=\"WoW\"))\n    shroud = await session.save(Player(name=\"Shroud\", game=\"Counter-Strike\"))\n    async with session.transaction() as transaction:\n        leeroy.game = \"Fortnite\"\n        await transaction.save(leeroy)\n        shroud.game = \"Fortnite\"\n        await transaction.save(shroud)\n        await transaction.commit()\n\nprint(await engine.count(Player, Player.game == \"Fortnite\"))\n#&gt; 2\n</code></pre> <pre><code>from odmantic import Model, SyncEngine\n\n\nclass Player(Model):\n    name: str\n    game: str\n\n\nengine = SyncEngine()\n\nwith engine.session() as session:\n    leeroy = session.save(Player(name=\"Leeroy Jenkins\", game=\"WoW\"))\n    shroud = session.save(Player(name=\"Shroud\", game=\"Counter-Strike\"))\n    with session.transaction() as transaction:\n        leeroy.game = \"Fortnite\"\n        transaction.save(leeroy)\n        shroud.game = \"Fortnite\"\n        transaction.save(shroud)\n        transaction.commit()\n\nprint(engine.count(Player, Player.game == \"Fortnite\"))\n#&gt; 2\n</code></pre>"},{"location":"fields/","title":"Fields","text":""},{"location":"fields/#the-id-field","title":"The <code>id</code> field","text":"<p>The <code>ObjectId</code> data type  is the default primary key type used by MongoDB. An <code>ObjectId</code> comes with many  information embedded into it (timestamp, machine identifier, ...). Since by default,  MongoDB will create a field <code>_id</code> containing an <code>ObjectId</code> primary key, ODMantic will  bind it automatically to an implicit field named <code>id</code>.</p> <pre><code>from odmantic import Model\n\n\nclass Player(Model):\n    name: str\n\n\nleeroy = Player(name=\"Leeroy Jenkins\")\nprint(leeroy.id)\n#&gt; ObjectId('5ed50fcad11d1975aa3d7a28')\nprint(repr(leeroy))\n#&gt; Player(id=ObjectId('5ed50fcad11d1975aa3d7a28'), name=\"Leeroy Jenkins\")\n</code></pre> <p>ObjectId creation</p> <p>This <code>id</code> field will be generated on instance creation, before saving the instance to the database. This helps to keep consistency between the instances persisted to the database and the ones only created locally.</p> <p>Even if this behavior is convenient, it is still possible to define custom primary keys.</p>"},{"location":"fields/#field-types","title":"Field types","text":""},{"location":"fields/#optional-fields","title":"Optional fields","text":"<p>By default, every single field will be required. To specify a field as non-required, the easiest way is to use the <code>typing.Optional</code> generic type that will allow the field to take the <code>None</code> value as well (it will be stored as <code>null</code> in the database) and to give it a default value of <code>None</code>.</p> <pre><code>from typing import Optional\n\nfrom odmantic import Model\n\n\nclass Person(Model):\n    name: str\n    age: Optional[int] = None\n\njohn = Person(name=\"John\")\nprint(john.age)\n#&gt; None\n</code></pre>"},{"location":"fields/#union-fields","title":"Union fields","text":"<p>As explained in the Python Typing documentation, <code>Optional[X]</code> is equivalent to <code>Union[X, None]</code>. That implies that the field type will be either <code>X</code> or <code>None</code>.</p> <p>It's possible to combine any kind of type using the <code>typ\u00eeng.Union</code> type constructor. For example if we want to allow both <code>string</code> and <code>int</code> in a field:</p> <pre><code>from typing import Union\n\nfrom odmantic import Model\n\n\nclass Thing(Model):\n    ref_id: Union[int, str]\n\n\nthing_1 = Thing(ref_id=42)\nprint(thing_1.ref_id)\n#&gt; 42\n\nthing_2 = Thing(ref_id=\"i am a string\")\nprint(thing_2.ref_id)\n#&gt; i am a string\n</code></pre> <p>NoneType</p> <p>Internally python describes the type of the <code>None</code> object as <code>NoneType</code> but in practice, <code>None</code> is used directly in type annotations (more details).</p>"},{"location":"fields/#enum-fields","title":"Enum fields","text":"<p>To define choices, it's possible to use the standard <code>enum</code> classes:</p> <pre><code>from enum import Enum\n\nfrom odmantic import AIOEngine, Model\n\n\nclass TreeKind(str, Enum):\n    BIG = \"big\"\n    SMALL = \"small\"\n\n\nclass Tree(Model):\n    name: str\n    kind: TreeKind\n\n\nsequoia = Tree(name=\"Sequoia\", kind=TreeKind.BIG)\nprint(sequoia.kind)\n#&gt; TreeKind.BIG\nprint(sequoia.kind == \"big\")\n#&gt; True\n\nspruce = Tree(name=\"Spruce\", kind=\"small\")\nprint(spruce.kind)\n#&gt; TreeKind.SMALL\nprint(spruce.kind == TreeKind.SMALL)\n#&gt; True\n\nengine = AIOEngine()\nawait engine.save_all([sequoia, spruce])\n</code></pre> <p>Resulting documents in the collection <code>tree</code> after execution</p> <pre><code>{ \"_id\" : ObjectId(\"5f818f2dd5708527282c49b6\"), \"kind\" : \"big\", \"name\" : \"Sequoia\" }\n{ \"_id\" : ObjectId(\"5f818f2dd5708527282c49b7\"), \"kind\" : \"small\", \"name\" : \"Spruce\" }\n</code></pre> <p>If you try to use a value not present in the allowed choices, a ValidationError exception will be raised.</p> <p>Usage of <code>enum.auto</code></p> <p>If you might add some values to an <code>Enum</code>, it's strongly recommended not to use the <code>enum.auto</code> value generator. Depending on the order you add choices, it could completely break the consistency with documents stored in the database.</p> Unwanted behavior example <pre><code>from enum import Enum, auto\n\n\nclass Color(Enum):\n    RED = auto()\n    BLUE = auto()\n\n\nprint(Color.RED.value)\n#&gt; 1\nprint(Color.BLUE.value)\n#&gt; 2\n</code></pre> <pre><code>from enum import Enum, auto\n\n\nclass Color(Enum):\n    RED = auto()\n    GREEN = auto()\n    BLUE = auto()\n\n\nprint(Color.RED.value)\n#&gt; 1\nprint(Color.GREEN.value)\n#&gt; 2\nprint(Color.BLUE.value)\n#&gt; 3\n</code></pre>"},{"location":"fields/#container-fields","title":"Container fields","text":""},{"location":"fields/#list","title":"List","text":"<pre><code>from typing import List, Union\n\nfrom odmantic import Model\n\n\nclass SimpleListModel(Model):\n    field: list\n\n\nprint(SimpleListModel(field=[1, \"a\", True]).field)\n#&gt; [1, 'a', True]\nprint(SimpleListModel(field=(1, \"a\", True)).field)\n#&gt; [1, 'a', True]\n\n\nclass IntListModel(Model):\n    field: List[int]\n\n\nprint(IntListModel(field=[1, 5]).field)\n#&gt; [1, 5]\nprint(IntListModel(field=(1, 5)).field)\n#&gt; [1, 5]\n\n\nclass IntStrListModel(Model):\n    field: List[Union[int, str]]\n\n\nprint(IntStrListModel(field=[1, \"b\"]).field)\n#&gt; [1, 'b']\nprint(IntStrListModel(field=(1, \"b\")).field)\n#&gt; [1, 'b']\n</code></pre> <p>Tip</p> <p>It's possible to define element count constraints for a list field using the Field descriptor.</p>"},{"location":"fields/#tuple","title":"Tuple","text":"<pre><code>from typing import Tuple\n\nfrom odmantic import Model\n\n\nclass SimpleTupleModel(Model):\n    field: tuple\n\n\nprint(SimpleTupleModel(field=[1, \"a\", True]).field)\n#&gt; (1, 'a', True)\nprint(SimpleTupleModel(field=(1, \"a\", True)).field)\n#&gt; (1, 'a', True)\n\n\nclass TwoIntTupleModel(Model):\n    field: Tuple[int, int]\n\n\nprint(SimpleTupleModel(field=(1, 10)).field)\n#&gt; (1, 10)\nprint(SimpleTupleModel(field=[1, 10]).field)\n#&gt; (1, 10)\n\n\nclass IntTupleModel(Model):\n    field: Tuple[int, ...]\n\n\nprint(IntTupleModel(field=(1,)).field)\n#&gt; (1,)\nprint(IntTupleModel(field=[1, 2, 3, 10]).field)\n#&gt; (1, 2, 3, 10)\n</code></pre>"},{"location":"fields/#dict","title":"Dict","text":"<p>Tip</p> <p>For mapping types with already known keys, you can see the embedded models section.</p> <pre><code>from typing import Dict, Union\n\nfrom odmantic import Model\n\n\nclass SimpleDictModel(Model):\n    field: dict\n\n\nprint(SimpleDictModel(field={18: \"a string\", True: 42, 18.3: [1, 2, 3]}).field)\n#&gt; {18: 'a string', True: 42, 18.3: [1, 2, 3]}\n\n\nclass IntStrDictModel(Model):\n    field: Dict[int, str]\n\n\nprint(IntStrDictModel(field={1: \"one\", 2: \"two\"}).field)\n#&gt; {1: 'one', 2: 'two'}\n\n\nclass IntBoolStrDictModel(Model):\n    field: Dict[int, Union[bool, str]]\n\n\nprint(IntBoolStrDictModel(field={0: False, 1: True, 3: \"three\"}).field)\n#&gt; {0: False, 1: True, 3: 'three'}\n</code></pre> <p>Performance tip</p> <p>Whenever possible, try to avoid mutable container types (<code>List</code>, <code>Set</code>, ...) and prefer their Immutable alternatives (<code>Tuple</code>, <code>FrozenSet</code>, ...). This will allow ODMantic to speedup database writes by only saving the modified container fields.</p>"},{"location":"fields/#bson-types-integration","title":"<code>BSON</code> types integration","text":"<p>ODMantic supports native python BSON types (<code>bson</code> package). Those types can be used directly as field types:</p> <ul> <li> <p><code>bson.ObjectId</code></p> </li> <li> <p><code>bson.Int64</code></p> </li> <li> <p><code>bson.Decimal128</code></p> </li> <li> <p><code>bson.Regex</code></p> </li> <li> <p><code>bson.Binary</code></p> </li> </ul> Generic python to BSON type map Python type BSON type Comment <code>bson.ObjectId</code> <code>objectId</code> <code>bool</code> <code>bool</code> <code>int</code> <code>int</code> value between -2^31 and 2^31 - 1 <code>int</code> <code>long</code> value not between -2^31 and 2^31 - 1 <code>bson.Int64</code> <code>long</code> <code>float</code> <code>double</code> <code>bson.Decimal128</code> <code>decimal</code> <code>decimal.Decimal</code> <code>decimal</code> <code>str</code> <code>string</code> <code>typing.Pattern</code> <code>regex</code> <code>bson.Regex</code> <code>regex</code> <code>bytes</code> <code>binData</code> <code>bson.Binary</code> <code>binData</code> <code>datetime.datetime</code> <code>date</code> microseconds are truncated, only naive datetimes are allowed <code>typing.Dict</code> <code>object</code> <code>typing.List</code> <code>array</code> <code>typing.Sequence</code> <code>array</code> <code>typing.Tuple[T, ...]</code> <code>array</code>"},{"location":"fields/#pydantic-fields","title":"Pydantic fields","text":"<p>Most of the types supported by pydantic are supported by ODMantic. See pydantic: Field Types for more field types.</p> <p>Unsupported fields:</p> <ul> <li><code>typing.Callable</code></li> </ul> <p>Fields with a specific behavior:</p> <ul> <li><code>datetime.datetime</code>: Only naive datetime   objects   will be allowed as MongoDB doesn't store the timezone information. Also, the   microsecond information will be truncated.</li> </ul>"},{"location":"fields/#customization","title":"Customization","text":"<p>The field customization can mainly be performed using the Field descriptor. This descriptor is here to define everything about the field except its type.</p>"},{"location":"fields/#default-values","title":"Default values","text":"<p>The easiest way to set a default value to a field is by assigning this default value directly while defining the model.</p> <pre><code>from odmantic import Model\n\n\nclass Player(Model):\n    name: str\n    level: int = 0\n\n\np = Player(name=\"Dash\")\nprint(repr(p))\n#&gt; Player(id=ObjectId('5f7cd4be16af832772f1615e'), name='Dash', level=0)\n</code></pre> <p>You can combine default values and an existing Field descriptor using the <code>default</code> keyword argument.</p> <pre><code>from odmantic import Field, Model\n\n\nclass Player(Model):\n    name: str\n    level: int = Field(default=1, ge=1)\n\n\np = Player(name=\"Dash\")\nprint(repr(p))\n#&gt; Player(id=ObjectId('5f7cdbfbb54a94e9e8717c77'), name='Dash', level=1)\n</code></pre> <p>Default factory</p> <p>You may as well define a factory function instead of a value using the <code>default_factory</code> argument of the Field descriptor.</p> <p>By default, the default factories won't be used while parsing MongoDB documents. It's possible to enable this behavior with the <code>parse_doc_with_default_factories</code> Config option.</p> <p>Default values validation</p> <p>Currently the default values are not validated yet during the model creation.</p> <p>An inconsistent default value might raise a ValidationError while building an instance.</p>"},{"location":"fields/#document-structure","title":"Document structure","text":"<p>By default, the MongoDB documents fields will be named after the field name. It is possible to override this naming policy by using the <code>key_name</code> argument in the Field descriptor.</p> AsyncSync <pre><code>from odmantic import AIOEngine, Field, Model\n\n\nclass Player(Model):\n    name: str = Field(key_name=\"username\")\n\n\nengine = AIOEngine()\nawait engine.save(Player(name=\"Jack\"))\n</code></pre> <pre><code>from odmantic import SyncEngine, Field, Model\n\n\nclass Player(Model):\n    name: str = Field(key_name=\"username\")\n\n\nengine = SyncEngine()\nengine.save(Player(name=\"Jack\"))\n</code></pre> <p>Resulting documents in the collection <code>player</code> after execution</p> <p><pre><code>{\n  \"_id\": ObjectId(\"5ed50fcad11d1975aa3d7a28\"),\n  \"username\": \"Jack\",\n}\n</code></pre> See this section for more details about the <code>_id</code> field that has been added.</p>"},{"location":"fields/#primary-key","title":"Primary key","text":"<p>While ODMantic will by default populate the <code>id</code> field as a primary key, you can use any other field as the primary key.</p> AsyncSync <pre><code>from odmantic import AIOEngine, Field, Model\n\n\nclass Player(Model):\n    name: str = Field(primary_field=True)\n\n\nleeroy = Player(name=\"Leeroy Jenkins\")\nprint(repr(leeroy))\n#&gt; Player(name=\"Leeroy Jenkins\")\n\nengine = AIOEngine()\nawait engine.save(leeroy)\n</code></pre> <pre><code>from odmantic import SyncEngine, Field, Model\n\n\nclass Player(Model):\n    name: str = Field(primary_field=True)\n\n\nleeroy = Player(name=\"Leeroy Jenkins\")\nprint(repr(leeroy))\n#&gt; Player(name=\"Leeroy Jenkins\")\n\nengine = SyncEngine()\nengine.save(leeroy)\n</code></pre> <p>Resulting documents in the collection <code>player</code> after execution</p> <pre><code>{\n    \"_id\": \"Leeroy Jenkins\"\n}\n</code></pre> <p>Info</p> <p>The Mongo name of the primary field will be enforced to <code>_id</code> and you will not be able to change it.</p> <p>Warning</p> <p>Using mutable types (Set, List, ...) as primary field might result in inconsistent behaviors.</p>"},{"location":"fields/#indexed-fields","title":"Indexed fields","text":"<p>You can define an index on a single field by using the <code>index</code> argument of the Field descriptor.</p> <p>More details about index creation can be found in the Indexes section.</p> AsyncSync <pre><code>from odmantic import AIOEngine, Field, Model\n\n\nclass Player(Model):\n    name: str\n    score: int = Field(index=True)\n\n\nengine = AIOEngine()\nawait engine.configure_database([Player])\n</code></pre> <pre><code>from odmantic import Field, Model, SyncEngine\n\n\nclass Player(Model):\n    name: str\n    score: int = Field(index=True)\n\n\nengine = SyncEngine()\nengine.configure_database([Player])\n</code></pre> <p>Warning</p> <p>When using indexes, make sure to call the <code>configure_database</code> method (AIOEngine.configure_database or SyncEngine.configure_database) to persist the indexes to the database.</p>"},{"location":"fields/#unique-fields","title":"Unique fields","text":"<p>In the same way, you can define unique constrains on a single field by using the <code>unique</code> argument of the Field descriptor. This will ensure that values of this fields are unique among all the instances saved in the database.</p> <p>More details about unique index creation can be found in the Indexes section.</p> AsyncSync <pre><code>from odmantic import AIOEngine, Field, Model\n\n\nclass Player(Model):\n    name: str = Field(unique=True)\n\n\nengine = AIOEngine()\nawait engine.configure_database([Player])\n\nleeroy = Player(name=\"Leeroy\")\nawait engine.save(leeroy)\n\nanother_leeroy = Player(name=\"Leeroy\")\nawait engine.save(another_leeroy)\n#&gt; Raises odmantic.exceptions.DuplicateKeyError:\n#&gt;    Duplicate key error for: Player.\n#&gt;    Instance: id=ObjectId('6314b4c25a19444bfe0c0be5') name='Leeroy'\n</code></pre> <pre><code>from odmantic import Field, Model, SyncEngine\n\n\nclass Player(Model):\n    name: str = Field(unique=True)\n\n\nengine = SyncEngine()\nengine.configure_database([Player])\n\nleeroy = Player(name=\"Leeroy\")\nengine.save(leeroy)\n\nanother_leeroy = Player(name=\"Leeroy\")\nengine.save(another_leeroy)\n#&gt; Raises odmantic.exceptions.DuplicateKeyError:\n#&gt;    Duplicate key error for: Player.\n#&gt;    Instance: id=ObjectId('6314b4c25a19444bfe0c0be5') name='Leeroy'\n</code></pre> <p>Warning</p> <p>When using indexes, make sure to call the <code>configure_database</code> method (AIOEngine.configure_database or SyncEngine.configure_database) to persist the indexes to the database.</p>"},{"location":"fields/#validation","title":"Validation","text":"<p>As ODMantic strongly relies on pydantic when it comes to data validation, most of the validation features provided by pydantic are available:</p> <ul> <li> <p>Add field validation constraints by using the Field descriptor <pre><code>from typing import List\n\nfrom odmantic import Field, Model\n\n\nclass ExampleModel(Model):\n    small_int: int = Field(le=10)\n    big_int: int = Field(gt=1000)\n    even_int: int = Field(multiple_of=2)\n\n    small_float: float = Field(lt=10)\n    big_float: float = Field(ge=1e10)\n\n    short_string: str = Field(max_length=10)\n    long_string: str = Field(min_length=100)\n    string_starting_with_the: str = Field(regex=r\"^The\")\n\n    short_str_list: List[str] = Field(max_items=5)\n    long_str_list: List[str] = Field(min_items=15)\n</code></pre></p> </li> <li> <p>Use strict types to prevent to coercion from compatible types (pydantic: Strict Types)   <pre><code>from pydantic import StrictBool, StrictFloat, StrictStr\n\nfrom odmantic import Model\n\n\nclass ExampleModel(Model):\n    strict_bool: StrictBool\n    strict_float: StrictFloat\n    strict_str: StrictStr\n</code></pre></p> </li> <li> <p>Define custom field validators (pydantic:   Validators)   <pre><code>from typing import ClassVar\n\nfrom pydantic import ValidationError, validator\n\nfrom odmantic import Model\n\n\nclass SmallRectangle(Model):\n    MAX_SIDE_SIZE: ClassVar[float] = 10\n\n    length: float\n    width: float\n\n    @validator(\"width\", \"length\")\n    def check_small_sides(cls, v):\n        if v &gt; cls.MAX_SIDE_SIZE:\n            raise ValueError(f\"side is greater than {cls.MAX_SIDE_SIZE}\")\n        return v\n\n    @validator(\"width\")\n    def check_width_length(cls, width, values, **kwargs):\n        length = values.get(\"length\")\n        if length is not None and width &gt; length:\n            raise ValueError(\"width can't be greater than length\")\n        return width\n\n\nprint(SmallRectangle(length=2, width=1))\n#&gt; id=ObjectId('5f81e3c073103f509f97e374'), length=2.0, width=1.0\n\ntry:\n    SmallRectangle(length=2)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for SmallRectangle\n    width\n      field required (type=value_error.missing)\n    \"\"\"\n\ntry:\n    SmallRectangle(length=2, width=3)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for SmallRectangle\n    width\n      width can't be greater than length (type=value_error)\n    \"\"\"\n\ntry:\n    SmallRectangle(length=40, width=3)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for SmallRectangle\n    length\n      side is greater than 10 (type=value_error)\n    \"\"\"\n</code></pre></p> </li> <li> <p>Define custom model validators: more details</p> </li> </ul>"},{"location":"fields/#custom-field-types","title":"Custom field types","text":"<p>Exactly in the same way pydantic allows it, it's possible to define custom field types as well with ODMantic (Pydantic: Custom data types).</p> <p>Sometimes, it might be required to customize as well the field BSON serialization. In order to do this, the field class will have to implement the <code>__bson__</code> class method.</p> <pre><code>from typing import Annotated\nfrom odmantic import AIOEngine, Model, WithBsonSerializer\n\nclass ASCIISerializedAsBinaryBase(str):\n    @classmethod\n    def __get_validators__(cls):\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, v):\n        if isinstance(v, bytes):  # Handle data coming from MongoDB\n            return v.decode(\"ascii\")\n        if not isinstance(v, str):\n            raise TypeError(\"string required\")\n        if not v.isascii():\n            raise ValueError(\"Only ascii characters are allowed\")\n        return v\n\n\ndef serialize_ascii_to_bytes(v: ASCIISerializedAsBinaryBase) -&gt; bytes:\n    # We can encode this string as ascii since it contains\n    # only ascii characters\n    bytes_ = v.encode(\"ascii\")\n    return bytes_\n\n\nASCIISerializedAsBinary = Annotated[\n    ASCIISerializedAsBinaryBase, WithBsonSerializer(serialize_ascii_to_bytes)\n]\n\nclass Example(Model):\n    field: ASCIISerializedAsBinary\n\nengine = AIOEngine()\nawait engine.save(Example(field=\"hello world\"))\nfetched = await engine.find_one(Example)\nprint(fetched.field)\n#&gt; hello world\n</code></pre> <p>In this example, we decide to store string data manually encoded in the ASCII encoding. The encoding is handled in the <code>__bson__</code> class method. On top of this, we handle the decoding by attempting to decode <code>bytes</code> object in the <code>validate</code> method.</p> <p>Resulting documents in the collection <code>example</code> after execution</p> <pre><code>{\n  \"_id\" : ObjectId(\"5f81fa5e8adaf4bf33f05035\"),\n  \"field\" : BinData(0,\"aGVsbG8gd29ybGQ=\")\n}\n</code></pre> <p>Warning</p> <p>When using custom bson serialization, it's important to handle as well the data validation for data retrieved from Mongo. In the previous example it's done by handling <code>bytes</code> objects in the validate method.</p>"},{"location":"migration_guide/","title":"Migration Guide","text":""},{"location":"migration_guide/#migrating-to-v1","title":"Migrating to v1","text":"<p>Before migrating ODMantic, have a look at the Pydantic v2 migration guide.</p>"},{"location":"migration_guide/#upgrading-to-odmantic-v1","title":"Upgrading to ODMantic v1","text":"<pre><code>pip install -U pydantic\n</code></pre>"},{"location":"migration_guide/#handling-optional-with-non-implicit-default-none-values","title":"Handling <code>Optional</code> with non-implicit default <code>None</code> values","text":"<p>Since this new version, the default value of an <code>Optional</code> field is not implicit anymore. Thus, if you want to keep the same behavior, you have to add the <code>default</code> parameter to your <code>Optional</code> fields.</p> <p>Before:</p> <pre><code>class MyModel(Model):\n    my_field: Optional[str]\n\nassert MyModel().my_field is None\n</code></pre> <p>Now:</p> <pre><code>class MyModel(Model):\n    my_field: Optional[str] = None\n\nassert MyModel().my_field is None\n</code></pre>"},{"location":"migration_guide/#upgrading-models-configuration","title":"Upgrading models configuration","text":"<p>Instead of the old <code>Config</code> class, you have to use the new <code>model_config</code> typed dict.</p> <p>Before:</p> <pre><code>class Event(Model):\n    date: datetime\n\n    class Config:\n        collection = \"event_collection\"\n        parse_doc_with_default_factories = True\n        indexes = [\n            Index(Event.date, unique=True),\n            pymongo.IndexModel([(\"date\", pymongo.DESCENDING)]),\n        ]\n</code></pre> <p>Now: <pre><code>class Event(Model):\n    date: datetime\n\n    model_config = {\n        \"collection\": \"event_collection\",\n        \"parse_doc_with_default_factories\": True,\n        \"indexes\": lambda: [\n            Index(Event.date, unique=True),\n            pymongo.IndexModel([(\"date\", pymongo.DESCENDING)]),\n        ],\n    }\n</code></pre></p>"},{"location":"migration_guide/#defining-custom-bson-serializers","title":"Defining custom BSON serializers","text":"<p>Instead of using the <code>__bson__</code> class method, you have to use the new WithBsonSerializer annotation.</p> <p>Note</p> <p>We will probably bring back the <code>__bson__</code> class method in a future version but using the new annotation is the recommended way to define custom BSON serializers.</p> <p>Here is an example of serializing an integer as a string in BSON:</p> <p>Before:</p> <pre><code>class IntBSONStr(int):\n    @classmethod\n    def __bson__(cls, v) -&gt; str:\n        return str(v)\n</code></pre> <p>Now:</p> <pre><code>from typing import Annotated\nfrom odmantic import WithBsonSerializer\n\nIntBSONStr = Annotated[int, WithBsonSerializer(lambda v: str(v))]\n</code></pre>"},{"location":"migration_guide/#building-a-pydantic-model-from-an-odmantic-model","title":"Building a Pydantic model from an ODMantic model","text":"<p>If you want to build a Pydantic model from an ODMantic model, you now have to enable the <code>from_attributes</code> configuration option.</p> <p>For example, with a <code>UserModel</code> that is used internally and a <code>ResponseSchema</code> that could be exposed through an API:</p> <pre><code>from pydantic import BaseModel, EmailStr\nfrom odmantic import Model\n\nclass UserModel(Model):\n    email: EmailStr\n    password_hash: str\n\nclass UserSchema(BaseModel):\n    email: EmailStr\n\nclass ResponseSchema(BaseModel):\n    user: UserSchema\n\n    model_config = {\"from_attributes\": True}\n\nuser = UserModel(email=\"john@doe.com\", password_hash=\"...\")\nresponse = ResponseSchema(user=user)\n</code></pre>"},{"location":"migration_guide/#replacing-the-model-and-embeddedmodel-deprecated-methods","title":"Replacing the <code>Model</code> and <code>EmbeddedModel</code> deprecated methods","text":"<ul> <li> <p>Replace <code>Model.dict</code> with the new <code>Model.model_dump</code> method</p> </li> <li> <p>Replace <code>Model.doc</code> with the new <code>Model.model_dump_doc</code> method</p> </li> <li> <p>Replace <code>Model.parse_doc</code> with the new <code>Model.model_validate_doc</code> method</p> </li> <li> <p>Replace <code>Model.update</code> with the new <code>Model.model_update</code> method</p> </li> <li> <p>Replace <code>Model.copy</code> with the new <code>Model.model_copy</code> method</p> </li> </ul>"},{"location":"migration_guide/#custom-json-encoders-on-odmanticbson-types","title":"Custom JSON encoders on <code>odmantic.bson</code> types","text":"<p>Custom JSON encoders (defined with the <code>json_encoders</code> config option) are no longer effective on <code>odmantic.bson</code> types since the builtin encoders cannot be overridden in that way anymore.</p> <p>The solution is to use the PlainSerializer annotation provided by Pydantic. For example, if we want to serialize ObjectId as a <code>id_</code> prefixed string:</p> <pre><code>from typing import Annotated\nfrom pydantic import BaseModel, PlainSerializer\nfrom odmantic import ObjectId\n\nMyObjectId = Annotated[ObjectId, PlainSerializer(lambda v: \"id_\" + str(v))]\n\nclass MyModel(BaseModel):\n    id: MyObjectId\n\ninstance = MyModel(id=ObjectId(\"ffffffffffffffffffffffff\"))\nprint(instance.model_dump_json())\n#&gt; {\"id\": \"id_ffffffffffffffffffffffff\"}\n</code></pre> <p>And ... that's it, congrats! \ud83d\ude80\u2692\ufe0f</p> <p>If you have any questions or if you need help to migrate something that is not covered by this guide, feel free to open an issue on GitHub.</p>"},{"location":"modeling/","title":"Modeling","text":""},{"location":"modeling/#models","title":"Models","text":"<p>To create a Model, simply inherit from the Model class and then specify the field types and eventually their descriptors.</p>"},{"location":"modeling/#collection","title":"Collection","text":"<p>Each Model will be linked to its own collection. By default, the collection name will be created from the chosen class name and converted to snake_case. For example a model class named <code>CapitalCity</code> will be stored in the collection named <code>capital_city</code>.</p> <p>If the class name ends with <code>Model</code>, ODMantic will remove it to create the collection name. For example, a model class named <code>PersonModel</code> will belong in the <code>person</code> collection.</p> <p>It's possible to customize the collection name of a model by specifying the <code>collection</code> option in the <code>model_config</code> class attribute.</p> <p>Custom collection name example</p> <p><pre><code>from odmantic import Model\n\nclass CapitalCity(Model):\n    name: str\n    population: int\n\n    model_config = {\n        \"collection\": \"city\"\n    }\n</code></pre> Now, when <code>CapitalCity</code> instances will be persisted to the database, they will belong in the <code>city</code> collection instead of <code>capital_city</code>.</p> <p>Warning</p> <p>Models and Embedded models inheritance is not supported yet.</p>"},{"location":"modeling/#indexes","title":"Indexes","text":""},{"location":"modeling/#index-definition","title":"Index definition","text":"<p>There are two ways to create indexes on a model in ODMantic. The first one is to use the Field descriptors as explained in Indexed fields or Unique fields. However, this way doesn't allow a great flexibility on index definition.</p> <p>That's why you can also use the <code>model_config.indexes</code> generator to specify advanced indexes (compound indexes, custom names). This static function defined in the <code>model_config</code> class attribute should yield odmantic.Index.</p> <p>For example:</p> <pre><code>from odmantic import Field, Index, Model\n\n\nclass Product(Model):\n    name: str = Field(index=True)\n    stock: int\n    category: str\n    sku: str = Field(unique=True)\n\n    model_config = {\n        \"indexes\": lambda: [\n            Index(Product.name, Product.stock, name=\"name_stock_index\"),\n            Index(Product.name, Product.category, unique=True),\n        ]\n    }\n</code></pre> <p>This snippet creates 4 indexes on the <code>Product</code> model:</p> <ul> <li> <p>An index on the <code>name</code> field defined with   the field descriptor, improving lookup performance by   product name.</p> </li> <li> <p>A unique index on the <code>sku</code> field defined with   the field descriptor, enforcing uniqueness of the <code>sku</code>   field.</p> </li> <li> <p>A compound index on the <code>name</code> and <code>stock</code> fields, making sure the following query   will be efficient (i.e. avoid a full collection scan):</p> <pre><code>engine.find(Product, Product.name == \"banana\", Product.stock &gt; 5)\n</code></pre> </li> <li> <p>A unique index on the <code>name</code> and <code>category</code> fields, making sure each category has   unique product name.</p> </li> </ul> <p>Sort orders with index definition</p> <p>You can also specify the sort order of the fields in the index definition using query.asc and query.desc as presented in the Sorting section.</p> <p>For example defining the following index on the <code>Event</code> model: <pre><code>from datetime import datetime\n\nfrom odmantic import Index, Model\nfrom odmantic.query import asc, desc\n\n\nclass Event(Model):\n    username: str\n    date: datetime\n\n    model_config = {\"indexes\": lambda: [Index(asc(Event.username), desc(Event.date))]}\n</code></pre></p> <p>Will greatly improve the performance of the query: <pre><code>engine.find(Event, sort=(asc(Event.name), desc(Event.date))\n</code></pre></p>"},{"location":"modeling/#index-creation","title":"Index creation","text":"<p>In order to create and enable the indexes in the database, you need to call the <code>engine.configure_database</code> method (either AIOEngine.configure_database or SyncEngine.configure_database).</p> AsyncSync <pre><code># ... Continuation of the previous snippet ...\n\nfrom odmantic import AIOEngine\n\nengine = AIOEngine()\nawait engine.configure_database([Product])\n</code></pre> <pre><code># ... Continuation of the previous snippet ...\n\nfrom odmantic import SyncEngine\n\nengine = SyncEngine()\nengine.configure_database([Product])\n</code></pre> <p>This method can also take a <code>update_existing_indexes=True</code> parameter to update existing indexes when the index definition changes. If not enabled, an exception will be thrown when a conflicting index update happens.</p>"},{"location":"modeling/#advanced-indexes","title":"Advanced indexes","text":"<p>In some cases, you might need a greater flexibility on the index definition (Geo2D, Hashed, Text indexes for example), the <code>Config.indexes</code> generator can also yield pymongo.IndexModel objects.</p> <p>For example, defining a text index :</p> <pre><code>import pymongo\n\nfrom odmantic import Model\n\n\nclass Post(Model):\n    title: str\n    content: str\n\n    model_config = {\n        \"indexes\": lambda: [\n            pymongo.IndexModel(\n                [(+Post.title, pymongo.TEXT), (+Post.content, pymongo.TEXT)]\n            )\n        ]\n    }\n</code></pre>"},{"location":"modeling/#custom-model-validators","title":"Custom model validators","text":"<p>Exactly as done with pydantic, it's possible to define custom model validators as described in the pydantic: Root Validators documentation (this apply as well to Embedded Models).</p> <p>In the following example, we will define a rectangle class and add two validators: The first one will check that the height is greater than the width. The second one will ensure that the area of the rectangle is less or equal to 9.</p> <pre><code>from typing import ClassVar\n\nfrom pydantic import ValidationError, model_validator\n\nfrom odmantic import Model\n\n\nclass SmallRectangle(Model):\n    MAX_AREA: ClassVar[float] = 9\n\n    length: float\n    width: float\n\n    @model_validator(mode=\"before\")\n    def check_width_length(cls, values):\n        length = values.get(\"length\", 0)\n        width = values.get(\"width\", 0)\n        if width &gt; length:\n            raise ValueError(\"width can't be greater than length\")\n        return values\n\n    @model_validator(mode=\"before\")\n    def check_area(cls, values):\n        length = values.get(\"length\", 0)\n        width = values.get(\"width\", 0)\n        if length * width &gt; cls.MAX_AREA:\n            raise ValueError(f\"area is greater than {cls.MAX_AREA}\")\n        return values\n\n\nprint(SmallRectangle(length=2, width=1))\n# &gt; id=ObjectId('5f81e3c073103f509f97e374'), length=2.0, width=1.0\n\ntry:\n    SmallRectangle(length=2)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for SmallRectangle\n    width\n      field required (type=value_error.missing)\n    \"\"\"\n\ntry:\n    SmallRectangle(length=2, width=3)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for SmallRectangle\n      Value error, width can't be greater than length\n    \"\"\"\n\ntry:\n    SmallRectangle(length=4, width=3)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for SmallRectangle\n    __root__\n      Value error, area is greater than 9\n    \"\"\"\n</code></pre> <p>Tip</p> <p>You can define class variables in the Models using the <code>typing.ClassVar</code> type construct, as done in this example with <code>MAX_AREA</code>. Those class variables will be completely ignored by ODMantic while persisting instances in the database.</p>"},{"location":"modeling/#advanced-configuration","title":"Advanced Configuration","text":"<p>The model configuration is done in the same way as with Pydantic models: using a ConfigDict <code>model_config</code> defined in the model body.</p> <p>Here is an example of a model configuration:</p> <pre><code>class Event(Model):\n    date: datetime\n\n    model_config = {\n        \"collection\": \"event_collection\",\n        \"parse_doc_with_default_factories\": True,\n        \"indexes\": lambda: [\n            Index(Event.date, unique=True),\n            pymongo.IndexModel([(\"date\", pymongo.DESCENDING)]),\n        ],\n    }\n</code></pre>"},{"location":"modeling/#available-options","title":"Available options","text":"<code>collection: str</code> Customize the collection name associated to the model. See this   section for more details about default collection naming. <code>parse_doc_with_default_factories: bool</code> <p>Wether to allow populating field values with default factories while parsing   documents from the database. See   Advanced parsing behavior for more   details.</p> <p>Default: <code>False</code></p> <code>indexes: Callable[[],Iterable[Union[Index, pymongo.IndexModel]]]</code> <p>Define additional indexes for the model. See Indexes for   more details.</p> <p>Default: <code>lambda: []</code></p> <code>title: str</code> (inherited from Pydantic) <p>Title inferred in the JSON schema.</p> <p>Default: name of the model class</p> <code>schema_extra: dict</code> (inherited from Pydantic) <p>A dict used to extend/update the generated JSON Schema, or a callable to   post-process it. See Pydantic: Schema customization for more details.</p> <p>Default: <code>{}</code></p> <code>anystr_strip_whitespace: bool</code> (inherited from Pydantic) <p>Whether to strip leading and trailing whitespaces for str &amp; byte types.</p> <p>Default: <code>False</code></p> <code>json_encoders: dict</code> (inherited from Pydantic) <p>Customize the way types used in the model are encoded to JSON.</p> <code>json_encoders</code> example <p>For example, in order to serialize <code>datetime</code> fields as timestamp values:</p> <pre><code>class Event(Model):\n    date: datetime\n\n    model_config = {\n        \"json_encoders\": {\n            datetime: lambda v: v.timestamp()\n        }\n    }\n</code></pre> <code>extra: pydantic.Extra</code> (inherited from Pydantic) <p>Whether to ignore, allow, or forbid extra attributes during model initialization. Accepts the string values of 'ignore', 'allow', or 'forbid', or values of the Extra enum. 'forbid' will cause validation to fail if extra attributes are included, 'ignore' will silently ignore any extra attributes, and 'allow' will assign the attributes to the model, reflecting them in the saved database documents and fetched instances.</p> <p>Default: <code>Extra.ignore</code></p> <p>For more details and examples about the options inherited from Pydantic, you can have a look at Pydantic: Model Config</p> <p>Warning</p> <p>Only the options described above are supported and other options from Pydantic can't be used with ODMantic.</p> <p>If you feel the need to have an additional option inherited from Pydantic, you can open an issue.</p>"},{"location":"modeling/#embedded-models","title":"Embedded Models","text":"<p>Using an embedded model will store it directly in the root model it's integrated in. On the MongoDB side, the collection will contain the root documents and in inside each of them, the embedded models will be directly stored.</p> <p>Embedded models are especially useful while building one-to-one or one-to-many relationships.</p> <p>Note</p> <p>Since Embedded Models are directly embedded in the MongoDB collection of the root model, it will not be possible to query on them directly without specifying a root document.</p> <p>The creation of an Embedded model is done by inheriting the EmbeddedModel class. You can then define fields exactly as for the regular Models.</p>"},{"location":"modeling/#one-to-one","title":"One to One","text":"<p>In this example, we will model the relation between a country and its capital city. Since one capital city can belong to one and only one country, we can model this relation as a One-to-One relationship. We will use an Embedded Model in this case.</p> <pre><code>from odmantic import AIOEngine, EmbeddedModel, Model\n\n\nclass CapitalCity(EmbeddedModel):\n    name: str\n    population: int\n\n\nclass Country(Model):\n    name: str\n    currency: str\n    capital_city: CapitalCity\n\n\ncountries = [\n    Country(\n        name=\"Switzerland\",\n        currency=\"Swiss franc\",\n        capital_city=CapitalCity(name=\"Bern\", population=1035000),\n    ),\n    Country(\n        name=\"Sweden\",\n        currency=\"Swedish krona\",\n        capital_city=CapitalCity(name=\"Stockholm\", population=975904),\n    ),\n]\n\nengine = AIOEngine()\nawait engine.save_all(countries)\n</code></pre> <p>Defining this relation is done in the same way as defining a new field. Here, the <code>CapitalCity</code> class will be considered as a field type during the model definition.</p> <p>The Field descriptor can be used as well for Embedded Models in order to bring more flexibility (default values, Mongo key name, ...).</p> Content of the <code>country</code> collection after execution <pre><code>{\n  \"_id\": ObjectId(\"5f79d7e8b305f24ca43593e2\"),\n  \"name\": \"Sweden\",\n  \"currency\": \"Swedish krona\",\n  \"capital_city\": {\n    \"name\": \"Stockholm\",\n    \"population\": 975904\n  }\n}\n{\n  \"_id\": ObjectId(\"5f79d7e8b305f24ca43593e1\"),\n  \"name\": \"Switzerland\",\n  \"currency\": \"Swiss franc\",\n  \"capital_city\": {\n    \"name\": \"Bern\",\n    \"population\": 1035000\n  }\n}\n</code></pre> <p>Tip</p> <p>It is possible as well to define query filters based on embedded documents content.</p> <pre><code>await engine.find_one(\n    Country, Country.capital_city.name == \"Stockholm\"\n)\n#&gt; Country(\n#&gt;     id=ObjectId(\"5f79d7e8b305f24ca43593e2\"),\n#&gt;     name=\"Sweden\",\n#&gt;     currency=\"Swedish krona\",\n#&gt;     capital_city=CapitalCity(name=\"Stockholm\", population=975904),\n#&gt; )\n</code></pre> <p>For more details, see the Querying section.</p>"},{"location":"modeling/#one-to-many","title":"One to Many","text":"<p>Here, we will model the relation between a customer of an online shop and his shipping addresses. A single customer can have multiple addresses but these addresses belong only to the customer's account. He should be allowed to modify them without modifying others addresses (for example if two family members use the same address, their addresses should not be linked together).</p> <pre><code>from typing import List\n\nfrom odmantic import AIOEngine, EmbeddedModel, Model\n\n\nclass Address(EmbeddedModel):\n    street: str\n    city: str\n    state: str\n    zipcode: str\n\n\nclass Customer(Model):\n    name: str\n    addresses: List[Address]\n\n\ncustomer = Customer(\n    name=\"John Doe\",\n    addresses=[\n        Address(\n            street=\"1757  Birch Street\",\n            city=\"Greenwood\",\n            state=\"Indiana\",\n            zipcode=\"46142\",\n        ),\n        Address(\n            street=\"262  Barnes Avenue\",\n            city=\"Cincinnati\",\n            state=\"Ohio\",\n            zipcode=\"45216\",\n        ),\n    ],\n)\n\nengine = AIOEngine()\nawait engine.save(customer)\n</code></pre> <p>As done previously for the One to One relation, defining a One to Many relationship with Embedded Models is done exactly as defining a field with its type being a sequence of <code>Address</code> objects.</p> Content of the <code>customer</code> collection after execution <pre><code>{\n  \"_id\": ObjectId(\"5f79eb116371e09b16e4fae4\"),\n  \"name\":\"John Doe\",\n  \"addresses\":[\n    {\n      \"street\":\"1757  Birch Street\",\n      \"city\":\"Greenwood\",\n      \"state\":\"Indiana\",\n      \"zipcode\":\"46142\"\n    },\n    {\n      \"street\":\"262  Barnes Avenue\",\n      \"city\":\"Cincinnati\",\n      \"state\":\"Ohio\",\n      \"zipcode\":\"45216\"\n    }\n  ]\n}\n</code></pre> <p>Tip</p> <p>To add conditions on the number of embedded elements, it's possible to use the <code>min_items</code> and <code>max_items</code> arguments of the Field descriptor. Another possibility is to use the <code>typing.Tuple</code> type.</p> <p>Note</p> <p>Building query filters based on the content of a sequence of embedded documents is not supported yet (but this feature is planned for an upcoming release ).</p> <p>Anyway, it's still possible to perform the filtering operation manually using Mongo Array Operators (<code>$all</code>, <code>$elemMatch</code>, <code>$size</code>). See the Raw query usage section for more details.</p>"},{"location":"modeling/#customization","title":"Customization","text":"<p>Since the Embedded Models are considered as types by ODMantic, most of the complex type constructs that could be imagined should be supported.</p> <p>Some ideas which could be useful:</p> <ul> <li> <p>Combine two different embedded models in a single field using <code>typing.Tuple</code>.</p> </li> <li> <p>Allow multiple Embedded model types using a <code>typing.Union</code> type.</p> </li> <li> <p>Make an Embedded model not required using <code>typing.Optional</code>.</p> </li> <li> <p>Embed the documents in a dictionary (using the <code>typing.Dict</code> type) to provide an   additional key-value mapping to the embedded documents.</p> </li> <li> <p>Nest embedded documents</p> </li> </ul>"},{"location":"modeling/#referenced-models","title":"Referenced models","text":"<p>Embedded models are really simple to use but sometimes it is needed as well to have many-to-one (i.e. multiple entities referring to another single one) or many-to-many relationships. This is not really possible to model those using embedded documents and in this case, references will come handy. Another use case where references are useful is for one-to-one/one-to-many relations but when the referenced model has to exist in its own collection, in order to be accessed on  its own without any parent model specified.</p>"},{"location":"modeling/#many-to-one-mapped","title":"Many to One (Mapped)","text":"<p>In this part, we will model the relation between books and publishers. Let's consider that each book has a single publisher. In this case, multiple books could be published by the same publisher. We can thus model this relation as a many-to-one relationship.</p> <pre><code>from odmantic import AIOEngine, Model, Reference\n\n\nclass Publisher(Model):\n    name: str\n    founded: int\n    location: str\n\n\nclass Book(Model):\n    title: str\n    pages: int\n    publisher: Publisher = Reference()\n\n\nhachette = Publisher(name=\"Hachette Livre\", founded=1826, location=\"FR\")\nharper = Publisher(name=\"HarperCollins\", founded=1989, location=\"US\")\n\nbooks = [\n    Book(title=\"They Didn't See Us Coming\", pages=304, publisher=hachette),\n    Book(title=\"This Isn't Happening\", pages=256, publisher=hachette),\n    Book(title=\"Prodigal Summer\", pages=464, publisher=harper),\n]\n\nengine = AIOEngine()\nawait engine.save_all(books)\n</code></pre> <p>The definition of a reference field requires the presence of the Reference() descriptor. Once the models are defined, linking two instances is done simply by assigning the reference field of the referencing instance to the referenced instance.</p> Why is it required to include the Reference descriptor ? <p>The main goal behind enforcing the presence of the descriptor is to have a clear distinction between Embedded Models and References.</p> <p>In the future, a generic <code>Reference[T]</code> type will probably be included to make this distinction since it would make more sense than having to set a descriptor for each reference.</p> Content of the <code>publisher</code> collection after execution <p><pre><code>{\n  \"_id\": ObjectId(\"5f7a0dc48a73b20f16e2a364\"),\n  \"founded\": 1826,\n  \"location\": \"FR\",\n  \"name\": \"Hachette Livre\"\n}\n{\n  \"_id\": ObjectId(\"5f7a0dc48a73b20f16e2a365\"),\n  \"founded\": 1989,\n  \"location\": \"US\",\n  \"name\": \"HarperCollins\"\n}\n</code></pre> We can see that the publishers have been persisted to their collection even if no explicit save has been performed. When calling the engine.save method, the engine will persist automatically the referenced documents.</p> <p>While fetching instances, the engine will as well resolve every reference.</p> Content of the <code>book</code> collection after execution <p><pre><code>{\n  \"_id\": ObjectId(\"5f7a0dc48a73b20f16e2a366\"),\n  \"pages\": 304,\n  \"publisher\": ObjectId(\"5f7a0dc48a73b20f16e2a364\"),\n  \"title\": \"They Didn't See Us Coming\"\n}\n{\n  \"_id\": ObjectId(\"5f7a0dc48a73b20f16e2a367\"),\n  \"pages\": 256,\n  \"publisher\": ObjectId(\"5f7a0dc48a73b20f16e2a364\"),\n  \"title\": \"This Isn't Happening\"\n}\n{\n  \"_id\": ObjectId(\"5f7a0dc48a73b20f16e2a368\"),\n  \"pages\": 464,\n  \"publisher\": ObjectId(\"5f7a0dc48a73b20f16e2a365\"),\n  \"title\": \"Prodigal Summer\"\n}\n</code></pre> The resulting books in the collection contain the publisher reference directly as a document attribute (using the reference name as the document's key).</p> <p>Tip</p> <p>It's possible to customize the foreign key storage key using the <code>key_name</code> argument while building the Reference descriptor.</p>"},{"location":"modeling/#many-to-many-manual","title":"Many to Many (Manual)","text":"<p>Here, we will model the relation between books and their authors. Since a book can have multiple authors and an author can be authoring multiple books, we will model this  relation as a many-to-many relationship.</p> <p>Note</p> <p>Currently, ODMantic does not support mapped multi-references yet. But we will still define the relationship in a manual way.</p> <pre><code>from typing import List\n\nfrom bson import ObjectId\n\nfrom odmantic import AIOEngine, Model\n\n\nclass Author(Model):\n    name: str\n\n\nclass Book(Model):\n    title: str\n    pages: int\n    author_ids: List[ObjectId]\n\n\ndavid = Author(name=\"David Beazley\")\nbrian = Author(name=\"Brian K. Jones\")\n\npython_cookbook = Book(\n    title=\"Python Cookbook\", pages=706, author_ids=[david.id, brian.id]\n)\npython_essentials = Book(\n    title=\"Python Essential Reference\", pages=717, author_ids=[brian.id]\n)\n\nengine = AIOEngine()\nawait engine.save_all((david, brian))\nawait engine.save_all((python_cookbook, python_essentials))\n</code></pre> <p>We defined an <code>author_ids</code> field which holds the list of unique ids of the authors (This <code>id</code> field in the <code>Author</code> model is generated implicitly by default).</p> <p>Since this multi-reference is not mapped by the ODM, we have to persist the authors manually.</p> Content of the <code>author</code> collection after execution <pre><code>{\n  \"_id\": ObjectId(\"5f7a37dc7311be1362e1da4e\"),\n  \"name\": \"David Beazley\"\n}\n{\n  \"_id\": ObjectId(\"5f7a37dc7311be1362e1da4f\"),\n  \"name\": \"Brian K. Jones\"\n}\n</code></pre> Content of the <code>book</code> collection after execution <pre><code>{\n  \"_id\": ObjectId(\"5f7a37dc7311be1362e1da50\"),\n  \"title\":\"Python Cookbook\"\n  \"pages\":706,\n  \"author_ids\":[\n    ObjectId(\"5f7a37dc7311be1362e1da4e\"),\n    ObjectId(\"5f7a37dc7311be1362e1da4f\")\n  ],\n}\n{\n  \"_id\": ObjectId(\"5f7a37dc7311be1362e1da51\"),\n  \"title\":\"Python Essential Reference\"\n  \"pages\":717,\n  \"author_ids\":[\n    ObjectId(\"5f7a37dc7311be1362e1da4f\")\n  ],\n}\n</code></pre> <p>Retrieving the authors of the Python Cookbook</p> <p>First, it's required to fetch the ids of the authors. Then we can use the in_ filter to select only the authors with the desired ids.</p> <pre><code>book = await engine.find_one(Book, Book.title == \"Python Cookbook\")\nauthors = await engine.find(Author, Author.id.in_(book.author_ids))\nprint(authors)\n#&gt; [\n#&gt;   Author(id=ObjectId(\"5f7a37dc7311be1362e1da4e\"), name=\"David Beazley\"),\n#&gt;   Author(id=ObjectId(\"5f7a37dc7311be1362e1da4f\"), name=\"Brian K. Jones\"),\n#&gt; ]\n</code></pre>"},{"location":"querying/","title":"Querying","text":""},{"location":"querying/#filtering","title":"Filtering","text":"<p>ODMantic uses QueryExpression objects to handle filter expressions. These expressions can be built from the comparison operators. It's then possible to combine multiple expressions using the logical operators. To support the wide variety of operators provided by MongoDB, it's possible as well to define the filter 'manually'.</p>"},{"location":"querying/#comparison-operators","title":"Comparison operators","text":"<p>There are multiple ways of building QueryExpression objects with comparisons operators:</p> <ol> <li> Using python comparison operators between the field of the model and the desired value <code>==</code>, <code>!=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&gt;</code> </li> <li> <p>Using the functions provided by the <code>odmantic.query</code> module</p> <ul> <li>query.eq</li> <li>query.ne</li> <li>query.gt</li> <li>query.gte</li> <li>query.lt</li> <li>query.lte</li> <li>query.in_</li> <li>query.not_in</li> </ul> </li> <li> <p>Using methods of the model's field and the desired value</p> <ul> <li><code>field.eq</code></li> <li><code>field.ne</code></li> <li><code>field.gte</code></li> <li><code>field.gt</code></li> <li><code>field.lte</code></li> <li><code>field.lte</code></li> <li><code>field.in_</code></li> <li><code>field.not_in</code></li> </ul> </li> </ol> <p>Type checkers</p> <p>Since there is currently not any type checker plugin, the third usage might create some errors with type checkers.</p>"},{"location":"querying/#equal","title":"Equal","text":"<p>Filter the trees named \"Spruce\": <pre><code>from odmantic import Model, query\n\n\nclass Tree(Model):\n    name: str\n    average_size: float\n\n\nTree.name == \"Spruce\"\n#&gt; QueryExpression({'name': {'$eq': 'Spruce'}})\nTree.name.eq(\"Spruce\")\n#&gt; QueryExpression({'name': {'$eq': 'Spruce'}})\nquery.eq(Tree.name, \"Spruce\")\n#&gt; QueryExpression({'name': {'$eq': 'Spruce'}})\n</code></pre> Equivalent raw MongoDB filter: <pre><code>{\"name\": \"Spruce\"}\n</code></pre></p> <p>Using equality operators with Enum fields</p> <p>Building filters using <code>Enum</code> fields is possible as well.</p> Example of filter built on an Enum field <p>Filter the 'small' trees: <pre><code>from enum import Enum\n\nfrom odmantic import Model, query\n\n\nclass TreeKind(str, Enum):\n    BIG = \"big\"\n    SMALL = \"small\"\n\n\nclass Tree(Model):\n    name: str\n    average_size: float\n    kind: TreeKind\n\n\nTree.kind == TreeKind.SMALL\n#&gt; QueryExpression({'kind': {'$eq': 'small'}})\nTree.kind.eq(TreeKind.SMALL)\n#&gt; QueryExpression({'kind': {'$eq': 'small'}})\nquery.eq(Tree.kind, TreeKind.SMALL)\n#&gt; QueryExpression({'kind': {'$eq': 'small'}})\n</code></pre> Equivalent raw MongoDB filter: <pre><code>{'kind': 'small'}\n</code></pre></p> <p>More details about Enum fields.</p>"},{"location":"querying/#not-equal","title":"Not Equal","text":"<p>Filter the trees that are not named \"Spruce\": <pre><code>from odmantic import Model, query\n\n\nclass Tree(Model):\n    name: str\n    average_size: float\n\n\nTree.name != \"Spruce\"\n#&gt; QueryExpression({'name': {'$ne': 'Spruce'}})\nTree.name.ne(\"Spruce\")\n#&gt; QueryExpression({'name': {'$ne': 'Spruce'}})\nquery.ne(Tree.name, \"Spruce\")\n#&gt; QueryExpression({'name': {'$ne': 'Spruce'}})\n</code></pre> Equivalent raw MongoDB filter: <pre><code>{\"name\": {\"$ne\": \"Spruce\"}}\n</code></pre></p>"},{"location":"querying/#less-than-or-equal-to","title":"Less than (or equal to)","text":"<p>Filter the trees that have a size that is less than (or equal to) 2: <pre><code>from odmantic import Model, query\n\n\nclass Tree(Model):\n    name: str\n    average_size: float\n\n\nTree.average_size &lt; 2\n#&gt; QueryExpression({'average_size': {'$lt': 2}})\nTree.average_size.lt(2)\n#&gt; QueryExpression({'average_size': {'$lt': 2}})\nquery.lt(Tree.average_size, 2)\n#&gt; QueryExpression({'average_size': {'$lt': 2}})\n\nTree.average_size &lt;= 2\n#&gt; QueryExpression({'average_size': {'$lte': 2}})\nTree.average_size.lte(2)\n#&gt; QueryExpression({'average_size': {'$lte': 2}})\nquery.lte(Tree.average_size, 2)\n#&gt; QueryExpression({'average_size': {'$lte': 2}})\n</code></pre> Equivalent raw MongoDB filter (less than): <pre><code>{\"average_size\": {\"$lt\": 2}}\n</code></pre> Equivalent raw MongoDB filter (less than or equal to): <pre><code>{\"average_size\": {\"$lte\": 2}}\n</code></pre></p>"},{"location":"querying/#greater-than-or-equal-to","title":"Greater than (or equal to)","text":"<p>Filter the trees having a size that is greater than (or equal to) 2: <pre><code>from odmantic import Model, query\n\n\nclass Tree(Model):\n    name: str\n    average_size: float\n\n\nTree.average_size &gt; 2\n#&gt; QueryExpression({'average_size': {'$gt': 2}})\nTree.average_size.gt(2)\n#&gt; QueryExpression({'average_size': {'$gt': 2}})\nquery.gt(Tree.average_size, 2)\n#&gt; QueryExpression({'average_size': {'$gt': 2}})\n\nTree.average_size &gt;= 2\n#&gt; QueryExpression({'average_size': {'$gte': 2}})\nTree.average_size.gte(2)\n#&gt; QueryExpression({'average_size': {'$gte': 2}})\nquery.gte(Tree.average_size, 2)\n#&gt; QueryExpression({'average_size': {'$gte': 2}})\n</code></pre> Equivalent raw MongoDB filter (greater than): <pre><code>{\"average_size\": {\"$gt\": 2}}\n</code></pre> Equivalent raw MongoDB filter (greater than or equal to): <pre><code>{\"average_size\": {\"$gte\": 2}}\n</code></pre></p>"},{"location":"querying/#included-in","title":"Included in","text":"<p>Filter the trees named either \"Spruce\" or \"Pine\": <pre><code>from odmantic import Model, query\n\n\nclass Tree(Model):\n    name: str\n    average_size: float\n\n\nTree.name.in_([\"Spruce\", \"Pine\"])\n#&gt; QueryExpression({'name': {'$in': ['Spruce', 'Pine']}})\nquery.in_(Tree.name, [\"Spruce\", \"Pine\"])\n#&gt; QueryExpression({'name': {'$in': ['Spruce', 'Pine']}})\n</code></pre> Equivalent raw MongoDB filter: <pre><code>{\"name\": {\"$in\": [\"Spruce\", \"Pine\"]}}\n</code></pre></p>"},{"location":"querying/#not-included-in","title":"Not included in","text":"<p>Filter the trees neither named \"Spruce\" nor \"Pine\": <pre><code>from odmantic import Model, query\n\n\nclass Tree(Model):\n    name: str\n    average_size: float\n\n\nTree.name.not_in([\"Spruce\", \"Pine\"])\n#&gt; QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}})\nquery.not_in(Tree.name, [\"Spruce\", \"Pine\"])\n#&gt; QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}})\n</code></pre></p> <p>Equivalent raw MongoDB filter: <pre><code>{\"name\": {\"$nin\": [\"Spruce\", \"Pine\"]}}\n</code></pre></p>"},{"location":"querying/#evaluation-operators","title":"Evaluation operators","text":""},{"location":"querying/#match-regex","title":"Match (Regex)","text":"<p>Filter the trees with a name starting with 'Spruce': <pre><code>from odmantic import Model, query\n\n\nclass Tree(Model):\n    name: str\n\n\nTree.name.match(r\"^Spruce\")\n#&gt; QueryExpression({'name': re.compile('^Spruce')})\nquery.match(Tree.name, r\"^Spruce\")\n#&gt; QueryExpression({'name': re.compile('^Spruce')})\n</code></pre></p> <p>Equivalent raw MongoDB filter: <pre><code>{\"name\": {\"$regex\": \"^Spruce\"}}\n</code></pre></p>"},{"location":"querying/#logical-operators","title":"Logical operators","text":"<p>There are two ways of combining QueryExpression objects with logical operators:</p> <ol> <li> Using python 'bitwise' operators between the field of the model and the desired value <code>&amp;</code>, <code>|</code> </li> </ol> <p>Warning</p> <p>When using those operators make sure to correctly bracket the expressions to avoid python operator precedence issues.</p> <ol> <li>Using the functions provided by the <code>odmantic.query</code> module<ul> <li>query.and_</li> <li>query.or_</li> <li>query.nor_</li> </ul> </li> </ol>"},{"location":"querying/#and","title":"And","text":"<p>Filter the trees named Spruce (AND) with a size less than 2: <pre><code>from odmantic import Model, query\n\n\nclass Tree(Model):\n    name: str\n    size: float\n\n\n(Tree.name == \"Spruce\") &amp; (Tree.size &lt;= 2)\n#&gt; QueryExpression(\n#&gt;     {\n#&gt;         \"$and\": (\n#&gt;             QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}),\n#&gt;             QueryExpression({\"size\": {\"$lte\": 2}}),\n#&gt;         )\n#&gt;     }\n#&gt; )\nquery.and_(Tree.name == \"Spruce\", Tree.size &lt;= 2)\n#&gt; ... same output ...\n</code></pre> Equivalent raw MongoDB filter: <pre><code>{\"name\": \"Spruce\", \"size\": {\"$lte\": 2}}}\n</code></pre></p> <p>Implicit AND</p> <p>When using find, find_one or count, you can specify multiple queries as positional arguments and those will be implicitly combined with the <code>AND</code> operator.</p>"},{"location":"querying/#or","title":"Or","text":"<p>Filter the trees named Spruce OR the trees with a size greater than 2:</p> <p><pre><code>from odmantic import Model, query\n\n\nclass Tree(Model):\n    name: str\n    size: float\n\n\n(Tree.name == \"Spruce\") | (Tree.size &gt; 2)\n#&gt; QueryExpression(\n#&gt;     {\n#&gt;         \"$or\": (\n#&gt;             QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}),\n#&gt;             QueryExpression({\"size\": {\"$gt\": 2}}),\n#&gt;         )\n#&gt;     }\n#&gt; )\nquery.or_(Tree.name == \"Spruce\", Tree.size &gt; 2)\n#&gt; ... same output ...\n</code></pre> Equivalent raw MongoDB filter: <pre><code>{\n  \"$or\":[\n    {\"name\":\"Spruce\"},\n    {\"size\":{\"$gt\":2}}\n  ]\n}\n</code></pre></p>"},{"location":"querying/#nor","title":"Nor","text":"<p>Filter the trees neither named Spruce NOR bigger than 2 (size): <pre><code>from odmantic import Model, query\n\n\nclass Tree(Model):\n    name: str\n    size: float\n\n\nquery.nor_(Tree.name == \"Spruce\", Tree.size &gt; 2)\n#&gt; QueryExpression(\n#&gt;     {\n#&gt;         \"$nor\": (\n#&gt;             QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}),\n#&gt;             QueryExpression({\"size\": {\"$gt\": 2}}),\n#&gt;         )\n#&gt;     }\n#&gt; )\n</code></pre> Equivalent raw MongoDB filter: <pre><code>{\n  \"$nor\":[\n    {\"name\":\"Spruce\"},\n    {\"size\":{\"$gt\":2}}\n  ]\n}\n</code></pre></p> <p>NOR Equivalence</p> <p>The following logical expressions are equivalent:</p> <ul> <li>A NOR B NOR C</li> <li>NOT(A OR B OR C)</li> <li>NOT(A) AND NOT(B) AND NOT(C)</li> </ul> <p><code>query.nor_</code> operator naming</p> <p>query.and_ and query.or_ require to add an extra underscore to avoid overlapping with the python keywords. While it could've been possible to name the NOR operator query.nor, the extra underscore has been kept for consistency in the naming of the logical operators.</p>"},{"location":"querying/#embedded-documents-filters","title":"Embedded documents filters","text":"<p>It's possible to build filter based on the content of embedded documents:</p> <p><pre><code>from odmantic import AIOEngine, EmbeddedModel, Model\n\n\nclass CapitalCity(EmbeddedModel):\n    name: str\n    population: int\n\n\nclass Country(Model):\n    name: str\n    currency: str\n    capital_city: CapitalCity\n\n\nCountry.capital_city.name == \"Paris\"\n#&gt; QueryExpression({'capital_city.name': {'$eq': 'Paris'}})\nCountry.capital_city.population &gt; 10 ** 6\n#&gt; QueryExpression({'capital_city.population': {'$gt': 1000000}})\n</code></pre> Equivalent raw MongoDB filters: <pre><code>{\"capital_city.name\": {\"$eq\": \"Paris\"}}\n</code></pre> <pre><code>{\"capital_city.population\": {\"$gt\": 1000000}}\n</code></pre></p> <p>Filtering across References</p> <p>Currently, it is not possible to build filter based on referenced objects.</p>"},{"location":"querying/#raw-mongodb-filters","title":"Raw MongoDB filters","text":"<p>Any QueryExpression can be replaced with raw MongoDB filters. Thus, it's completely possible to use traditional filters with the find, find_one or count methods.</p> <p>You can find more details about building raw query filters using the Model in the Raw query usage section.</p>"},{"location":"querying/#sorting","title":"Sorting","text":"<p>ODMantic uses SortExpression objects to handle sort expressions.</p> <p>There are multiple ways of building SortExpression objects:</p> <ol> <li> <p>Using implicit <code>Model</code> fields:</p> <p>Ascending sort</p> <p>To sort <code>Publisher</code> instances by ascending <code>Publisher.founded</code>:</p> <p><pre><code>await engine.find(Publisher, sort=Publisher.founded)\n</code></pre> This example refers to the code showcased in the Overview.</p> </li> <li> <p>Using the functions provided by the <code>odmantic.query</code> module</p> <ul> <li>query.asc</li> <li>query.desc</li> </ul> </li> <li> <p>Using methods of the model's field and the desired value</p> <ul> <li><code>field.asc</code></li> <li><code>field.desc</code></li> </ul> </li> </ol> <p>Type checkers</p> <p>Since there is currently not any type checker plugin, the third usage might create some errors with type checkers.</p>"},{"location":"querying/#ascending","title":"Ascending","text":"<pre><code>from odmantic import AIOEngine, Model, query\n\nengine = AIOEngine()\n\n\nclass Tree(Model):\n    name: str\n    average_size: float\n\n\n# The following queries are equivalent,\n# they will sort `Tree` by ascending `average_size`\n\nawait engine.find(Tree, sort=Tree.average_size)\nawait engine.find(Tree, sort=Tree.average_size.asc())\nawait engine.find(Tree, sort=query.asc(Tree.average_size))\n</code></pre>"},{"location":"querying/#descending","title":"Descending","text":"<pre><code>from odmantic import AIOEngine, Model, query\n\nengine = AIOEngine()\n\n\nclass Tree(Model):\n    name: str\n    average_size: float\n\n\n# The following queries are equivalent,\n# they will sort `Tree` by descending `average_size`\n\nawait engine.find(Tree, sort=Tree.average_size.desc())\nawait engine.find(Tree, sort=query.desc(Tree.average_size))\n</code></pre>"},{"location":"querying/#sort-on-multiple-fields","title":"Sort on multiple fields","text":"<p>We can pass a <code>tuple</code> to the <code>sort</code> kwarg, this will enable us to make a more complex sort query:</p> <pre><code>from odmantic import AIOEngine, Model, query\n\nengine = AIOEngine()\n\n\nclass Tree(Model):\n    name: str\n    average_size: float\n\n\n# This query will first sort on ascending `average_size`, then\n# on descending `name` when `average_size` is the same\n\nawait engine.find(Tree, sort=(Tree.average_size, Tree.name.desc()))\n</code></pre>"},{"location":"querying/#embedded-model-field-as-a-sort-key","title":"Embedded model field as a sort key","text":"<p>We can sort instances based on the content of their embedded models.</p> <p>Sorting by an embedded model field</p> <p>We can sort the countries by descending order of the population of their capital city:</p> <pre><code>from odmantic import AIOEngine, EmbeddedModel, Model\nfrom odmantic.query import desc\n\n\nclass CapitalCity(EmbeddedModel):\n    name: str\n    population: int\n\n\nclass Country(Model):\n    name: str\n    currency: str\n    capital_city: CapitalCity\n\n\nengine = AIOEngine()\nawait engine.find(Country, sort=desc(Country.capital_city.population))\n</code></pre>"},{"location":"raw_query_usage/","title":"Raw query usage","text":"<p>As ODMantic doesn't completely wrap the MongoDB API, some helpers are provided to be enhance the usability while building raw queries and interacting with raw documents.</p>"},{"location":"raw_query_usage/#raw-query-helpers","title":"Raw query helpers","text":""},{"location":"raw_query_usage/#collection-name","title":"Collection name","text":"<p>You can get the collection name associated to a model by using the unary <code>+</code> operator on the model class. <pre><code>from odmantic import Model\n\n\nclass User(Model):\n    name: str\n\n\ncollection_name = +User\nprint(collection_name)\n#&gt; user\n</code></pre></p>"},{"location":"raw_query_usage/#motor-collection","title":"Motor collection","text":"<p>The AIOEngine object can provide you directly the motor collection (AsyncIOMotorCollection) linked to the motor client used by the engine. To achieve this, you can use the AIOEngine.get_collection method.</p> <pre><code>from odmantic import AIOEngine, Model\n\n\nclass User(Model):\n    name: str\n\n\nengine = AIOEngine()\nmotor_collection = engine.get_collection(User)\nprint(motor_collection)\n#&gt; AsyncIOMotorCollection(\n#&gt;     Collection(\n#&gt;         Database(\n#&gt;             MongoClient(\n#&gt;                 host=[\"localhost:27017\"],\n#&gt;                 document_class=dict,\n#&gt;                 tz_aware=False,\n#&gt;                 connect=False,\n#&gt;                 driver=DriverInfo(name=\"Motor\", version=\"2.2.0\", platform=\"asyncio\"),\n#&gt;             ),\n#&gt;             \"test\",\n#&gt;         ),\n#&gt;         \"user\",\n#&gt;     )\n#&gt; )\n</code></pre>"},{"location":"raw_query_usage/#pymongo-collection","title":"PyMongo collection","text":"<p>The SyncEngine object can provide you directly the PyMongo collection (pymongo.collection.Collection) linked to the PyMongo client used by the engine. To achieve this, you can use the SyncEngine.get_collection method.</p> <pre><code>from odmantic import SyncEngine, Model\n\n\nclass User(Model):\n    name: str\n\n\nengine = SyncEngine()\ncollection = engine.get_collection(User)\nprint(collection)\n#&gt; Collection(\n#&gt;     Database(\n#&gt;         MongoClient(\n#&gt;             host=[\"localhost:27017\"],\n#&gt;             document_class=dict,\n#&gt;             tz_aware=False,\n#&gt;             connect=True,\n#&gt;         ),\n#&gt;         \"test\",\n#&gt;     ),\n#&gt;     \"user\",\n#&gt; )\n</code></pre>"},{"location":"raw_query_usage/#key-name-of-a-field","title":"Key name of a field","text":"<p>Since some field might have some customized key names, you can get the key name associated to a field by using the unary <code>+</code> operator on the model class. As well, to ease the use of aggregation pipelines where you might need to reference your field (<code>$field</code>), you can double the operator (i.e use <code>++</code>) to get the field reference name.</p> <pre><code>from odmantic import Field, Model\n\n\nclass User(Model):\n    name: str = Field(key_name=\"username\")\n\n\nprint(+User.name)\n#&gt; username\n\nprint(++User.name)\n#&gt; $username\n</code></pre>"},{"location":"raw_query_usage/#using-raw-mongodb-filters","title":"Using raw MongoDB filters","text":"<p>Any QueryExpression can be replaced by its raw filter equivalent.</p> <p>For example, with a Tree model:</p> <pre><code>from odmantic import AIOEngine, Model\n\n\nclass Tree(Model):\n    name: str\n    average_size: float\n\n\nengine = AIOEngine()\n</code></pre> <p>All the following find queries would give exactly the same results: <pre><code>engine.find(Tree, Tree.average_size &gt; 2)\nengine.find(Tree, {+Tree.average_size: {\"$gt\": 2}})\nengine.find(Tree, {\"average_size\": {\"$gt\": 2}})\n</code></pre></p>"},{"location":"raw_query_usage/#raw-mongodb-documents","title":"Raw MongoDB documents","text":""},{"location":"raw_query_usage/#parsing-documents","title":"Parsing documents","text":"<p>You can parse MongoDB document to instances using the model_validate_doc method.</p> <p>Tip</p> <p>If the provided documents contain extra fields, ODMantic will ignore them. This can be especially useful in aggregation pipelines.</p> <pre><code>from bson import ObjectId\n\nfrom odmantic import Field, Model\n\n\nclass User(Model):\n    name: str = Field(key_name=\"username\")\n\n\ndocument = {\"username\": \"John\", \"_id\": ObjectId(\"5f8352a87a733b8b18b0cb27\")}\n\nuser = User.model_validate_doc(document)\nprint(repr(user))\n#&gt; User(id=ObjectId('5f8352a87a733b8b18b0cb27'), name='John')\n</code></pre>"},{"location":"raw_query_usage/#dumping-documents","title":"Dumping documents","text":"<p>You can generate a document from instances using the model_dump_doc method. <pre><code>from odmantic import Field, Model\n\n\nclass User(Model):\n    name: str = Field(key_name=\"username\")\n\n\nuser = User(name=\"John\")\nprint(user.model_dump_doc())\n#&gt; {'username': 'John', '_id': ObjectId('5f8352a87a733b8b18b0cb27')}\n</code></pre></p>"},{"location":"raw_query_usage/#advanced-parsing-behavior","title":"Advanced parsing behavior","text":""},{"location":"raw_query_usage/#default-values","title":"Default values","text":"<p>While parsing documents, ODMantic will use the default values provided in the Models to populate the missing fields from the documents:</p> <pre><code>from bson import ObjectId\n\nfrom odmantic import Model\n\n\nclass Player(Model):\n    name: str\n    level: int = 1\n\n\ndocument = {\"name\": \"Leeroy\", \"_id\": ObjectId(\"5f8352a87a733b8b18b0cb27\")}\n\nuser = Player.model_validate_doc(document)\nprint(repr(user))\n#&gt; Player(\n#&gt;     id=ObjectId(\"5f8352a87a733b8b18b0cb27\"),\n#&gt;     name=\"Leeroy\",\n#&gt;     level=1,\n#&gt; )\n</code></pre>"},{"location":"raw_query_usage/#default-factories","title":"Default factories","text":"<p>For the field with default factories provided through the Field descriptor though, by default they wont be populated.</p> <pre><code>from datetime import datetime\n\nfrom bson import ObjectId\n\nfrom odmantic import Model\nfrom odmantic.exceptions import DocumentParsingError\nfrom odmantic.field import Field\n\n\nclass User(Model):\n    name: str\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n\n\ndocument = {\"name\": \"Leeroy\", \"_id\": ObjectId(\"5f8352a87a733b8b18b0cb27\")}\n\ntry:\n    User.model_validate_doc(document)\nexcept DocumentParsingError as e:\n    print(e)\n    #&gt; 1 validation error for User\n    #&gt; created_at\n    #&gt;   key not found in document (type=value_error.keynotfoundindocument; key_name='created_at')\n    #&gt; (User instance details: id=ObjectId('5f8352a87a733b8b18b0cb27'))\n</code></pre> <p>In the previous example, using the default factories could create data inconsistencies and in this case, it would probably be more suitable to perform a manual migration to provide the correct values.</p> <p>Still, the <code>parse_doc_with_default_factories</code> Config option can be used to allow the use of the default factories while parsing documents:</p> <pre><code>from datetime import datetime\n\nfrom bson import ObjectId\n\nfrom odmantic import Model\nfrom odmantic.exceptions import DocumentParsingError\nfrom odmantic.field import Field\n\n\nclass User(Model):\n    name: str\n    updated_at: datetime = Field(default_factory=datetime.utcnow)\n\n    model_config = {\"parse_doc_with_default_factories\": True}\n\n\ndocument = {\"name\": \"Leeroy\", \"_id\": ObjectId(\"5f8352a87a733b8b18b0cb27\")}\n\nuser = User.model_validate_doc(document)\nprint(repr(user))\n#&gt; User(\n#&gt;     id=ObjectId(\"5f8352a87a733b8b18b0cb27\"),\n#&gt;     name=\"Leeroy\",\n#&gt;     updated_at=datetime.datetime(2020, 11, 8, 23, 28, 19, 980000),\n#&gt; )\n</code></pre>"},{"location":"raw_query_usage/#aggregation-example","title":"Aggregation example","text":"<p>In the following example, we will demonstrate the use of the previous helpers to build an aggregation pipeline. We will first consider a <code>Rectangle</code> model with two float fields (<code>height</code> and <code>length</code>). We will then fetch the rectangles with an area that is less than 10. To finish, we will reconstruct <code>Rectangle</code> instances from this query.</p> <pre><code>from odmantic import AIOEngine, Model\n\n\nclass Rectangle(Model):\n    length: float\n    width: float\n\n\nrectangles = [\n    Rectangle(length=0.1, width=1),\n    Rectangle(length=3.5, width=1),\n    Rectangle(length=2.87, width=5.19),\n    Rectangle(length=1, width=10),\n    Rectangle(length=0.1, width=100),\n]\n\nengine = AIOEngine()\nawait engine.save_all(rectangles)\n\ncollection = engine.get_collection(Rectangle)\npipeline = []\n# Add an area field\npipeline.append(\n    {\n        \"$addFields\": {\n            \"area\": {\n                \"$multiply\": [++Rectangle.length, ++Rectangle.width]\n            }  # Compute the area remotely\n        }\n    }\n)\n# Filter only rectanges with an area lower than 10\npipeline.append({\"$match\": {\"area\": {\"$lt\": 10}}})\n# Project to keep only the defined fields (this step is optional)\npipeline.append(\n    {\n        \"$project\": {\n            +Rectangle.length: True,\n            +Rectangle.width: True,\n        }  # Specifying \"area\": False is unnecessary here\n    }\n)\ndocuments = await collection.aggregate(pipeline).to_list(length=None)\nsmall_rectangles = [Rectangle.model_validate_doc(doc) for doc in documents]\nprint(small_rectangles)\n#&gt; [\n#&gt;     Rectangle(id=ObjectId(\"...\"), length=0.1, width=1.0),\n#&gt;     Rectangle(id=ObjectId(\"...\"), length=3.5, width=1.0),\n#&gt; ]\n</code></pre>"},{"location":"usage_fastapi/","title":"Usage with FastAPI","text":""},{"location":"usage_fastapi/#example","title":"Example","text":"<p>In this example, we create a minimalist REST API describing trees by their name, average size and discovery year.</p> <p>Requirements</p> <p>To run the following example, you'll need to install FastAPI and Uvicorn. <pre><code>pip install fastapi uvicorn\n</code></pre></p> <pre><code>from typing import List\n\nfrom fastapi import FastAPI, HTTPException\n\nfrom odmantic import AIOEngine, Model, ObjectId\n\n\nclass Tree(Model):\n    name: str\n    average_size: float\n    discovery_year: int\n\n\napp = FastAPI()\n\nengine = AIOEngine()\n\n\n@app.put(\"/trees/\", response_model=Tree)\nasync def create_tree(tree: Tree):\n    await engine.save(tree)\n    return tree\n\n\n@app.get(\"/trees/\", response_model=List[Tree])\nasync def get_trees():\n    trees = await engine.find(Tree)\n    return trees\n\n\n@app.get(\"/trees/count\", response_model=int)\nasync def count_trees():\n    count = await engine.count(Tree)\n    return count\n\n\n@app.get(\"/trees/{id}\", response_model=Tree)\nasync def get_tree_by_id(id: ObjectId):\n    tree = await engine.find_one(Tree, Tree.id == id)\n    if tree is None:\n        raise HTTPException(404)\n    return tree\n</code></pre> <p>You can then start the application. For example if you saved the file above in a file named <code>tree_api.py</code>: <pre><code>uvicorn tree_api:app\n</code></pre></p> <p>Uvicorn should start serving the API locally:</p> <pre><code>INFO:     Started server process [21429]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://localhost:8080 (Press CTRL+C to quit)\n</code></pre> <p>To try it out, you can simply access the interactive documentation generated by FastAPI at http://localhost:8080/docs.</p> <p></p> <p>We'll now dive in the details of this example.</p>"},{"location":"usage_fastapi/#defining-the-model","title":"Defining the model","text":"<p>First, we create our <code>Tree</code> model.</p> <pre><code>class Tree(Model):\n    name: str\n    average_size: float\n    discovery_year: int\n</code></pre> <p>This describes our <code>Tree</code> instances structure both for JSON serialization and for the storage in the MongoDB collection.</p>"},{"location":"usage_fastapi/#building-the-engine","title":"Building the engine","text":"<p>After having defined the model, we create the AIOEngine object. This object will be responsible for performing database operations.</p> <pre><code>engine = AIOEngine()\n</code></pre> <p>It's possible as well to build the engine with custom parameters (mongo URI, database name). See this section for more details.</p> <p>Running the python file directly</p> <p>If you need to execute the python file directly with the interpreter (to use a debugger for example), some extra steps will be required.</p> <p>Run <code>uvicorn</code> using the default event loop (if the file is called directly): <pre><code>if __name__ == \"__main__\":\n    import asyncio\n    import uvicorn\n    loop = asyncio.get_event_loop()\n    config = uvicorn.Config(app=app, port=8080, loop=loop)\n    server = uvicorn.Server(config)\n    loop.run_until_complete(server.serve())\n</code></pre></p> <code>uvicorn.run</code> behavior with event loops (Advanced) <p>The usual entrypoint <code>uvicorn.run(app)</code> for ASGI apps doesn't work because when called <code>uvicorn</code> will create and run a brand new event loop.</p> <p>Thus, the engine object will be bound to a different event loop that will not be running. In this case, you'll witness <code>&lt;Future pending&gt; attached to a different loop</code> errors because the app itself will be running in a different event loop than the engine's driver.</p> <p>Anyway, when running directly the app through the <code>uvicorn</code> CLI, the default event loop will be the one that will be running later, so no modifications are required.</p> <p>AIOEngineDependency deprecation (from v0.2.0)</p> <p>The <code>AIOEngineDependency</code> that was used to inject the engine in the API routes is now deprecated (it will be kept for few versions though).</p> <p>Using a global engine object should be preferred as it will dramatically reduce the required verbosity to use the engine in an endpoint.</p> <p>If you need to run your <code>app</code> directly from a python file, see the above Running the python file directly section.</p>"},{"location":"usage_fastapi/#creating-a-tree","title":"Creating a tree","text":"<p>The next step is to define a route enabling us to create a new tree. To that end, we create a <code>PUT</code> route with the path <code>/trees/</code>. This endpoint will receive a tree, persist it to the database and return the created object.</p> <p><pre><code>@app.put(\"/trees/\", response_model=Tree)\nasync def create_tree(tree: Tree):\n    await engine.save(tree)\n    return tree\n</code></pre> First, the request body will be parsed to a <code>Tree</code> object (this is done by specifying the argument <code>tree: Tree</code>). This mean that the model validation will be performed. Once the model is parsed to a Tree instance, we persist it to the database and we return it.</p> Command line tool for interacting with JSON based HTTP APIs <p>To interact with the API from the command line, we recommend to use the HTTPie CLI.</p> <p>The next examples are still provided with the <code>curl</code> syntax since the Swagger  documentation generated by FastAPI will give you curl examples directly.</p> <p>Creating a Tree from the command line</p> HTTPiecurl <p>Send the request: <pre><code>http PUT localhost:8080/trees/ name=\"Spruce\" discovery_year=1995 average_size=2\n</code></pre> Output: <pre><code>HTTP/1.1 200 OK\ncontent-length: 90\ncontent-type: application/json\ndate: Sun, 18 Oct 2020 18:40:30 GMT\nserver: uvicorn\n\n{\n    \"average_size\": 2.0,\n    \"discovery_year\": 1995,\n    \"id\": \"5f8c8c1ff1d33aa1012f3086\",\n    \"name\": \"Spruce\"\n}\n</code></pre></p> <p>Send the request: <pre><code>curl -X PUT \"http://localhost:8080/trees/\" \\\n     -H  \"Content-Type: application/json\" \\\n     -d '{\"name\":\"Spruce\", \"discovery_year\":1995, \"average_size\":2}'\n</code></pre> Output: <pre><code>{\"name\":\"Spruce\",\"average_size\":2.0,\"discovery_year\":1995,\"id\":\"5f8c8c1ff1d33aa1012f3086\"}\n</code></pre></p> <p>You can notice that the <code>id</code> field has been added automatically by ODMantic. This <code>id</code> field is actually not required since it's defined automatically by ODMantic with a default factory method (more details).</p> <p>You can still specify this field in the request body to predefine the <code>id</code> of the created instance or to overwrite an existing instance.</p> <p>Why <code>PUT</code> instead of <code>POST</code> ?</p> <p>Since the <code>engine.save</code> behave as an upsert operation (more details), you can overwrite instances stored in the database  by creating a new instance with the same id and calling the <code>engine.save</code> method.</p> Modifying the Tree from the command line <p>To overwrite the tree with <code>id=5f8c8c1ff1d33aa1012f3086</code>:</p> HTTPiecurl <p>Send the request: <pre><code>http PUT localhost:8080/trees/ \\\n    name=\"Norway Spruce\" discovery_year=1795 \\\n    average_size=200 id=\"5f8c8c1ff1d33aa1012f3086\"\n</code></pre> Output: <pre><code>HTTP/1.1 200 OK\ncontent-length: 90\ncontent-type: application/json\ndate: Sun, 18 Oct 2020 18:40:30 GMT\nserver: uvicorn\n\n{\n    \"average_size\": 200.0,\n    \"discovery_year\": 1795,\n    \"id\": \"5f8c8c1ff1d33aa1012f3086\",\n    \"name\": \"Norway Spruce\"\n}\n</code></pre></p> <p>Send the request: <pre><code>curl -X PUT \"http://localhost:8080/trees/\" \\\n     -H  \"Content-Type: application/json\" \\\n     -d '{\"name\":\"Norway Spruce\", \"discovery_year\":1795,\n          \"average_size\":200, \"id\":\"5f8c8c1ff1d33aa1012f3086\"}'\n</code></pre> Output: <pre><code>{\"name\":\"Norway Spruce\",\"average_size\":200.0,\"discovery_year\":1795,\"id\":\"5f8c8c1ff1d33aa1012f3086\"}\n</code></pre></p> <p>Since we can modify an existing instance, it makes more sense to define the  operation as a <code>PUT</code> instead of a <code>POST</code> that should create a new resource on each  call.</p> <p>If the request body doesn't match our model schema, a <code>422 Unprocessable Entity</code> error will be returned by the API, containing the details about the error.</p> <p>Invalid data while creating the Tree from the command line</p> <p>You can try by omitting the <code>average_size</code> field:</p> HTTPiecurl <p>Send the request: <pre><code>http PUT localhost:8080/trees/ name=\"Spruce\" discovery_year=1995\n</code></pre> Output: <pre><code>HTTP/1.1 422 Unprocessable Entity\ncontent-length: 96\ncontent-type: application/json\ndate: Sun, 18 Oct 2020 16:42:18 GMT\nserver: uvicorn\n\n{\n    \"detail\": [\n        {\n            \"loc\": [\n                \"body\",\n                \"average_size\"\n            ],\n            \"msg\": \"field required\",\n            \"type\": \"value_error.missing\"\n        }\n    ]\n}\n</code></pre></p> <p>Send the request: <pre><code>curl -v -X PUT \"http://localhost:8080/trees/\" \\\n     -H  \"Content-Type: application/json\" \\\n     -d '{\"name\":\"Spruce\", \"discovery_year\":1995}'\n</code></pre> Output: <pre><code>*   Trying 127.0.0.1...\n* TCP_NODELAY set\n* Connected to localhost (127.0.0.1) port 8080 (#0)\n&gt; PUT /trees/ HTTP/1.1\n&gt; Host: localhost:8080\n&gt; User-Agent: curl/7.58.0\n&gt; Accept: */*\n&gt; Content-Type: application/json\n&gt; Content-Length: 40\n&gt;\n* upload completely sent off: 40 out of 40 bytes\n&lt; HTTP/1.1 422 Unprocessable Entity\n&lt; date: Sun, 18 Oct 2020 18:51:33 GMT\n&lt; server: uvicorn\n&lt; content-length: 96\n&lt; content-type: application/json\n&lt;\n* Connection #0 to host localhost left intact\n{\"detail\":[{\"loc\":[\"body\",\"average_size\"],\"msg\":\"field required\",\"type\":\"value_error.missing\"}]}%\n</code></pre></p> <p>The validation error structure is the one that is defined by the Pydantic:  ValidationError  exception.</p> <p>Finally, specifying the <code>response_model</code> in the <code>app.put</code> decorator is not mandatory but it is strongly advised as it helps FastAPI to generate the documentation.</p>"},{"location":"usage_fastapi/#getting-all-the-trees","title":"Getting all the trees","text":"<p>To get the trees stored in the database, we use the AIOEngine.find method in its <code>awaitable</code> form (more details), this gives us directly the list of Tree instances that we can return directly:</p> <pre><code>@app.get(\"/trees/\", response_model=List[Tree])\nasync def get_trees():\n    trees = await engine.find(Tree)\n    return trees\n</code></pre> <p>Creating and getting the trees from the command line</p> HTTPiecurl <p>Create some trees: <pre><code>http PUT localhost:8080/trees/ name=\"Spruce\" discovery_year=1995 average_size=10.2\nhttp PUT localhost:8080/trees/ name=\"Pine\" discovery_year=1850 average_size=5\n</code></pre></p> <p>Get the trees: <pre><code>http localhost:8080/trees/\n</code></pre> Output: <pre><code>HTTP/1.1 200 OK\ncontent-length: 270\ncontent-type: application/json\ndate: Sun, 18 Oct 2020 17:59:10 GMT\nserver: uvicorn\n\n[\n    {\n        \"average_size\": 10.2,\n        \"discovery_year\": 1995,\n        \"id\": \"5f8c8266f1d33aa1012f3082\",\n        \"name\": \"Spruce\"\n    },\n    {\n        \"average_size\": 5.0,\n        \"discovery_year\": 1850,\n        \"id\": \"5f8c8266f1d33aa1012f3083\",\n        \"name\": \"Pine\"\n    }\n]\n</code></pre></p> <p>Create some trees: <pre><code>curl -v -X PUT \"http://localhost:8080/trees/\" \\\n     -H  \"Content-Type: application/json\" \\\n     -d '{\"name\":\"Spruce\", \"discovery_year\":1995, \"average_size\":10.2}'\ncurl -v  -X PUT \"http://localhost:8080/trees/\" \\\n     -H  \"Content-Type: application/json\" \\\n     -d '{\"name\":\"Pine\", \"discovery_year\":1850, \"average_size\":5}'\n</code></pre> Get the trees: <pre><code>curl http://localhost:8080/trees/ | python -mjson.tool\n</code></pre> Output: <pre><code>[\n    {\n        \"name\": \"Spruce\",\n        \"average_size\": 10.2,\n        \"discovery_year\": 1995,\n        \"id\": \"5f8c8266f1d33aa1012f3082\"\n    },\n    {\n        \"name\": \"Pine\",\n        \"average_size\": 5.0,\n        \"discovery_year\": 1850,\n        \"id\": \"5f8c8266f1d33aa1012f3083\"\n    }\n]\n</code></pre></p> <p>Pagination</p> <p>You can add pagination to this <code>GET</code> request by using the <code>skip</code> and <code>limit</code> arguments while calling the AIOEngine.find method.</p>"},{"location":"usage_fastapi/#counting-the-trees","title":"Counting the trees","text":"<p>To get the number of trees stored in the database, we use the AIOEngine.count method without specifying any query parameters (to directly get the total count of instances).</p> <pre><code>@app.get(\"/trees/count\", response_model=int)\nasync def count_trees():\n    count = await engine.count(Tree)\n    return count\n</code></pre> <p>Getting the tree count from the command line</p> HTTPiecurl <p>Get the count: <pre><code>http localhost:8080/trees/count\n</code></pre> Output: <pre><code>HTTP/1.1 200 OK\ncontent-length: 1\ncontent-type: application/json\ndate: Sun, 18 Oct 2020 20:16:50 GMT\nserver: uvicorn\n\n2\n</code></pre></p> <p>Get the count: <pre><code>curl http://localhost:8080/trees/count\n</code></pre> Output: <pre><code>2\n</code></pre></p>"},{"location":"usage_fastapi/#getting-a-tree-by-id","title":"Getting a tree by <code>id</code>","text":"<pre><code>@app.get(\"/trees/{id}\", response_model=Tree)\nasync def get_tree_by_id(id: ObjectId, ):\n    tree = await engine.find_one(Tree, Tree.id == id)\n    if tree is None:\n        raise HTTPException(404)\n    return tree\n</code></pre> <p>To return a tree from its <code>id</code> we add a path parameter <code>id: ObjectId</code>. Once this endpoint is called, FastAPI will try to validate this query parameter, thus inferring an <code>ObjectId</code> object.</p> <p>Using BSON objects as parameters</p> <p>While you can define ODMantic models directly using <code>bson</code> fields (more details), it's not possible to use those types directly with FastAPI, you'll need to get the equivalent objects from the odmantic.bson module. Those equivalent types implement the additional validation logic enabling FastAPI to work with them.</p> <pre><code>from odmantic.bson import ObjectId\n</code></pre> <p>For convenience reasons, the <code>ObjectId</code> type including the validation logic is as well available directly from the <code>odmantic</code> module.</p> <pre><code>from odmantic import ObjectId\n</code></pre> <p>With this <code>ObjectId</code>, we build a query that will filter only the instances having this exactly same <code>id</code>: <pre><code>Tree.id == id\n</code></pre> Then, we pass this query to the AIOEngine.find_one method that will try to return an instance, otherwise <code>None</code> will be returned: <pre><code>tree = await engine.find_one(Tree, Tree.id == id)\n</code></pre> Now, if our tree object is None (i.e the instance has not been found), we need to return a <code>404 Not Found</code> error: <pre><code>if tree is None:\n    raise HTTPException(404)\n</code></pre> Otherwise, we found the requested instance. We can return it ! <pre><code>return tree\n</code></pre></p> <p>Getting a tree from the command line</p> HTTPiecurl <p>Get the tree <code>5f8c8266f1d33aa1012f3082</code>: <pre><code>http localhost:8080/trees/5f8c8266f1d33aa1012f3082\n</code></pre> Output: <pre><code>HTTP/1.1 200 OK\ncontent-length: 91\ncontent-type: application/json\ndate: Sun, 18 Oct 2020 21:08:07 GMT\nserver: uvicorn\n\n{\n    \"average_size\": 10.2,\n    \"discovery_year\": 1995,\n    \"id\": \"5f8c8266f1d33aa1012f3082\",\n    \"name\": \"Spruce\"\n}\n</code></pre></p> <p>Get the tree <code>5f8c8266f1d33aa1012f3082</code>:</p> <p><pre><code>curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3082\n</code></pre> Output: <pre><code>{\"name\":\"Spruce\",\"average_size\":10.2,\"discovery_year\":1995,\"id\":\"5f8c8266f1d33aa1012f3082\"}\n</code></pre></p> <p>Trying to get a tree not in the database from the command line</p> HTTPiecurl <p>Try to get the tree <code>f0f0f0f0f0f0f0f0f0f0f0f0</code> (it has not been created): <pre><code>http localhost:8080/trees/f0f0f0f0f0f0f0f0f0f0f0f0\n</code></pre> Output: <pre><code>HTTP/1.1 404 Not Found\ncontent-length: 22\ncontent-type: application/json\ndate: Sun, 18 Oct 2020 21:11:48 GMT\nserver: uvicorn\n\n{\n    \"detail\": \"Not Found\"\n}\n</code></pre></p> <p>Try to get the tree <code>f0f0f0f0f0f0f0f0f0f0f0f0</code> (it has not been created): <pre><code>curl http://localhost:8080/trees/f0f0f0f0f0f0f0f0f0f0f0f0\n</code></pre> Output: <pre><code>{\"detail\":\"Not Found\"}\n</code></pre></p> <p>This <code>id</code> path parameter should be a 16 characters hexadecimal string (see MongoDB: ObjectId for more details). If the <code>id</code> specified in the path does not match this criteria, a <code>422 Unprocessable Entity</code> error will be returned:</p> <p>Trying to get a tree with an invalid <code>id</code> from the command line</p> HTTPiecurl <p>Get the tree identified by <code>invalid_object_id</code>: <pre><code>http localhost:8080/trees/invalid_object_id\n</code></pre> Output: <pre><code>HTTP/1.1 422 Unprocessable Entity\ncontent-length: 89\ncontent-type: application/json\ndate: Sun, 18 Oct 2020 20:50:25 GMT\nserver: uvicorn\n\n{\n    \"detail\": [\n        {\n            \"loc\": [\n                \"path\",\n                \"id\"\n            ],\n            \"msg\": \"invalid ObjectId specified\",\n            \"type\": \"type_error\"\n        }\n    ]\n}\n</code></pre></p> <p>Get the tree identified by <code>invalid_object_id</code>:</p> <p><pre><code>curl http://localhost:8080/trees/invalid_object_id\n</code></pre> Output: <pre><code>{\"detail\":[{\"loc\":[\"path\",\"id\"],\"msg\":\"invalid ObjectId specified\",\"type\":\"type_error\"}]}\n</code></pre></p>"},{"location":"usage_fastapi/#extending-the-example","title":"Extending the example","text":""},{"location":"usage_fastapi/#deleting-a-tree","title":"Deleting a tree","text":"<pre><code>import uvicorn\nfrom fastapi import FastAPI, HTTPException\n\nfrom odmantic import AIOEngine, Model, ObjectId\n\n\nclass Tree(Model):\n    name: str\n    average_size: float\n    discovery_year: int\n\n\napp = FastAPI()\n\nengine = AIOEngine()\n\n\n@app.get(\"/trees/{id}\", response_model=Tree)\nasync def get_tree_by_id(id: ObjectId):\n    tree = await engine.find_one(Tree, Tree.id == id)\n    if tree is None:\n        raise HTTPException(404)\n    return tree\n\n\n@app.delete(\"/trees/{id}\", response_model=Tree)\nasync def delete_tree_by_id(id: ObjectId):\n    tree = await engine.find_one(Tree, Tree.id == id)\n    if tree is None:\n        raise HTTPException(404)\n    await engine.delete(tree)\n    return tree\n</code></pre> <p>This new <code>DELETE</code> route is strongly inspired from the one used to get a tree from its <code>id</code>.</p> <p>Currently, ODMantic can only delete an instance and it's not possible to perform a delete operation from a query filter. Thus, we first need to get the associated instance. Once we have the instance, we call the AIOEngine.delete method to perform the deletion.</p> <p>Deleting a tree from the command line</p> HTTPiecurl <p>Delete the tree identified by <code>5f8c8266f1d33aa1012f3082</code>: <pre><code>http DELETE localhost:8080/trees/5f8c8266f1d33aa1012f3082\n</code></pre> Output: <pre><code>HTTP/1.1 200 OK\ncontent-length: 91\ncontent-type: application/json\ndate: Sun, 18 Oct 2020 21:35:22 GMT\nserver: uvicorn\n\n{\n    \"average_size\": 10.2,\n    \"discovery_year\": 1995,\n    \"id\": \"5f8c8266f1d33aa1012f3082\",\n    \"name\": \"Spruce\"\n}\n</code></pre></p> <p>Check that the tree is not stored anymore:</p> <p><pre><code>http localhost:8080/trees/5f8c8266f1d33aa1012f3082\n</code></pre> Output: <pre><code>HTTP/1.1 404 Not Found\ncontent-length: 22\ncontent-type: application/json\ndate: Sun, 18 Oct 2020 21:36:45 GMT\nserver: uvicorn\n\n{\n    \"detail\": \"Not Found\"\n}\n</code></pre></p> <p>Delete the tree identified by <code>5f8c8266f1d33aa1012f3082</code>: <pre><code>curl -X DELETE http://localhost:8080/trees/5f8c8266f1d33aa1012f3082\n</code></pre> Output: <pre><code>{\"name\":\"Spruce\",\"average_size\":10.2,\"discovery_year\":1995,\"id\":\"5f8c8266f1d33aa1012f3082\"}\n</code></pre> Check that the tree is not stored anymore: <pre><code>curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3082\n</code></pre> Output: <pre><code>{\"detail\":\"Not Found\"}\n</code></pre></p> <p>The tree has been removed successfully !</p>"},{"location":"usage_fastapi/#updating-a-tree","title":"Updating a tree","text":"<p>We already defined a <code>PUT</code> route that enables us to modify (replace) a tree instance. However, with this previous implementation, it's not possible to specify only the fields that we want to change as the whole Tree instance is rebuilt from the request's body.</p> <p>In this example, we will define a <code>PATCH</code> method that will allow us to modify only some specific fields of a Tree instance:</p> <p><pre><code>from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\n\nfrom odmantic import AIOEngine, Model, ObjectId\n\n\nclass Tree(Model):\n    name: str\n    average_size: float\n    discovery_year: int\n\n\napp = FastAPI()\n\nengine = AIOEngine()\n\n\n@app.get(\"/trees/{id}\", response_model=Tree)\nasync def get_tree_by_id(id: ObjectId):\n    tree = await engine.find_one(Tree, Tree.id == id)\n    if tree is None:\n        raise HTTPException(404)\n    return tree\n\n\nclass TreePatchSchema(BaseModel):\n    name: str = None\n    average_size: float = None\n    discovery_year: float = None\n\n\n@app.patch(\"/trees/{id}\", response_model=Tree)\nasync def update_tree_by_id(id: ObjectId, patch: TreePatchSchema):\n    tree = await engine.find_one(Tree, Tree.id == id)\n    if tree is None:\n        raise HTTPException(404)\n    tree.model_update(patch)\n    await engine.save(tree)\n    return tree\n</code></pre> First, we define the <code>TreePatchSchema</code> this Pydantic model will contain the modifications that we need to apply on the instance. Since we want to be able to update each field independently, we give each of them the <code>None</code> default value.</p> <p>Then, we configure a new <code>PATCH</code> endpoint by setting the <code>id</code> of the model to update as a path parameter and the <code>TreePatchSchema</code> as the request body parameter.</p> <p>After all the parameters have been validated properly and the appropriate instance have been gathered, we can apply the modifications to the local instance using the Model.model_update method. By default, the update method will replace each field values in the instance with the ones explicitely set in the patch object. Thus, the fields containing the None default values are not gonna be changed in the instance.</p> <p>We can then finish by saving and returning the updated tree.</p> Optional, defaults, non-required and required pydantic fields (advanced) <pre><code>from pydantic import BaseModel\n\nclass M(BaseModel):\n    a: Optional[int]\n    b: Optional[int] = None\n    c: int = None\n    d: int\n</code></pre> <p>In this example, fields have a different behavior:</p> <code>a: Optional[int]</code> this field is not required, <code>None</code> is its default value, it can be given   <code>None</code> or any <code>int</code> values <code>b: Optional[int] = None</code> same behavior as <code>a</code> since <code>None</code> is set automatically as the default value for   <code>typing.Optional</code> fields <code>c: int = None</code> this field is not required, if not explicitely provided it will take the   <code>None</code> value, only an <code>int</code> can be given as an explicit value <code>d: int</code> this field is required and an <code>int</code> value must be provided <p>(More details: pydantic #1223,  pydantic: Required fields)</p> <p>By default Model.model_update, will not apply values from unset (not explicitely populated) fields. Since we don't want to allow explicitely set <code>None</code> values in the example, we used fields defined as <code>c: int = None</code>.</p> <p>Updating a tree from the command line</p> HTTPiecurl <p>Update the tree identified by <code>5f8c8266f1d33aa1012f3083</code>: <pre><code>http PATCH localhost:8080/trees/5f8c8266f1d33aa1012f3083 \\\n    discovery_year=1825 name=\"Stone Pine\"\n</code></pre> Output: <pre><code>HTTP/1.1 200 OK\ncontent-length: 94\ncontent-type: application/json\ndate: Sun, 18 Oct 2020 22:02:44 GMT\nserver: uvicorn\n\n{\n    \"average_size\": 5.0,\n    \"discovery_year\": 1825,\n    \"id\": \"5f8c8266f1d33aa1012f3083\",\n    \"name\": \"Stone Pine\"\n}\n</code></pre></p> <p>Check that the tree has been updated properly:</p> <p><pre><code>http localhost:8080/trees/5f8c8266f1d33aa1012f3083\n</code></pre> Output: <pre><code>HTTP/1.1 200 OK\ncontent-length: 94\ncontent-type: application/json\ndate: Sun, 18 Oct 2020 22:06:52 GMT\nserver: uvicorn\n\n{\n    \"average_size\": 5.0,\n    \"discovery_year\": 1825,\n    \"id\": \"5f8c8266f1d33aa1012f3083\",\n    \"name\": \"Stone Pine\"\n}\n</code></pre></p> <p>Update the tree identified by <code>5f8c8266f1d33aa1012f3083</code>: <pre><code>curl -X PATCH \"http://localhost:8080/trees/5f8c8266f1d33aa1012f3083\" \\\n     -H  \"Content-Type: application/json\" \\\n     -d '{\"name\":\"Stone Pine\", \"discovery_year\":1825}'\n</code></pre> Output: <pre><code>{\"name\":\"Stone Pine\",\"average_size\":5.0,\"discovery_year\":1825,\"id\":\"5f8c8266f1d33aa1012f3083\"}\n</code></pre> Check that the tree has been updated properly: <pre><code>curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3083\n</code></pre> Output: <pre><code>{\"name\":\"Stone Pine\",\"average_size\":5.0,\"discovery_year\":1825,\"id\":\"5f8c8266f1d33aa1012f3083\"}\n</code></pre></p> <p>The tree has been updated successfully !</p>"},{"location":"usage_fastapi/#upcoming-features","title":"Upcoming features","text":"<p>A lot of feature could still improve the ODMantic + FastAPI experience.</p> <p>Some ideas that should arrive soon:</p> <ul> <li>Add a <code>not_found_exception</code> argument to the AIOEngine.find_one method. Thus, if the   document is not found an exception will be raised directly.</li> <li>Implement the equivalent of MongoDB insert method to be able to create document   without overwriting existing ones.</li> <li>Implement a Model.model_update method to update the model fields from a dictionnary or from   a Pydantic schema.</li> <li>Automatically generate CRUD endpoints directly from an ODMantic Model.</li> </ul>"},{"location":"usage_pydantic/","title":"Usage with Pydantic","text":""},{"location":"usage_pydantic/#defining-models-with-bson-fields","title":"Defining models with BSON Fields","text":"<p>You might need to define pure Pydantic models which include <code>BSON</code> fields. To that end, you can use the BaseBSONModel as the base class of your Pydantic models. This class adds the JSON encoders required to handle the <code>BSON</code> fields.</p> <p>Also, you will have to use the <code>bson</code> equivalent types defined in the odmantic.bson module. Those types, add a validation logic to the native types from the <code>bson</code> module.</p> <p>Custom <code>json_encoders</code> with <code>BaseBSONModel</code></p> <p>If you want to specify additional json encoders, with a Pydantic model containing <code>BSON</code> fields, you will need to pass as well the ODMantic encoders (BSON_TYPES_ENCODERS).</p> Custom encoders example <pre><code>from datetime import datetime\n\nfrom odmantic.bson import BSON_TYPES_ENCODERS, BaseBSONModel, ObjectId\n\n\nclass M(BaseBSONModel):\n    id: ObjectId\n    date: datetime\n\n    model_config = {\n        \"json_encoders\": {\n            **BSON_TYPES_ENCODERS,\n            datetime: lambda dt: dt.year,\n        }\n    }\n\n\nprint(M(id=ObjectId(), date=datetime.utcnow()).model_dump_json())\n#&gt; {\"id\": \"5fa3378c8fde3766574d874d\", \"date\": 2020}\n</code></pre> <p>An issue that would simplify this behavior has been opened: pydantic#2024</p>"},{"location":"usage_pydantic/#accessing-the-underlying-pydantic-model","title":"Accessing the underlying pydantic model","text":"<p>Each ODMantic Model contain a pure version of the pydantic model used to build the ODMantic Model. This Pydantic model can be accessed in the <code>__pydantic_model__</code> class attribute of the ODMantic Model/EmbeddedModel.</p>"},{"location":"api_reference/","title":"odmantic.index","text":"Source code in <code>odmantic/index.py</code> <pre><code>class Index:\n    def __init__(\n        self,\n        *fields: Union[FieldProxyAny, SortExpression],\n        unique: bool = False,\n        name: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Declare an ODM index in the Model.Config.indexes generator.\n\n        Example usage:\n        ```python\n        from odmantic import Model, Index\n        from odmantic.query import desc\n\n        class Player(Model):\n            name: str\n            score: int\n\n            model_config = {\n                \"indexes\": lambda: [Index(Player.name, desc(Player.score))],\n            }\n        ```\n\n        Args:\n            *fields (Any | SortExpression | str): fields to build the index with\n            unique: build a unique index\n            name: specify an optional custom index name\n        \"\"\"\n        self.fields = cast(Tuple[Union[SortExpression, FieldProxy], ...], fields)\n        self.unique = unique\n        self.name = name\n\n    def to_odm_index(self) -&gt; \"ODMBaseIndex\":\n        if len(self.fields) == 1:\n            field = self.fields[0]\n            if isinstance(field, SortExpression):\n                key_name = list(field.keys())[0]\n            else:\n                key_name = object.__getattribute__(field, \"_get_key_name\")()\n            return ODMSingleFieldIndex(\n                key_name, unique=self.unique, index_name=self.name\n            )\n        else:\n            fields = tuple(\n                (f if isinstance(f, SortExpression) else asc(f) for f in self.fields)\n            )\n            return ODMCompoundIndex(fields, unique=self.unique, index_name=self.name)\n</code></pre>"},{"location":"api_reference/#odmantic.index.Index.__init__","title":"<code>__init__(*fields, unique=False, name=None)</code>","text":"<p>Declare an ODM index in the Model.Config.indexes generator.</p> <p>Example usage: <pre><code>from odmantic import Model, Index\nfrom odmantic.query import desc\n\nclass Player(Model):\n    name: str\n    score: int\n\n    model_config = {\n        \"indexes\": lambda: [Index(Player.name, desc(Player.score))],\n    }\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>*fields</code> <code>Any | SortExpression | str</code> <p>fields to build the index with</p> <code>()</code> <code>unique</code> <code>bool</code> <p>build a unique index</p> <code>False</code> <code>name</code> <code>Optional[str]</code> <p>specify an optional custom index name</p> <code>None</code> Source code in <code>odmantic/index.py</code> <pre><code>def __init__(\n    self,\n    *fields: Union[FieldProxyAny, SortExpression],\n    unique: bool = False,\n    name: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Declare an ODM index in the Model.Config.indexes generator.\n\n    Example usage:\n    ```python\n    from odmantic import Model, Index\n    from odmantic.query import desc\n\n    class Player(Model):\n        name: str\n        score: int\n\n        model_config = {\n            \"indexes\": lambda: [Index(Player.name, desc(Player.score))],\n        }\n    ```\n\n    Args:\n        *fields (Any | SortExpression | str): fields to build the index with\n        unique: build a unique index\n        name: specify an optional custom index name\n    \"\"\"\n    self.fields = cast(Tuple[Union[SortExpression, FieldProxy], ...], fields)\n    self.unique = unique\n    self.name = name\n</code></pre>"},{"location":"api_reference/bson/","title":"odmantic.bson","text":"<p>This module provides helpers to build Pydantic Models containing BSON objects.</p>"},{"location":"api_reference/bson/#pydantic-model-helpers","title":"Pydantic model helpers","text":"<p>             Bases: <code>BaseModel</code></p> <p>Equivalent of <code>pydantic.BaseModel</code> supporting BSON types serialization.</p> <p>If you want to apply other custom JSON encoders, you'll need to use BSON_TYPES_ENCODERS directly.</p> Source code in <code>odmantic/bson.py</code> <pre><code>class BaseBSONModel(BaseModel):\n    \"\"\"Equivalent of `pydantic.BaseModel` supporting BSON types serialization.\n\n    If you want to apply other custom JSON encoders, you'll need to use\n    [BSON_TYPES_ENCODERS][odmantic.bson.BSON_TYPES_ENCODERS] directly.\n    \"\"\"\n\n    model_config = {\"json_encoders\": BSON_TYPES_ENCODERS}\n</code></pre> <p>Encoders required to encode BSON fields (can be used in the Pydantic Model's <code>Config.json_encoders</code> parameter). See pydantic: JSON Encoders for more details.</p>"},{"location":"api_reference/bson/#custom-bson-serializer-annotation","title":"Custom BSON serializer annotation","text":"<p>Adds a BSON serializer to use on a field when it will be saved to the database</p> Source code in <code>odmantic/bson.py</code> <pre><code>@dataclass(frozen=True)\nclass WithBsonSerializer:\n    \"\"\"Adds a BSON serializer to use on a field when it will be saved to the database\"\"\"\n\n    bson_serializer: Callable[[Any], Any]\n</code></pre>"},{"location":"api_reference/bson/#pydantic-type-helpers","title":"Pydantic type helpers","text":"<p>Those helpers inherit directly from their respective <code>bson</code> types. They add the field validation logic required by Pydantic to work with them. On top of this, the appropriate JSON schemas are generated for them.</p> <p>             Bases: <code>ObjectId</code></p> Source code in <code>odmantic/bson.py</code> <pre><code>class ObjectId(bson.ObjectId):\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        _source_type: Any,\n        _handler: Callable[[Any], core_schema.CoreSchema],\n    ) -&gt; core_schema.CoreSchema:\n        def validate_from_string_or_bytes(value: Union[str, bytes]) -&gt; bson.ObjectId:\n            try:\n                return bson.ObjectId(value)\n            except bson.errors.InvalidId:\n                raise ValueError(\"Invalid ObjectId\")\n\n        from_string_or_bytes_schema = core_schema.chain_schema(\n            [\n                core_schema.union_schema(\n                    [\n                        core_schema.str_schema(),\n                        core_schema.bytes_schema(),\n                    ]\n                ),\n                core_schema.no_info_plain_validator_function(\n                    validate_from_string_or_bytes\n                ),\n            ]\n        )\n\n        return core_schema.json_or_python_schema(\n            json_schema=from_string_or_bytes_schema,\n            python_schema=core_schema.union_schema(\n                [\n                    core_schema.is_instance_schema(bson.ObjectId),\n                    from_string_or_bytes_schema,\n                ],\n            ),\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                str, when_used=\"json\"\n            ),\n        )\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, _schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n    ) -&gt; JsonSchemaValue:\n        json_schema = handler(core_schema.str_schema())\n        json_schema.update(\n            examples=[\"5f85f36d6dfecacc68428a46\", \"ffffffffffffffffffffffff\"],\n            example=\"5f85f36d6dfecacc68428a46\",\n        )\n        return json_schema\n</code></pre> <p>             Bases: <code>Int64</code></p> Source code in <code>odmantic/bson.py</code> <pre><code>class Int64(bson.Int64):\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        _source_type: Any,\n        _handler: Callable[[Any], core_schema.CoreSchema],\n    ) -&gt; core_schema.CoreSchema:\n        def validate_from_int(value: int) -&gt; bson.int64.Int64:\n            return bson.int64.Int64(value)\n\n        from_int_schema = core_schema.chain_schema(\n            [\n                core_schema.int_schema(),\n                core_schema.no_info_plain_validator_function(validate_from_int),\n            ]\n        )\n\n        return core_schema.json_or_python_schema(\n            json_schema=from_int_schema,\n            python_schema=core_schema.union_schema(\n                [\n                    core_schema.is_instance_schema(bson.int64.Int64),\n                    from_int_schema,\n                ]\n            ),\n        )\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, _core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n    ) -&gt; JsonSchemaValue:\n        # Use the same schema that would be used for `int`\n        return handler(core_schema.int_schema())\n</code></pre> <p>             Bases: <code>Decimal128</code></p> Source code in <code>odmantic/bson.py</code> <pre><code>class Decimal128(bson.decimal128.Decimal128):\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        _source_type: Any,\n        _handler: Callable[[Any], core_schema.CoreSchema],\n    ) -&gt; core_schema.CoreSchema:\n        def validate_from_decimal_repr(\n            value: Union[decimal.Decimal, float, str, Tuple[int, Sequence[int], int]],\n        ) -&gt; bson.decimal128.Decimal128:\n            try:\n                return bson.decimal128.Decimal128(value)\n            except Exception:\n                raise ValueError(\"Invalid Decimal128 value\")\n\n        from_decimal_repr_schema = core_schema.no_info_plain_validator_function(\n            validate_from_decimal_repr\n        )\n        return core_schema.json_or_python_schema(\n            json_schema=from_decimal_repr_schema,\n            python_schema=core_schema.union_schema(\n                [\n                    core_schema.is_instance_schema(bson.decimal128.Decimal128),\n                    from_decimal_repr_schema,\n                ]\n            ),\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                lambda v: v.to_decimal(), when_used=\"json\"\n            ),\n        )\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, _core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n    ) -&gt; JsonSchemaValue:\n        return handler(core_schema.float_schema())\n</code></pre> <p>             Bases: <code>Binary</code></p> Source code in <code>odmantic/bson.py</code> <pre><code>class Binary(bson.binary.Binary):\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        _source_type: Any,\n        _handler: Callable[[Any], core_schema.CoreSchema],\n    ) -&gt; core_schema.CoreSchema:\n        def validate_from_bytes(\n            value: bytes,\n        ) -&gt; bson.binary.Binary:\n            return bson.binary.Binary(value)\n\n        from_bytes_schema = core_schema.chain_schema(\n            [\n                core_schema.bytes_schema(),\n                core_schema.no_info_plain_validator_function(validate_from_bytes),\n            ]\n        )\n        return core_schema.json_or_python_schema(\n            json_schema=from_bytes_schema,\n            python_schema=core_schema.union_schema(\n                [\n                    core_schema.is_instance_schema(bson.binary.Binary),\n                    from_bytes_schema,\n                ]\n            ),\n        )\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, _core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n    ) -&gt; JsonSchemaValue:\n        return handler(core_schema.bytes_schema())\n</code></pre> <p>             Bases: <code>Regex</code></p> Source code in <code>odmantic/bson.py</code> <pre><code>class Regex(bson.regex.Regex):\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        _source_type: Any,\n        _handler: Callable[[Any], core_schema.CoreSchema],\n    ) -&gt; core_schema.CoreSchema:\n        from_str_schema = core_schema.chain_schema(\n            [\n                core_schema.str_schema(),\n                core_schema.no_info_plain_validator_function(validate_pattern_from_str),\n                core_schema.no_info_plain_validator_function(\n                    validate_regex_from_pattern\n                ),\n            ]\n        )\n        from_pattern_schema = core_schema.chain_schema(\n            [\n                core_schema.is_instance_schema(Pattern),\n                core_schema.no_info_plain_validator_function(\n                    validate_regex_from_pattern\n                ),\n            ]\n        )\n        return core_schema.json_or_python_schema(\n            json_schema=from_str_schema,\n            python_schema=core_schema.union_schema(\n                [\n                    core_schema.is_instance_schema(bson.regex.Regex),\n                    from_pattern_schema,\n                    from_str_schema,\n                ]\n            ),\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                lambda v: v.pattern, when_used=\"json\"\n            ),\n        )\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, _core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n    ) -&gt; JsonSchemaValue:\n        schema = handler(core_schema.str_schema())\n        schema.update(\n            examples=[r\"^Foo\"], example=r\"^Foo\", type=\"string\", format=\"binary\"\n        )\n        return schema\n</code></pre>"},{"location":"api_reference/config/","title":"odmantic.config","text":"<p>             Bases: <code>ConfigDict</code></p> Source code in <code>odmantic/config.py</code> <pre><code>class ODMConfigDict(ConfigDict, total=False):\n    collection: str | None\n    \"\"\"Customize the collection name associated to the model\"\"\"\n    parse_doc_with_default_factories: bool\n    \"\"\"Wether to allow populating field values with default factories while parsing\n    documents from the database\"\"\"\n    indexes: Callable[[], Iterable[ODMIndex.Index | pymongo.IndexModel]] | None\n    \"\"\"Define additional indexes for the model\"\"\"\n</code></pre>"},{"location":"api_reference/config/#odmantic.config.ODMConfigDict.collection","title":"<code>collection: str | None</code>  <code>instance-attribute</code>","text":"<p>Customize the collection name associated to the model</p>"},{"location":"api_reference/config/#odmantic.config.ODMConfigDict.indexes","title":"<code>indexes: Callable[[], Iterable[ODMIndex.Index | pymongo.IndexModel]] | None</code>  <code>instance-attribute</code>","text":"<p>Define additional indexes for the model</p>"},{"location":"api_reference/config/#odmantic.config.ODMConfigDict.parse_doc_with_default_factories","title":"<code>parse_doc_with_default_factories: bool</code>  <code>instance-attribute</code>","text":"<p>Wether to allow populating field values with default factories while parsing documents from the database</p>"},{"location":"api_reference/engine/","title":"odmantic.engine","text":"<p>             Bases: <code>BaseEngine</code></p> <p>The AIOEngine object is responsible for handling database operations with MongoDB in an asynchronous way using motor.</p> Source code in <code>odmantic/engine.py</code> <pre><code>class AIOEngine(BaseEngine):\n    \"\"\"The AIOEngine object is responsible for handling database operations with MongoDB\n    in an asynchronous way using motor.\n    \"\"\"\n\n    client: \"AsyncIOMotorClient\"\n    database: \"AsyncIOMotorDatabase\"\n\n    def __init__(\n        self,\n        client: Union[\"AsyncIOMotorClient\", None] = None,\n        database: str = \"test\",\n    ):\n        \"\"\"Engine constructor.\n\n        Args:\n            client: instance of an AsyncIO motor client. If None, a default one\n                    will be created\n            database: name of the database to use\n\n        &lt;!---\n        #noqa: DAR401 RuntimeError\n        --&gt;\n        \"\"\"\n        if not motor:\n            raise RuntimeError(\n                \"motor is required to use AIOEngine, install it with:\\n\\n\"\n                + 'pip install \"odmantic[motor]\"'\n            )\n        if client is None:\n            client = AsyncIOMotorClient()\n        super().__init__(client=client, database=database)\n\n    def get_collection(self, model: Type[ModelType]) -&gt; \"AsyncIOMotorCollection\":\n        \"\"\"Get the motor collection associated to a Model.\n\n        Args:\n            model: model class\n\n        Returns:\n            the AsyncIO motor collection object\n        \"\"\"\n        return self.database[model.__collection__]\n\n    @staticmethod\n    def _get_session(\n        session: Union[AIOSessionType, AIOSessionBase],\n    ) -&gt; Optional[AsyncIOMotorClientSession]:\n        if isinstance(session, (AIOSession, AIOTransaction)):\n            return session.get_driver_session()\n        assert not isinstance(session, AIOSessionBase)  # Abstract class\n        return session\n\n    async def configure_database(\n        self,\n        models: Sequence[Type[ModelType]],\n        *,\n        update_existing_indexes: bool = False,\n        session: SyncSessionType = None,\n    ) -&gt; None:\n        \"\"\"Apply model constraints to the database.\n\n        Args:\n            models: list of models to initialize the database with\n            update_existing_indexes: conflicting indexes will be dropped before creation\n            session: an optional session to use for the operation\n\n        &lt;!---\n        #noqa: DAR401 pymongo.errors.OperationFailure\n        --&gt;\n        \"\"\"\n        driver_session = self._get_session(session)\n        for model in models:\n            collection = self.get_collection(model)\n            for index in model.__indexes__():\n                pymongo_index = (\n                    index.get_pymongo_index()\n                    if isinstance(index, ODMBaseIndex)\n                    else index\n                )\n                try:\n                    await collection.create_indexes(\n                        [pymongo_index], session=driver_session\n                    )\n                except pymongo.errors.OperationFailure as exc:\n                    if update_existing_indexes and getattr(exc, \"code\", None) in (\n                        85,  # aka IndexOptionsConflict\n                        86,  # aka IndexKeySpecsConflict for MongoDB &gt; 5\n                    ):\n                        await collection.drop_index(\n                            pymongo_index.document[\"name\"], session=driver_session\n                        )\n                        await collection.create_indexes(\n                            [pymongo_index], session=driver_session\n                        )\n                    else:\n                        raise\n\n    def session(self) -&gt; AIOSession:\n        \"\"\"Get a new session for the engine to allow ordering sequential operations.\n\n        Returns:\n            a new session object\n\n        Example usage:\n\n        ```python\n        engine = AIOEngine(...)\n        async with engine.session() as session:\n            john = await session.find(User, User.name == \"John\")\n            john.name = \"Doe\"\n            await session.save(john)\n        ```\n        \"\"\"\n        return AIOSession(self)\n\n    def transaction(self) -&gt; AIOTransaction:\n        \"\"\"Get a new transaction for the engine to aggregate sequential operations.\n\n        Returns:\n            a new transaction object\n\n        Example usage:\n        ```python\n        engine = AIOEngine(...)\n        async with engine.transaction() as transaction:\n            john = transaction.find(User, User.name == \"John\")\n            john.name = \"Doe\"\n            await transaction.save(john)\n            await transaction.commit()\n        ```\n\n        Warning:\n            MongoDB transaction are only supported on replicated clusters: either\n            directly a replicaSet or a sharded cluster with replication enabled.\n        \"\"\"\n        return AIOTransaction(self)\n\n    def find(\n        self,\n        model: Type[ModelType],\n        *queries: Union[\n            QueryExpression, Dict, bool\n        ],  # bool: allow using binary operators with mypy\n        sort: Optional[Any] = None,\n        skip: int = 0,\n        limit: Optional[int] = None,\n        session: AIOSessionType = None,\n    ) -&gt; AIOCursor[ModelType]:\n        \"\"\"Search for Model instances matching the query filter provided\n\n        Args:\n            model: model to perform the operation on\n            *queries: query filter to apply\n            sort: sort expression\n            skip: number of document to skip\n            limit: maximum number of instance fetched\n            session: an optional session to use for the operation\n\n        Raises:\n            DocumentParsingError: unable to parse one of the resulting documents\n\n        Returns:\n            [odmantic.engine.AIOCursor][] of the query\n\n        &lt;!---\n        #noqa: DAR401 ValueError\n        #noqa: DAR401 TypeError\n        #noqa: DAR402 DocumentParsingError\n        --&gt;\n        \"\"\"\n        pipeline = self._prepare_find_pipeline(\n            model,\n            *queries,\n            sort=sort,\n            skip=skip,\n            limit=limit,\n        )\n        collection = self.get_collection(model)\n        motor_cursor = collection.aggregate(\n            pipeline, session=self._get_session(session)\n        )\n        return AIOCursor(model, motor_cursor)\n\n    async def find_one(\n        self,\n        model: Type[ModelType],\n        *queries: Union[\n            QueryExpression, Dict, bool\n        ],  # bool: allow using binary operators w/o plugin\n        sort: Optional[Any] = None,\n        session: AIOSessionType = None,\n    ) -&gt; Optional[ModelType]:\n        \"\"\"Search for a Model instance matching the query filter provided\n\n        Args:\n            model: model to perform the operation on\n            *queries: query filter to apply\n            sort: sort expression\n            session: an optional session to use for the operation\n\n        Raises:\n            DocumentParsingError: unable to parse the resulting document\n\n        Returns:\n            the fetched instance if found otherwise None\n\n        &lt;!---\n        #noqa: DAR401 TypeError\n        #noqa: DAR402 DocumentParsingError\n        --&gt;\n        \"\"\"\n        if not lenient_issubclass(model, Model):\n            raise TypeError(\"Can only call find_one with a Model class\")\n        results = await self.find(model, *queries, sort=sort, limit=1, session=session)\n        if len(results) == 0:\n            return None\n        return results[0]\n\n    async def _save(\n        self, instance: ModelType, session: \"AsyncIOMotorClientSession\"\n    ) -&gt; ModelType:\n        \"\"\"Perform an atomic save operation in the specified session\"\"\"\n        for ref_field_name in instance.__references__:\n            sub_instance = cast(Model, getattr(instance, ref_field_name))\n            await self._save(sub_instance, session)\n\n        fields_to_update = instance.__fields_modified__ | instance.__mutable_fields__\n        if len(fields_to_update) &gt; 0:\n            doc = instance.model_dump_doc(include=fields_to_update)\n            collection = self.get_collection(type(instance))\n            try:\n                await collection.update_one(\n                    instance.model_dump_doc(include={instance.__primary_field__}),\n                    {\"$set\": doc},\n                    upsert=True,\n                    session=session,\n                )\n            except pymongo.errors.DuplicateKeyError as e:\n                raise DuplicateKeyError(instance, e)\n            object.__setattr__(instance, \"__fields_modified__\", set())\n        return instance\n\n    async def save(\n        self,\n        instance: ModelType,\n        *,\n        session: AIOSessionType = None,\n    ) -&gt; ModelType:\n        \"\"\"Persist an instance to the database\n\n        This method behaves as an 'upsert' operation. If a document already exists\n        with the same primary key, it will be overwritten.\n\n        All the other models referenced by this instance will be saved as well.\n\n        Args:\n            instance: instance to persist\n            session: An optional session to use for the operation. If not provided, an\n                     internal session will be used to persist the instance and\n                     sub-instances.\n\n        Returns:\n            the saved instance\n\n        Raises:\n            DuplicateKeyError: the instance is duplicated according to a unique index.\n\n        NOTE:\n            The save operation actually modify the instance argument in place. However,\n            the instance is still returned for convenience.\n\n        &lt;!---\n        #noqa: DAR401 TypeError\n        #noqa: DAR402 DuplicateKeyError\n        --&gt;\n        \"\"\"\n        if not isinstance(instance, Model):\n            raise TypeError(\"Can only call find_one with a Model class\")\n        if session:\n            await self._save(instance, self._get_session(session))\n        else:\n            async with await self.client.start_session() as local_session:\n                await self._save(instance, local_session)\n        return instance\n\n    async def save_all(\n        self,\n        instances: Sequence[ModelType],\n        *,\n        session: AIOSessionType = None,\n    ) -&gt; List[ModelType]:\n        \"\"\"Persist instances to the database\n\n        This method behaves as multiple 'upsert' operations. If one of the document\n        already exists with the same primary key, it will be overwritten.\n\n        All the other models referenced by this instance will be recursively saved as\n        well.\n\n        Args:\n            instances: instances to persist\n            session: An optional session to use for the operation. If not provided, an\n                     internal session will be used to persist the instances.\n\n        Returns:\n            the saved instances\n\n        Raises:\n            DuplicateKeyError: an instance is duplicated according to a unique index.\n\n        NOTE:\n            The save_all operation actually modify the arguments in place. However, the\n            instances are still returned for convenience.\n\n        &lt;!---\n        #noqa: DAR402 DuplicateKeyError\n        --&gt;\n        \"\"\"\n        if session:\n            added_instances = [\n                await self._save(instance, self._get_session(session))\n                for instance in instances\n            ]\n        else:\n            async with await self.client.start_session() as local_session:\n                added_instances = [\n                    await self._save(instance, local_session) for instance in instances\n                ]\n        return added_instances\n\n    async def delete(\n        self,\n        instance: ModelType,\n        *,\n        session: AIOSessionType = None,\n    ) -&gt; None:\n        \"\"\"Delete an instance from the database\n\n        Args:\n            instance: the instance to delete\n            session: an optional session to use for the operation\n\n\n        Raises:\n            DocumentNotFoundError: the instance has not been persisted to the database\n        \"\"\"\n        # TODO handle cascade deletion\n        collection = self.database[instance.__collection__]\n        pk_name = instance.__primary_field__\n        result = await collection.delete_many(\n            {\"_id\": getattr(instance, pk_name)}, session=self._get_session(session)\n        )\n        count = int(result.deleted_count)\n        if count == 0:\n            raise DocumentNotFoundError(instance)\n\n    async def remove(\n        self,\n        model: Type[ModelType],\n        *queries: Union[QueryExpression, Dict, bool],\n        just_one: bool = False,\n        session: AIOSessionType = None,\n    ) -&gt; int:\n        \"\"\"Delete Model instances matching the query filter provided\n\n        Args:\n            model: model to perform the operation on\n            *queries: query filter to apply\n            just_one: limit the deletion to just one document\n            session: an optional session to use for the operation\n\n        Returns:\n            the number of instances deleted from the database.\n\n        \"\"\"\n        query = AIOEngine._build_query(*queries)\n        collection = self.get_collection(model)\n\n        if just_one:\n            result = await collection.delete_one(\n                query, session=self._get_session(session)\n            )\n        else:\n            result = await collection.delete_many(\n                query, session=self._get_session(session)\n            )\n\n        return cast(int, result.deleted_count)\n\n    async def count(\n        self,\n        model: Type[ModelType],\n        *queries: Union[QueryExpression, Dict, bool],\n        session: AIOSessionType = None,\n    ) -&gt; int:\n        \"\"\"Get the count of documents matching a query\n\n        Args:\n            model: model to perform the operation on\n            *queries: query filters to apply\n            session: an optional session to use for the operation\n\n        Returns:\n            number of document matching the query\n\n        &lt;!---\n        #noqa: DAR401 TypeError\n        --&gt;\n        \"\"\"\n        if not lenient_issubclass(model, Model):\n            raise TypeError(\"Can only call count with a Model class\")\n        query = BaseEngine._build_query(*queries)\n        collection = self.database[model.__collection__]\n        count = await collection.count_documents(\n            query, session=self._get_session(session)\n        )\n        return int(count)\n</code></pre> <p>             Bases: <code>BaseCursor[ModelType]</code>, <code>AsyncIterable[ModelType]</code>, <code>Awaitable[List[ModelType]]</code></p> <p>This object has to be built from the odmantic.engine.AIOEngine.find method.</p> <p>An AIOCursor object support multiple async operations:</p> <ul> <li>async for: asynchronously iterate over the query results</li> <li>await : when awaited it will return a list of the fetched models</li> </ul> Source code in <code>odmantic/engine.py</code> <pre><code>class AIOCursor(\n    BaseCursor[ModelType], AsyncIterable[ModelType], Awaitable[List[ModelType]]\n):\n    \"\"\"This object has to be built from the [odmantic.engine.AIOEngine.find][] method.\n\n    An AIOCursor object support multiple async operations:\n\n      - **async for**: asynchronously iterate over the query results\n      - **await** : when awaited it will return a list of the fetched models\n    \"\"\"\n\n    _cursor: \"AsyncIOMotorCursor\"\n\n    def __init__(self, model: Type[ModelType], cursor: \"AsyncIOMotorCursor\"):\n        super().__init__(model=model, cursor=cursor)\n\n    def __await__(self) -&gt; Generator[None, None, List[ModelType]]:\n        if self._results is not None:\n            return self._results\n        raw_docs = yield from self._cursor.to_list(length=None).__await__()\n        instances = []\n        for raw_doc in raw_docs:\n            instances.append(self._parse_document(raw_doc))\n            yield\n        self._results = instances\n        return instances\n\n    async def __aiter__(self) -&gt; AsyncGenerator[ModelType, None]:\n        if self._results is not None:\n            for res in self._results:\n                yield res\n            return\n        results = []\n        async for raw_doc in self._cursor:\n            instance = self._parse_document(raw_doc)\n            results.append(instance)\n            yield instance\n        self._results = results\n</code></pre> <p>             Bases: <code>BaseEngine</code></p> <p>The SyncEngine object is responsible for handling database operations with MongoDB in an synchronous way using pymongo.</p> Source code in <code>odmantic/engine.py</code> <pre><code>class SyncEngine(BaseEngine):\n    \"\"\"The SyncEngine object is responsible for handling database operations with\n    MongoDB in an synchronous way using pymongo.\n    \"\"\"\n\n    client: \"MongoClient\"\n    database: \"Database\"\n\n    def __init__(\n        self,\n        client: \"Union[MongoClient, None]\" = None,\n        database: str = \"test\",\n    ):\n        \"\"\"Engine constructor.\n\n        Args:\n            client: instance of a PyMongo client. If None, a default one\n                    will be created\n            database: name of the database to use\n        \"\"\"\n        if client is None:\n            client = MongoClient()\n        super().__init__(client=client, database=database)\n\n    def get_collection(self, model: Type[ModelType]) -&gt; \"Collection\":\n        \"\"\"Get the pymongo collection associated to a Model.\n\n        Args:\n            model: model class\n\n        Returns:\n            the pymongo collection object\n        \"\"\"\n        collection = self.database[model.__collection__]\n        return collection\n\n    @staticmethod\n    def _get_session(\n        session: Union[SyncSessionType, SyncSessionBase],\n    ) -&gt; Optional[ClientSession]:\n        if isinstance(session, (SyncSession, SyncTransaction)):\n            return session.get_driver_session()\n        assert not isinstance(session, SyncSessionBase)  # Abstract class\n        return session\n\n    def configure_database(\n        self,\n        models: Sequence[Type[ModelType]],\n        *,\n        update_existing_indexes: bool = False,\n        session: SyncSessionType = None,\n    ) -&gt; None:\n        \"\"\"Apply model constraints to the database.\n\n        Args:\n            models: list of models to initialize the database with\n            update_existing_indexes: conflicting indexes will be dropped before creation\n            session: an optional session to use for the operation\n\n        &lt;!---\n        #noqa: DAR401 pymongo.errors.OperationFailure\n        --&gt;\n        \"\"\"\n        driver_session = self._get_session(session)\n        for model in models:\n            collection = self.get_collection(model)\n            for index in model.__indexes__():\n                pymongo_index = (\n                    index.get_pymongo_index()\n                    if isinstance(index, ODMBaseIndex)\n                    else index\n                )\n                try:\n                    collection.create_indexes([pymongo_index], session=driver_session)\n                except pymongo.errors.OperationFailure as exc:\n                    if update_existing_indexes and getattr(exc, \"code\", None) in (\n                        85,  # aka IndexOptionsConflict\n                        86,  # aka IndexKeySpecsConflict for MongoDB &gt; 5\n                    ):\n                        collection.drop_index(\n                            pymongo_index.document[\"name\"], session=driver_session\n                        )\n                        collection.create_indexes(\n                            [pymongo_index], session=driver_session\n                        )\n                    else:\n                        raise\n\n    def session(self) -&gt; SyncSession:\n        \"\"\"Get a new session for the engine to allow ordering sequential operations.\n\n        Returns:\n            a new session object\n\n        Example usage:\n\n        ```python\n        engine = SyncEngine(...)\n        with engine.session() as session:\n            john = session.find(User, User.name == \"John\")\n            john.name = \"Doe\"\n            session.save(john)\n        ```\n        \"\"\"\n        return SyncSession(self)\n\n    def transaction(self) -&gt; SyncTransaction:\n        \"\"\"Get a new transaction for the engine to aggregate sequential operations.\n\n        Returns:\n            a new transaction object\n\n        Example usage:\n        ```python\n        engine = SyncEngine(...)\n        with engine.transaction() as transaction:\n            john = transaction.find(User, User.name == \"John\")\n            john.name = \"Doe\"\n            transaction.save(john)\n            transaction.commit()\n        ```\n\n        Warning:\n            MongoDB transaction are only supported on replicated clusters: either\n            directly a replicaSet or a sharded cluster with replication enabled.\n        \"\"\"\n        return SyncTransaction(self)\n\n    def find(\n        self,\n        model: Type[ModelType],\n        *queries: Union[\n            QueryExpression, Dict, bool\n        ],  # bool: allow using binary operators with mypy\n        sort: Optional[Any] = None,\n        skip: int = 0,\n        limit: Optional[int] = None,\n        session: SyncSessionType = None,\n    ) -&gt; SyncCursor[ModelType]:\n        \"\"\"Search for Model instances matching the query filter provided\n\n        Args:\n            model: model to perform the operation on\n            *queries: query filter to apply\n            sort: sort expression\n            skip: number of document to skip\n            limit: maximum number of instance fetched\n            session: an optional session to use for the operation\n\n        Raises:\n            DocumentParsingError: unable to parse one of the resulting documents\n\n        Returns:\n            [odmantic.engine.SyncCursor][] of the query\n\n        &lt;!---\n        #noqa: DAR401 ValueError\n        #noqa: DAR401 TypeError\n        #noqa: DAR402 DocumentParsingError\n        --&gt;\n        \"\"\"\n        pipeline = self._prepare_find_pipeline(\n            model,\n            *queries,\n            sort=sort,\n            skip=skip,\n            limit=limit,\n        )\n        collection = self.get_collection(model)\n        cursor = collection.aggregate(pipeline, session=self._get_session(session))\n        return SyncCursor(model, cursor)\n\n    def find_one(\n        self,\n        model: Type[ModelType],\n        *queries: Union[\n            QueryExpression, Dict, bool\n        ],  # bool: allow using binary operators w/o plugin\n        sort: Optional[Any] = None,\n        session: SyncSessionType = None,\n    ) -&gt; Optional[ModelType]:\n        \"\"\"Search for a Model instance matching the query filter provided\n\n        Args:\n            model: model to perform the operation on\n            *queries: query filter to apply\n            sort: sort expression\n            session: an optional session to use for the operation\n\n        Raises:\n            DocumentParsingError: unable to parse the resulting document\n\n        Returns:\n            the fetched instance if found otherwise None\n\n        &lt;!---\n        #noqa: DAR401 TypeError\n        #noqa: DAR402 DocumentParsingError\n        --&gt;\n        \"\"\"\n        if not lenient_issubclass(model, Model):\n            raise TypeError(\"Can only call find_one with a Model class\")\n        results = list(self.find(model, *queries, sort=sort, limit=1, session=session))\n        if len(results) == 0:\n            return None\n        return results[0]\n\n    def _save(self, instance: ModelType, session: \"ClientSession\") -&gt; ModelType:\n        \"\"\"Perform an atomic save operation in the specified session\"\"\"\n        for ref_field_name in instance.__references__:\n            sub_instance = cast(Model, getattr(instance, ref_field_name))\n            self._save(sub_instance, session)\n\n        fields_to_update = instance.__fields_modified__ | instance.__mutable_fields__\n        if len(fields_to_update) &gt; 0:\n            doc = instance.model_dump_doc(include=fields_to_update)\n            collection = self.get_collection(type(instance))\n            try:\n                collection.update_one(\n                    instance.model_dump_doc(include={instance.__primary_field__}),\n                    {\"$set\": doc},\n                    upsert=True,\n                    session=session,\n                )\n            except pymongo.errors.DuplicateKeyError as e:\n                raise DuplicateKeyError(instance, e)\n            object.__setattr__(instance, \"__fields_modified__\", set())\n        return instance\n\n    def save(\n        self,\n        instance: ModelType,\n        *,\n        session: SyncSessionType = None,\n    ) -&gt; ModelType:\n        \"\"\"Persist an instance to the database\n\n        This method behaves as an 'upsert' operation. If a document already exists\n        with the same primary key, it will be overwritten.\n\n        All the other models referenced by this instance will be saved as well.\n\n        Args:\n            instance: instance to persist\n            session: An optional session to use for the operation. If not provided, an\n                     internal session will be used to persist the instance and\n                     sub-instances.\n\n        Returns:\n            the saved instance\n\n        Raises:\n            DuplicateKeyError: the instance is duplicated according to a unique index.\n\n        NOTE:\n            The save operation actually modify the instance argument in place. However,\n            the instance is still returned for convenience.\n\n        &lt;!---\n        #noqa: DAR401 TypeError\n        #noqa: DAR402 DuplicateKeyError\n        --&gt;\n        \"\"\"\n        if not isinstance(instance, Model):\n            raise TypeError(\"Can only call find_one with a Model class\")\n\n        if session:\n            self._save(instance, self._get_session(session))  # type: ignore\n        else:\n            with self.client.start_session() as local_session:\n                self._save(instance, local_session)\n        return instance\n\n    def save_all(\n        self,\n        instances: Sequence[ModelType],\n        *,\n        session: SyncSessionType = None,\n    ) -&gt; List[ModelType]:\n        \"\"\"Persist instances to the database\n\n        This method behaves as multiple 'upsert' operations. If one of the document\n        already exists with the same primary key, it will be overwritten.\n\n        All the other models referenced by this instance will be recursively saved as\n        well.\n\n        Args:\n            instances: instances to persist\n            session: An optional session to use for the operation. If not provided an\n                     internal session will be used to persist the instances.\n\n        Returns:\n            the saved instances\n\n        Raises:\n            DuplicateKeyError: an instance is duplicated according to a unique index.\n\n        NOTE:\n            The save_all operation actually modify the arguments in place. However, the\n            instances are still returned for convenience.\n        &lt;!---\n        #noqa: DAR402 DuplicateKeyError\n        --&gt;\n        \"\"\"\n        if session:\n            added_instances = [\n                self._save(instance, self._get_session(session))  # type: ignore\n                for instance in instances\n            ]\n        else:\n            with self.client.start_session() as local_session:\n                added_instances = [\n                    self._save(instance, local_session) for instance in instances\n                ]\n        return added_instances\n\n    def delete(\n        self,\n        instance: ModelType,\n        session: SyncSessionType = None,\n    ) -&gt; None:\n        \"\"\"Delete an instance from the database\n\n        Args:\n            instance: the instance to delete\n            session: an optional session to use for the operation\n\n        Raises:\n            DocumentNotFoundError: the instance has not been persisted to the database\n\n        \"\"\"\n        # TODO handle cascade deletion\n        collection = self.database[instance.__collection__]\n        pk_name = instance.__primary_field__\n        result = collection.delete_many(\n            {\"_id\": getattr(instance, pk_name)}, session=self._get_session(session)\n        )\n        count = result.deleted_count\n        if count == 0:\n            raise DocumentNotFoundError(instance)\n\n    def remove(\n        self,\n        model: Type[ModelType],\n        *queries: Union[QueryExpression, Dict, bool],\n        just_one: bool = False,\n        session: SyncSessionType = None,\n    ) -&gt; int:\n        \"\"\"Delete Model instances matching the query filter provided\n\n        Args:\n            model: model to perform the operation on\n            *queries: query filter to apply\n            just_one: limit the deletion to just one document\n            session: an optional session to use for the operation\n\n        Returns:\n            the number of instances deleted from the database.\n        \"\"\"\n        query = SyncEngine._build_query(*queries)\n        collection = self.get_collection(model)\n\n        if just_one:\n            result = collection.delete_one(query, session=self._get_session(session))\n        else:\n            result = collection.delete_many(query, session=self._get_session(session))\n\n        return result.deleted_count\n\n    def count(\n        self,\n        model: Type[ModelType],\n        *queries: Union[QueryExpression, Dict, bool],\n        session: SyncSessionType = None,\n    ) -&gt; int:\n        \"\"\"Get the count of documents matching a query\n\n        Args:\n            model: model to perform the operation on\n            *queries: query filters to apply\n            session: an optional session to use for the operation\n\n        Returns:\n            number of document matching the query\n\n        &lt;!---\n        #noqa: DAR401 TypeError\n        --&gt;\n        \"\"\"\n        if not lenient_issubclass(model, Model):\n            raise TypeError(\"Can only call count with a Model class\")\n        query = BaseEngine._build_query(*queries)\n        collection = self.database[model.__collection__]\n        count = collection.count_documents(query, session=self._get_session(session))\n        return int(count)\n</code></pre> <p>             Bases: <code>BaseCursor[ModelType]</code>, <code>Iterable[ModelType]</code></p> <p>This object has to be built from the odmantic.engine.SyncEngine.find method.</p> <p>A SyncCursor object supports iterating over the query results using <code>for</code>.</p> <p>To get a list of all the results you can wrap it with <code>list</code>, as in <code>list(cursor)</code>.</p> Source code in <code>odmantic/engine.py</code> <pre><code>class SyncCursor(BaseCursor[ModelType], Iterable[ModelType]):\n    \"\"\"This object has to be built from the [odmantic.engine.SyncEngine.find][] method.\n\n    A SyncCursor object supports iterating over the query results using **`for`**.\n\n    To get a list of all the results you can wrap it with `list`, as in `list(cursor)`.\n    \"\"\"\n\n    _cursor: \"CommandCursor\"\n\n    def __init__(self, model: Type[ModelType], cursor: \"CommandCursor\"):\n        super().__init__(model=model, cursor=cursor)\n\n    def __iter__(self) -&gt; Iterator[ModelType]:\n        if self._results is not None:\n            for res in self._results:\n                yield res\n            return\n        results = []\n        for raw_doc in self._cursor:\n            instance = self._parse_document(raw_doc)\n            results.append(instance)\n            yield instance\n        self._results = results\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.__init__","title":"<code>__init__(client=None, database='test')</code>","text":"<p>Engine constructor.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Union[AsyncIOMotorClient, None]</code> <p>instance of an AsyncIO motor client. If None, a default one     will be created</p> <code>None</code> <code>database</code> <code>str</code> <p>name of the database to use</p> <code>'test'</code> Source code in <code>odmantic/engine.py</code> <pre><code>def __init__(\n    self,\n    client: Union[\"AsyncIOMotorClient\", None] = None,\n    database: str = \"test\",\n):\n    \"\"\"Engine constructor.\n\n    Args:\n        client: instance of an AsyncIO motor client. If None, a default one\n                will be created\n        database: name of the database to use\n\n    &lt;!---\n    #noqa: DAR401 RuntimeError\n    --&gt;\n    \"\"\"\n    if not motor:\n        raise RuntimeError(\n            \"motor is required to use AIOEngine, install it with:\\n\\n\"\n            + 'pip install \"odmantic[motor]\"'\n        )\n    if client is None:\n        client = AsyncIOMotorClient()\n    super().__init__(client=client, database=database)\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.configure_database","title":"<code>configure_database(models, *, update_existing_indexes=False, session=None)</code>  <code>async</code>","text":"<p>Apply model constraints to the database.</p> <p>Parameters:</p> Name Type Description Default <code>models</code> <code>Sequence[Type[ModelType]]</code> <p>list of models to initialize the database with</p> required <code>update_existing_indexes</code> <code>bool</code> <p>conflicting indexes will be dropped before creation</p> <code>False</code> <code>session</code> <code>SyncSessionType</code> <p>an optional session to use for the operation</p> <code>None</code> Source code in <code>odmantic/engine.py</code> <pre><code>async def configure_database(\n    self,\n    models: Sequence[Type[ModelType]],\n    *,\n    update_existing_indexes: bool = False,\n    session: SyncSessionType = None,\n) -&gt; None:\n    \"\"\"Apply model constraints to the database.\n\n    Args:\n        models: list of models to initialize the database with\n        update_existing_indexes: conflicting indexes will be dropped before creation\n        session: an optional session to use for the operation\n\n    &lt;!---\n    #noqa: DAR401 pymongo.errors.OperationFailure\n    --&gt;\n    \"\"\"\n    driver_session = self._get_session(session)\n    for model in models:\n        collection = self.get_collection(model)\n        for index in model.__indexes__():\n            pymongo_index = (\n                index.get_pymongo_index()\n                if isinstance(index, ODMBaseIndex)\n                else index\n            )\n            try:\n                await collection.create_indexes(\n                    [pymongo_index], session=driver_session\n                )\n            except pymongo.errors.OperationFailure as exc:\n                if update_existing_indexes and getattr(exc, \"code\", None) in (\n                    85,  # aka IndexOptionsConflict\n                    86,  # aka IndexKeySpecsConflict for MongoDB &gt; 5\n                ):\n                    await collection.drop_index(\n                        pymongo_index.document[\"name\"], session=driver_session\n                    )\n                    await collection.create_indexes(\n                        [pymongo_index], session=driver_session\n                    )\n                else:\n                    raise\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.count","title":"<code>count(model, *queries, session=None)</code>  <code>async</code>","text":"<p>Get the count of documents matching a query</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[ModelType]</code> <p>model to perform the operation on</p> required <code>*queries</code> <code>Union[QueryExpression, Dict, bool]</code> <p>query filters to apply</p> <code>()</code> <code>session</code> <code>AIOSessionType</code> <p>an optional session to use for the operation</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>number of document matching the query</p> Source code in <code>odmantic/engine.py</code> <pre><code>async def count(\n    self,\n    model: Type[ModelType],\n    *queries: Union[QueryExpression, Dict, bool],\n    session: AIOSessionType = None,\n) -&gt; int:\n    \"\"\"Get the count of documents matching a query\n\n    Args:\n        model: model to perform the operation on\n        *queries: query filters to apply\n        session: an optional session to use for the operation\n\n    Returns:\n        number of document matching the query\n\n    &lt;!---\n    #noqa: DAR401 TypeError\n    --&gt;\n    \"\"\"\n    if not lenient_issubclass(model, Model):\n        raise TypeError(\"Can only call count with a Model class\")\n    query = BaseEngine._build_query(*queries)\n    collection = self.database[model.__collection__]\n    count = await collection.count_documents(\n        query, session=self._get_session(session)\n    )\n    return int(count)\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.delete","title":"<code>delete(instance, *, session=None)</code>  <code>async</code>","text":"<p>Delete an instance from the database</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>ModelType</code> <p>the instance to delete</p> required <code>session</code> <code>AIOSessionType</code> <p>an optional session to use for the operation</p> <code>None</code> <p>Raises:</p> Type Description <code>DocumentNotFoundError</code> <p>the instance has not been persisted to the database</p> Source code in <code>odmantic/engine.py</code> <pre><code>async def delete(\n    self,\n    instance: ModelType,\n    *,\n    session: AIOSessionType = None,\n) -&gt; None:\n    \"\"\"Delete an instance from the database\n\n    Args:\n        instance: the instance to delete\n        session: an optional session to use for the operation\n\n\n    Raises:\n        DocumentNotFoundError: the instance has not been persisted to the database\n    \"\"\"\n    # TODO handle cascade deletion\n    collection = self.database[instance.__collection__]\n    pk_name = instance.__primary_field__\n    result = await collection.delete_many(\n        {\"_id\": getattr(instance, pk_name)}, session=self._get_session(session)\n    )\n    count = int(result.deleted_count)\n    if count == 0:\n        raise DocumentNotFoundError(instance)\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.find","title":"<code>find(model, *queries, sort=None, skip=0, limit=None, session=None)</code>","text":"<p>Search for Model instances matching the query filter provided</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[ModelType]</code> <p>model to perform the operation on</p> required <code>*queries</code> <code>Union[QueryExpression, Dict, bool]</code> <p>query filter to apply</p> <code>()</code> <code>sort</code> <code>Optional[Any]</code> <p>sort expression</p> <code>None</code> <code>skip</code> <code>int</code> <p>number of document to skip</p> <code>0</code> <code>limit</code> <code>Optional[int]</code> <p>maximum number of instance fetched</p> <code>None</code> <code>session</code> <code>AIOSessionType</code> <p>an optional session to use for the operation</p> <code>None</code> <p>Raises:</p> Type Description <code>DocumentParsingError</code> <p>unable to parse one of the resulting documents</p> <p>Returns:</p> Type Description <code>AIOCursor[ModelType]</code> <p>odmantic.engine.AIOCursor of the query</p> Source code in <code>odmantic/engine.py</code> <pre><code>def find(\n    self,\n    model: Type[ModelType],\n    *queries: Union[\n        QueryExpression, Dict, bool\n    ],  # bool: allow using binary operators with mypy\n    sort: Optional[Any] = None,\n    skip: int = 0,\n    limit: Optional[int] = None,\n    session: AIOSessionType = None,\n) -&gt; AIOCursor[ModelType]:\n    \"\"\"Search for Model instances matching the query filter provided\n\n    Args:\n        model: model to perform the operation on\n        *queries: query filter to apply\n        sort: sort expression\n        skip: number of document to skip\n        limit: maximum number of instance fetched\n        session: an optional session to use for the operation\n\n    Raises:\n        DocumentParsingError: unable to parse one of the resulting documents\n\n    Returns:\n        [odmantic.engine.AIOCursor][] of the query\n\n    &lt;!---\n    #noqa: DAR401 ValueError\n    #noqa: DAR401 TypeError\n    #noqa: DAR402 DocumentParsingError\n    --&gt;\n    \"\"\"\n    pipeline = self._prepare_find_pipeline(\n        model,\n        *queries,\n        sort=sort,\n        skip=skip,\n        limit=limit,\n    )\n    collection = self.get_collection(model)\n    motor_cursor = collection.aggregate(\n        pipeline, session=self._get_session(session)\n    )\n    return AIOCursor(model, motor_cursor)\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.find_one","title":"<code>find_one(model, *queries, sort=None, session=None)</code>  <code>async</code>","text":"<p>Search for a Model instance matching the query filter provided</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[ModelType]</code> <p>model to perform the operation on</p> required <code>*queries</code> <code>Union[QueryExpression, Dict, bool]</code> <p>query filter to apply</p> <code>()</code> <code>sort</code> <code>Optional[Any]</code> <p>sort expression</p> <code>None</code> <code>session</code> <code>AIOSessionType</code> <p>an optional session to use for the operation</p> <code>None</code> <p>Raises:</p> Type Description <code>DocumentParsingError</code> <p>unable to parse the resulting document</p> <p>Returns:</p> Type Description <code>Optional[ModelType]</code> <p>the fetched instance if found otherwise None</p> Source code in <code>odmantic/engine.py</code> <pre><code>async def find_one(\n    self,\n    model: Type[ModelType],\n    *queries: Union[\n        QueryExpression, Dict, bool\n    ],  # bool: allow using binary operators w/o plugin\n    sort: Optional[Any] = None,\n    session: AIOSessionType = None,\n) -&gt; Optional[ModelType]:\n    \"\"\"Search for a Model instance matching the query filter provided\n\n    Args:\n        model: model to perform the operation on\n        *queries: query filter to apply\n        sort: sort expression\n        session: an optional session to use for the operation\n\n    Raises:\n        DocumentParsingError: unable to parse the resulting document\n\n    Returns:\n        the fetched instance if found otherwise None\n\n    &lt;!---\n    #noqa: DAR401 TypeError\n    #noqa: DAR402 DocumentParsingError\n    --&gt;\n    \"\"\"\n    if not lenient_issubclass(model, Model):\n        raise TypeError(\"Can only call find_one with a Model class\")\n    results = await self.find(model, *queries, sort=sort, limit=1, session=session)\n    if len(results) == 0:\n        return None\n    return results[0]\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.get_collection","title":"<code>get_collection(model)</code>","text":"<p>Get the motor collection associated to a Model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[ModelType]</code> <p>model class</p> required <p>Returns:</p> Type Description <code>AsyncIOMotorCollection</code> <p>the AsyncIO motor collection object</p> Source code in <code>odmantic/engine.py</code> <pre><code>def get_collection(self, model: Type[ModelType]) -&gt; \"AsyncIOMotorCollection\":\n    \"\"\"Get the motor collection associated to a Model.\n\n    Args:\n        model: model class\n\n    Returns:\n        the AsyncIO motor collection object\n    \"\"\"\n    return self.database[model.__collection__]\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.remove","title":"<code>remove(model, *queries, just_one=False, session=None)</code>  <code>async</code>","text":"<p>Delete Model instances matching the query filter provided</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[ModelType]</code> <p>model to perform the operation on</p> required <code>*queries</code> <code>Union[QueryExpression, Dict, bool]</code> <p>query filter to apply</p> <code>()</code> <code>just_one</code> <code>bool</code> <p>limit the deletion to just one document</p> <code>False</code> <code>session</code> <code>AIOSessionType</code> <p>an optional session to use for the operation</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>the number of instances deleted from the database.</p> Source code in <code>odmantic/engine.py</code> <pre><code>async def remove(\n    self,\n    model: Type[ModelType],\n    *queries: Union[QueryExpression, Dict, bool],\n    just_one: bool = False,\n    session: AIOSessionType = None,\n) -&gt; int:\n    \"\"\"Delete Model instances matching the query filter provided\n\n    Args:\n        model: model to perform the operation on\n        *queries: query filter to apply\n        just_one: limit the deletion to just one document\n        session: an optional session to use for the operation\n\n    Returns:\n        the number of instances deleted from the database.\n\n    \"\"\"\n    query = AIOEngine._build_query(*queries)\n    collection = self.get_collection(model)\n\n    if just_one:\n        result = await collection.delete_one(\n            query, session=self._get_session(session)\n        )\n    else:\n        result = await collection.delete_many(\n            query, session=self._get_session(session)\n        )\n\n    return cast(int, result.deleted_count)\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.save","title":"<code>save(instance, *, session=None)</code>  <code>async</code>","text":"<p>Persist an instance to the database</p> <p>This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten.</p> <p>All the other models referenced by this instance will be saved as well.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>ModelType</code> <p>instance to persist</p> required <code>session</code> <code>AIOSessionType</code> <p>An optional session to use for the operation. If not provided, an      internal session will be used to persist the instance and      sub-instances.</p> <code>None</code> <p>Returns:</p> Type Description <code>ModelType</code> <p>the saved instance</p> <p>Raises:</p> Type Description <code>DuplicateKeyError</code> <p>the instance is duplicated according to a unique index.</p> NOTE <p>The save operation actually modify the instance argument in place. However, the instance is still returned for convenience.</p> Source code in <code>odmantic/engine.py</code> <pre><code>async def save(\n    self,\n    instance: ModelType,\n    *,\n    session: AIOSessionType = None,\n) -&gt; ModelType:\n    \"\"\"Persist an instance to the database\n\n    This method behaves as an 'upsert' operation. If a document already exists\n    with the same primary key, it will be overwritten.\n\n    All the other models referenced by this instance will be saved as well.\n\n    Args:\n        instance: instance to persist\n        session: An optional session to use for the operation. If not provided, an\n                 internal session will be used to persist the instance and\n                 sub-instances.\n\n    Returns:\n        the saved instance\n\n    Raises:\n        DuplicateKeyError: the instance is duplicated according to a unique index.\n\n    NOTE:\n        The save operation actually modify the instance argument in place. However,\n        the instance is still returned for convenience.\n\n    &lt;!---\n    #noqa: DAR401 TypeError\n    #noqa: DAR402 DuplicateKeyError\n    --&gt;\n    \"\"\"\n    if not isinstance(instance, Model):\n        raise TypeError(\"Can only call find_one with a Model class\")\n    if session:\n        await self._save(instance, self._get_session(session))\n    else:\n        async with await self.client.start_session() as local_session:\n            await self._save(instance, local_session)\n    return instance\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.save_all","title":"<code>save_all(instances, *, session=None)</code>  <code>async</code>","text":"<p>Persist instances to the database</p> <p>This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten.</p> <p>All the other models referenced by this instance will be recursively saved as well.</p> <p>Parameters:</p> Name Type Description Default <code>instances</code> <code>Sequence[ModelType]</code> <p>instances to persist</p> required <code>session</code> <code>AIOSessionType</code> <p>An optional session to use for the operation. If not provided, an      internal session will be used to persist the instances.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[ModelType]</code> <p>the saved instances</p> <p>Raises:</p> Type Description <code>DuplicateKeyError</code> <p>an instance is duplicated according to a unique index.</p> NOTE <p>The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience.</p> Source code in <code>odmantic/engine.py</code> <pre><code>async def save_all(\n    self,\n    instances: Sequence[ModelType],\n    *,\n    session: AIOSessionType = None,\n) -&gt; List[ModelType]:\n    \"\"\"Persist instances to the database\n\n    This method behaves as multiple 'upsert' operations. If one of the document\n    already exists with the same primary key, it will be overwritten.\n\n    All the other models referenced by this instance will be recursively saved as\n    well.\n\n    Args:\n        instances: instances to persist\n        session: An optional session to use for the operation. If not provided, an\n                 internal session will be used to persist the instances.\n\n    Returns:\n        the saved instances\n\n    Raises:\n        DuplicateKeyError: an instance is duplicated according to a unique index.\n\n    NOTE:\n        The save_all operation actually modify the arguments in place. However, the\n        instances are still returned for convenience.\n\n    &lt;!---\n    #noqa: DAR402 DuplicateKeyError\n    --&gt;\n    \"\"\"\n    if session:\n        added_instances = [\n            await self._save(instance, self._get_session(session))\n            for instance in instances\n        ]\n    else:\n        async with await self.client.start_session() as local_session:\n            added_instances = [\n                await self._save(instance, local_session) for instance in instances\n            ]\n    return added_instances\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.session","title":"<code>session()</code>","text":"<p>Get a new session for the engine to allow ordering sequential operations.</p> <p>Returns:</p> Type Description <code>AIOSession</code> <p>a new session object</p> <p>Example usage:</p> <pre><code>engine = AIOEngine(...)\nasync with engine.session() as session:\n    john = await session.find(User, User.name == \"John\")\n    john.name = \"Doe\"\n    await session.save(john)\n</code></pre> Source code in <code>odmantic/engine.py</code> <pre><code>def session(self) -&gt; AIOSession:\n    \"\"\"Get a new session for the engine to allow ordering sequential operations.\n\n    Returns:\n        a new session object\n\n    Example usage:\n\n    ```python\n    engine = AIOEngine(...)\n    async with engine.session() as session:\n        john = await session.find(User, User.name == \"John\")\n        john.name = \"Doe\"\n        await session.save(john)\n    ```\n    \"\"\"\n    return AIOSession(self)\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.transaction","title":"<code>transaction()</code>","text":"<p>Get a new transaction for the engine to aggregate sequential operations.</p> <p>Returns:</p> Type Description <code>AIOTransaction</code> <p>a new transaction object</p> <p>Example usage: <pre><code>engine = AIOEngine(...)\nasync with engine.transaction() as transaction:\n    john = transaction.find(User, User.name == \"John\")\n    john.name = \"Doe\"\n    await transaction.save(john)\n    await transaction.commit()\n</code></pre></p> Warning <p>MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled.</p> Source code in <code>odmantic/engine.py</code> <pre><code>def transaction(self) -&gt; AIOTransaction:\n    \"\"\"Get a new transaction for the engine to aggregate sequential operations.\n\n    Returns:\n        a new transaction object\n\n    Example usage:\n    ```python\n    engine = AIOEngine(...)\n    async with engine.transaction() as transaction:\n        john = transaction.find(User, User.name == \"John\")\n        john.name = \"Doe\"\n        await transaction.save(john)\n        await transaction.commit()\n    ```\n\n    Warning:\n        MongoDB transaction are only supported on replicated clusters: either\n        directly a replicaSet or a sharded cluster with replication enabled.\n    \"\"\"\n    return AIOTransaction(self)\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.__init__","title":"<code>__init__(client=None, database='test')</code>","text":"<p>Engine constructor.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Union[MongoClient, None]</code> <p>instance of a PyMongo client. If None, a default one     will be created</p> <code>None</code> <code>database</code> <code>str</code> <p>name of the database to use</p> <code>'test'</code> Source code in <code>odmantic/engine.py</code> <pre><code>def __init__(\n    self,\n    client: \"Union[MongoClient, None]\" = None,\n    database: str = \"test\",\n):\n    \"\"\"Engine constructor.\n\n    Args:\n        client: instance of a PyMongo client. If None, a default one\n                will be created\n        database: name of the database to use\n    \"\"\"\n    if client is None:\n        client = MongoClient()\n    super().__init__(client=client, database=database)\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.configure_database","title":"<code>configure_database(models, *, update_existing_indexes=False, session=None)</code>","text":"<p>Apply model constraints to the database.</p> <p>Parameters:</p> Name Type Description Default <code>models</code> <code>Sequence[Type[ModelType]]</code> <p>list of models to initialize the database with</p> required <code>update_existing_indexes</code> <code>bool</code> <p>conflicting indexes will be dropped before creation</p> <code>False</code> <code>session</code> <code>SyncSessionType</code> <p>an optional session to use for the operation</p> <code>None</code> Source code in <code>odmantic/engine.py</code> <pre><code>def configure_database(\n    self,\n    models: Sequence[Type[ModelType]],\n    *,\n    update_existing_indexes: bool = False,\n    session: SyncSessionType = None,\n) -&gt; None:\n    \"\"\"Apply model constraints to the database.\n\n    Args:\n        models: list of models to initialize the database with\n        update_existing_indexes: conflicting indexes will be dropped before creation\n        session: an optional session to use for the operation\n\n    &lt;!---\n    #noqa: DAR401 pymongo.errors.OperationFailure\n    --&gt;\n    \"\"\"\n    driver_session = self._get_session(session)\n    for model in models:\n        collection = self.get_collection(model)\n        for index in model.__indexes__():\n            pymongo_index = (\n                index.get_pymongo_index()\n                if isinstance(index, ODMBaseIndex)\n                else index\n            )\n            try:\n                collection.create_indexes([pymongo_index], session=driver_session)\n            except pymongo.errors.OperationFailure as exc:\n                if update_existing_indexes and getattr(exc, \"code\", None) in (\n                    85,  # aka IndexOptionsConflict\n                    86,  # aka IndexKeySpecsConflict for MongoDB &gt; 5\n                ):\n                    collection.drop_index(\n                        pymongo_index.document[\"name\"], session=driver_session\n                    )\n                    collection.create_indexes(\n                        [pymongo_index], session=driver_session\n                    )\n                else:\n                    raise\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.count","title":"<code>count(model, *queries, session=None)</code>","text":"<p>Get the count of documents matching a query</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[ModelType]</code> <p>model to perform the operation on</p> required <code>*queries</code> <code>Union[QueryExpression, Dict, bool]</code> <p>query filters to apply</p> <code>()</code> <code>session</code> <code>SyncSessionType</code> <p>an optional session to use for the operation</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>number of document matching the query</p> Source code in <code>odmantic/engine.py</code> <pre><code>def count(\n    self,\n    model: Type[ModelType],\n    *queries: Union[QueryExpression, Dict, bool],\n    session: SyncSessionType = None,\n) -&gt; int:\n    \"\"\"Get the count of documents matching a query\n\n    Args:\n        model: model to perform the operation on\n        *queries: query filters to apply\n        session: an optional session to use for the operation\n\n    Returns:\n        number of document matching the query\n\n    &lt;!---\n    #noqa: DAR401 TypeError\n    --&gt;\n    \"\"\"\n    if not lenient_issubclass(model, Model):\n        raise TypeError(\"Can only call count with a Model class\")\n    query = BaseEngine._build_query(*queries)\n    collection = self.database[model.__collection__]\n    count = collection.count_documents(query, session=self._get_session(session))\n    return int(count)\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.delete","title":"<code>delete(instance, session=None)</code>","text":"<p>Delete an instance from the database</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>ModelType</code> <p>the instance to delete</p> required <code>session</code> <code>SyncSessionType</code> <p>an optional session to use for the operation</p> <code>None</code> <p>Raises:</p> Type Description <code>DocumentNotFoundError</code> <p>the instance has not been persisted to the database</p> Source code in <code>odmantic/engine.py</code> <pre><code>def delete(\n    self,\n    instance: ModelType,\n    session: SyncSessionType = None,\n) -&gt; None:\n    \"\"\"Delete an instance from the database\n\n    Args:\n        instance: the instance to delete\n        session: an optional session to use for the operation\n\n    Raises:\n        DocumentNotFoundError: the instance has not been persisted to the database\n\n    \"\"\"\n    # TODO handle cascade deletion\n    collection = self.database[instance.__collection__]\n    pk_name = instance.__primary_field__\n    result = collection.delete_many(\n        {\"_id\": getattr(instance, pk_name)}, session=self._get_session(session)\n    )\n    count = result.deleted_count\n    if count == 0:\n        raise DocumentNotFoundError(instance)\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.find","title":"<code>find(model, *queries, sort=None, skip=0, limit=None, session=None)</code>","text":"<p>Search for Model instances matching the query filter provided</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[ModelType]</code> <p>model to perform the operation on</p> required <code>*queries</code> <code>Union[QueryExpression, Dict, bool]</code> <p>query filter to apply</p> <code>()</code> <code>sort</code> <code>Optional[Any]</code> <p>sort expression</p> <code>None</code> <code>skip</code> <code>int</code> <p>number of document to skip</p> <code>0</code> <code>limit</code> <code>Optional[int]</code> <p>maximum number of instance fetched</p> <code>None</code> <code>session</code> <code>SyncSessionType</code> <p>an optional session to use for the operation</p> <code>None</code> <p>Raises:</p> Type Description <code>DocumentParsingError</code> <p>unable to parse one of the resulting documents</p> <p>Returns:</p> Type Description <code>SyncCursor[ModelType]</code> <p>odmantic.engine.SyncCursor of the query</p> Source code in <code>odmantic/engine.py</code> <pre><code>def find(\n    self,\n    model: Type[ModelType],\n    *queries: Union[\n        QueryExpression, Dict, bool\n    ],  # bool: allow using binary operators with mypy\n    sort: Optional[Any] = None,\n    skip: int = 0,\n    limit: Optional[int] = None,\n    session: SyncSessionType = None,\n) -&gt; SyncCursor[ModelType]:\n    \"\"\"Search for Model instances matching the query filter provided\n\n    Args:\n        model: model to perform the operation on\n        *queries: query filter to apply\n        sort: sort expression\n        skip: number of document to skip\n        limit: maximum number of instance fetched\n        session: an optional session to use for the operation\n\n    Raises:\n        DocumentParsingError: unable to parse one of the resulting documents\n\n    Returns:\n        [odmantic.engine.SyncCursor][] of the query\n\n    &lt;!---\n    #noqa: DAR401 ValueError\n    #noqa: DAR401 TypeError\n    #noqa: DAR402 DocumentParsingError\n    --&gt;\n    \"\"\"\n    pipeline = self._prepare_find_pipeline(\n        model,\n        *queries,\n        sort=sort,\n        skip=skip,\n        limit=limit,\n    )\n    collection = self.get_collection(model)\n    cursor = collection.aggregate(pipeline, session=self._get_session(session))\n    return SyncCursor(model, cursor)\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.find_one","title":"<code>find_one(model, *queries, sort=None, session=None)</code>","text":"<p>Search for a Model instance matching the query filter provided</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[ModelType]</code> <p>model to perform the operation on</p> required <code>*queries</code> <code>Union[QueryExpression, Dict, bool]</code> <p>query filter to apply</p> <code>()</code> <code>sort</code> <code>Optional[Any]</code> <p>sort expression</p> <code>None</code> <code>session</code> <code>SyncSessionType</code> <p>an optional session to use for the operation</p> <code>None</code> <p>Raises:</p> Type Description <code>DocumentParsingError</code> <p>unable to parse the resulting document</p> <p>Returns:</p> Type Description <code>Optional[ModelType]</code> <p>the fetched instance if found otherwise None</p> Source code in <code>odmantic/engine.py</code> <pre><code>def find_one(\n    self,\n    model: Type[ModelType],\n    *queries: Union[\n        QueryExpression, Dict, bool\n    ],  # bool: allow using binary operators w/o plugin\n    sort: Optional[Any] = None,\n    session: SyncSessionType = None,\n) -&gt; Optional[ModelType]:\n    \"\"\"Search for a Model instance matching the query filter provided\n\n    Args:\n        model: model to perform the operation on\n        *queries: query filter to apply\n        sort: sort expression\n        session: an optional session to use for the operation\n\n    Raises:\n        DocumentParsingError: unable to parse the resulting document\n\n    Returns:\n        the fetched instance if found otherwise None\n\n    &lt;!---\n    #noqa: DAR401 TypeError\n    #noqa: DAR402 DocumentParsingError\n    --&gt;\n    \"\"\"\n    if not lenient_issubclass(model, Model):\n        raise TypeError(\"Can only call find_one with a Model class\")\n    results = list(self.find(model, *queries, sort=sort, limit=1, session=session))\n    if len(results) == 0:\n        return None\n    return results[0]\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.get_collection","title":"<code>get_collection(model)</code>","text":"<p>Get the pymongo collection associated to a Model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[ModelType]</code> <p>model class</p> required <p>Returns:</p> Type Description <code>Collection</code> <p>the pymongo collection object</p> Source code in <code>odmantic/engine.py</code> <pre><code>def get_collection(self, model: Type[ModelType]) -&gt; \"Collection\":\n    \"\"\"Get the pymongo collection associated to a Model.\n\n    Args:\n        model: model class\n\n    Returns:\n        the pymongo collection object\n    \"\"\"\n    collection = self.database[model.__collection__]\n    return collection\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.remove","title":"<code>remove(model, *queries, just_one=False, session=None)</code>","text":"<p>Delete Model instances matching the query filter provided</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[ModelType]</code> <p>model to perform the operation on</p> required <code>*queries</code> <code>Union[QueryExpression, Dict, bool]</code> <p>query filter to apply</p> <code>()</code> <code>just_one</code> <code>bool</code> <p>limit the deletion to just one document</p> <code>False</code> <code>session</code> <code>SyncSessionType</code> <p>an optional session to use for the operation</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>the number of instances deleted from the database.</p> Source code in <code>odmantic/engine.py</code> <pre><code>def remove(\n    self,\n    model: Type[ModelType],\n    *queries: Union[QueryExpression, Dict, bool],\n    just_one: bool = False,\n    session: SyncSessionType = None,\n) -&gt; int:\n    \"\"\"Delete Model instances matching the query filter provided\n\n    Args:\n        model: model to perform the operation on\n        *queries: query filter to apply\n        just_one: limit the deletion to just one document\n        session: an optional session to use for the operation\n\n    Returns:\n        the number of instances deleted from the database.\n    \"\"\"\n    query = SyncEngine._build_query(*queries)\n    collection = self.get_collection(model)\n\n    if just_one:\n        result = collection.delete_one(query, session=self._get_session(session))\n    else:\n        result = collection.delete_many(query, session=self._get_session(session))\n\n    return result.deleted_count\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.save","title":"<code>save(instance, *, session=None)</code>","text":"<p>Persist an instance to the database</p> <p>This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten.</p> <p>All the other models referenced by this instance will be saved as well.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>ModelType</code> <p>instance to persist</p> required <code>session</code> <code>SyncSessionType</code> <p>An optional session to use for the operation. If not provided, an      internal session will be used to persist the instance and      sub-instances.</p> <code>None</code> <p>Returns:</p> Type Description <code>ModelType</code> <p>the saved instance</p> <p>Raises:</p> Type Description <code>DuplicateKeyError</code> <p>the instance is duplicated according to a unique index.</p> NOTE <p>The save operation actually modify the instance argument in place. However, the instance is still returned for convenience.</p> Source code in <code>odmantic/engine.py</code> <pre><code>def save(\n    self,\n    instance: ModelType,\n    *,\n    session: SyncSessionType = None,\n) -&gt; ModelType:\n    \"\"\"Persist an instance to the database\n\n    This method behaves as an 'upsert' operation. If a document already exists\n    with the same primary key, it will be overwritten.\n\n    All the other models referenced by this instance will be saved as well.\n\n    Args:\n        instance: instance to persist\n        session: An optional session to use for the operation. If not provided, an\n                 internal session will be used to persist the instance and\n                 sub-instances.\n\n    Returns:\n        the saved instance\n\n    Raises:\n        DuplicateKeyError: the instance is duplicated according to a unique index.\n\n    NOTE:\n        The save operation actually modify the instance argument in place. However,\n        the instance is still returned for convenience.\n\n    &lt;!---\n    #noqa: DAR401 TypeError\n    #noqa: DAR402 DuplicateKeyError\n    --&gt;\n    \"\"\"\n    if not isinstance(instance, Model):\n        raise TypeError(\"Can only call find_one with a Model class\")\n\n    if session:\n        self._save(instance, self._get_session(session))  # type: ignore\n    else:\n        with self.client.start_session() as local_session:\n            self._save(instance, local_session)\n    return instance\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.save_all","title":"<code>save_all(instances, *, session=None)</code>","text":"<p>Persist instances to the database</p> <p>This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten.</p> <p>All the other models referenced by this instance will be recursively saved as well.</p> <p>Parameters:</p> Name Type Description Default <code>instances</code> <code>Sequence[ModelType]</code> <p>instances to persist</p> required <code>session</code> <code>SyncSessionType</code> <p>An optional session to use for the operation. If not provided an      internal session will be used to persist the instances.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[ModelType]</code> <p>the saved instances</p> <p>Raises:</p> Type Description <code>DuplicateKeyError</code> <p>an instance is duplicated according to a unique index.</p> NOTE <p>The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience.</p> Source code in <code>odmantic/engine.py</code> <pre><code>def save_all(\n    self,\n    instances: Sequence[ModelType],\n    *,\n    session: SyncSessionType = None,\n) -&gt; List[ModelType]:\n    \"\"\"Persist instances to the database\n\n    This method behaves as multiple 'upsert' operations. If one of the document\n    already exists with the same primary key, it will be overwritten.\n\n    All the other models referenced by this instance will be recursively saved as\n    well.\n\n    Args:\n        instances: instances to persist\n        session: An optional session to use for the operation. If not provided an\n                 internal session will be used to persist the instances.\n\n    Returns:\n        the saved instances\n\n    Raises:\n        DuplicateKeyError: an instance is duplicated according to a unique index.\n\n    NOTE:\n        The save_all operation actually modify the arguments in place. However, the\n        instances are still returned for convenience.\n    &lt;!---\n    #noqa: DAR402 DuplicateKeyError\n    --&gt;\n    \"\"\"\n    if session:\n        added_instances = [\n            self._save(instance, self._get_session(session))  # type: ignore\n            for instance in instances\n        ]\n    else:\n        with self.client.start_session() as local_session:\n            added_instances = [\n                self._save(instance, local_session) for instance in instances\n            ]\n    return added_instances\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.session","title":"<code>session()</code>","text":"<p>Get a new session for the engine to allow ordering sequential operations.</p> <p>Returns:</p> Type Description <code>SyncSession</code> <p>a new session object</p> <p>Example usage:</p> <pre><code>engine = SyncEngine(...)\nwith engine.session() as session:\n    john = session.find(User, User.name == \"John\")\n    john.name = \"Doe\"\n    session.save(john)\n</code></pre> Source code in <code>odmantic/engine.py</code> <pre><code>def session(self) -&gt; SyncSession:\n    \"\"\"Get a new session for the engine to allow ordering sequential operations.\n\n    Returns:\n        a new session object\n\n    Example usage:\n\n    ```python\n    engine = SyncEngine(...)\n    with engine.session() as session:\n        john = session.find(User, User.name == \"John\")\n        john.name = \"Doe\"\n        session.save(john)\n    ```\n    \"\"\"\n    return SyncSession(self)\n</code></pre>"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.transaction","title":"<code>transaction()</code>","text":"<p>Get a new transaction for the engine to aggregate sequential operations.</p> <p>Returns:</p> Type Description <code>SyncTransaction</code> <p>a new transaction object</p> <p>Example usage: <pre><code>engine = SyncEngine(...)\nwith engine.transaction() as transaction:\n    john = transaction.find(User, User.name == \"John\")\n    john.name = \"Doe\"\n    transaction.save(john)\n    transaction.commit()\n</code></pre></p> Warning <p>MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled.</p> Source code in <code>odmantic/engine.py</code> <pre><code>def transaction(self) -&gt; SyncTransaction:\n    \"\"\"Get a new transaction for the engine to aggregate sequential operations.\n\n    Returns:\n        a new transaction object\n\n    Example usage:\n    ```python\n    engine = SyncEngine(...)\n    with engine.transaction() as transaction:\n        john = transaction.find(User, User.name == \"John\")\n        john.name = \"Doe\"\n        transaction.save(john)\n        transaction.commit()\n    ```\n\n    Warning:\n        MongoDB transaction are only supported on replicated clusters: either\n        directly a replicaSet or a sharded cluster with replication enabled.\n    \"\"\"\n    return SyncTransaction(self)\n</code></pre>"},{"location":"api_reference/exceptions/","title":"odmantic.exceptions","text":"<p>             Bases: <code>Exception</code></p> <p>Base Exception raised by the engine while operating with the database.</p> Source code in <code>odmantic/exceptions.py</code> <pre><code>class BaseEngineException(Exception, metaclass=ABCMeta):\n    \"\"\"Base Exception raised by the engine while operating with the database.\"\"\"\n\n    def __init__(self, message: str, model: Type[\"Model\"]):\n        self.model: Type[\"Model\"] = model\n        super().__init__(message)\n</code></pre> <p>             Bases: <code>BaseEngineException</code></p> <p>The targetted document has not been found by the engine.</p> <p>Attributes:</p> Name Type Description <code>instance</code> <code>Model</code> <p>the instance that has not been found</p> Source code in <code>odmantic/exceptions.py</code> <pre><code>class DocumentNotFoundError(BaseEngineException):\n    \"\"\"The targetted document has not been found by the engine.\n\n    Attributes:\n      instance: the instance that has not been found\n    \"\"\"\n\n    def __init__(self, instance: \"Model\"):\n        self.instance: \"Model\" = instance\n        super().__init__(\n            f\"Document not found for : {type(instance).__name__}. \"\n            f\"Instance: {self.instance}\",\n            type(instance),\n        )\n</code></pre> <p>             Bases: <code>ValueError</code></p> <p>Unable to parse the document into an instance.</p> <p>Inherits from the <code>ValidationError</code> defined by Pydantic.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>Union[Type[Model], Type[EmbeddedModel]]</code> <p>model which could not be instanciated</p> Source code in <code>odmantic/exceptions.py</code> <pre><code>class DocumentParsingError(ValueError):\n    \"\"\"Unable to parse the document into an instance.\n\n    Inherits from the `ValidationError` defined by Pydantic.\n\n    Attributes:\n      model (Union[Type[Model],Type[EmbeddedModel]]): model which could not be\n        instanciated\n    \"\"\"\n\n    def __init__(\n        self,\n        errors: ErrorList,\n        model: Type[\"_BaseODMModel\"],\n    ):\n        self.model = model\n        self.inner = ValidationError.from_exception_data(\n            title=self.model.__name__,\n            line_errors=errors,\n        )\n\n    def __str__(self) -&gt; str:\n        return str(self.inner)\n\n    def __repr__(self) -&gt; str:\n        return repr(self.inner)\n</code></pre> <p>             Bases: <code>BaseEngineException</code></p> <p>The targetted document is duplicated according to a unique index.</p> <p>Attributes:</p> Name Type Description <code>instance</code> <code>Model</code> <p>the instance that has not been found</p> <code>driver_error</code> <p>the original driver error</p> Source code in <code>odmantic/exceptions.py</code> <pre><code>class DuplicateKeyError(BaseEngineException):\n    \"\"\"The targetted document is duplicated according to a unique index.\n\n    Attributes:\n      instance: the instance that has not been found\n      driver_error: the original driver error\n    \"\"\"\n\n    def __init__(\n        self, instance: \"Model\", driver_error: pymongo.errors.DuplicateKeyError\n    ):\n        self.instance: \"Model\" = instance\n        self.driver_error = driver_error\n        super().__init__(\n            f\"Duplicate key error for: {type(instance).__name__}. \"\n            f\"Instance: {self.instance} \"\n            f\"Driver error: {self.driver_error}\",\n            type(instance),\n        )\n</code></pre>"},{"location":"api_reference/field/","title":"odmantic.field","text":"<p>Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields (<code>int</code>, <code>float</code>,  <code>Decimal</code>) and some apply only to <code>str</code>.</p> Tip <p>The main additions of ODMantic to the regular pydantic <code>Field</code> are the <code>key_name</code>, <code>index</code>, <code>unique</code> and the <code>primary_field</code> options.</p> Warning <p>If both <code>default</code> and <code>default_factory</code> are set, an error is raised.</p> Warning <p><code>primary_field</code> can't be used along with <code>key_name</code> since the key_name will be set to <code>_id</code>.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Any</code> <p>since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis (<code>...</code>) to indicate the field has no default value</p> <code>PydanticUndefined</code> <code>key_name</code> <code>Optional[str]</code> <p>the name to use in the the mongo document structure</p> <code>None</code> <code>primary_field</code> <code>bool</code> <p>this field should be considered as a primary key.</p> <code>False</code> <code>index</code> <code>bool</code> <p>this field should be considered as an index</p> <code>False</code> <code>unique</code> <code>bool</code> <p>this field should be considered as a unique index</p> <code>False</code> <code>default_factory</code> <code>Optional['NoArgAnyCallable']</code> <p>callable that will be called when a default value is needed for this field.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>can be any string, used in the schema</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>can be any string, used in the schema</p> <code>None</code> <code>examples</code> <code>list[Any] | None</code> <p>can be any list, used in the schema</p> <code>None</code> <code>json_schema_extra</code> <code>JsonDict | Callable[[JsonDict], None] | None</code> <p>Any additional JSON schema data for the schema property.</p> <code>None</code> <code>const</code> <code>Optional[bool]</code> <p>this field is required and must take it's default value</p> <code>None</code> <code>gt</code> <code>Optional[float]</code> <p>only applies to numbers, requires the field to be \"greater than\". The schema will have an <code>exclusiveMinimum</code> validation keyword</p> <code>None</code> <code>ge</code> <code>Optional[float]</code> <p>only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a <code>minimum</code> validation keyword</p> <code>None</code> <code>lt</code> <code>Optional[float]</code> <p>only applies to numbers, requires the field to be \"less than\". The schema will have an <code>exclusiveMaximum</code> validation keyword</p> <code>None</code> <code>le</code> <code>Optional[float]</code> <p>only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a <code>maximum</code> validation keyword</p> <code>None</code> <code>multiple_of</code> <code>Optional[float]</code> <p>only applies to numbers, requires the field to be \"a multiple of \". The schema will have a <code>multipleOf</code> validation keyword</p> <code>None</code> <code>min_items</code> <code>Optional[int]</code> <p>only applies to sequences, requires the field to have a minimum item count.</p> <code>None</code> <code>max_items</code> <code>Optional[int]</code> <p>only applies to sequences, requires the field to have a maximum item count.</p> <code>None</code> <code>min_length</code> <code>Optional[int]</code> <p>only applies to strings, requires the field to have a minimum length. The schema will have a <code>maximum</code> validation keyword</p> <code>None</code> <code>max_length</code> <code>Optional[int]</code> <p>only applies to strings, requires the field to have a maximum length. The schema will have a <code>maxLength</code> validation keyword</p> <code>None</code> <code>regex</code> <code>Optional[str]</code> <p>only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a <code>pattern</code> validation keyword</p> <code>None</code> Source code in <code>odmantic/field.py</code> <pre><code>def Field(\n    default: Any = PydanticUndefined,\n    *,\n    key_name: Optional[str] = None,\n    primary_field: bool = False,\n    index: bool = False,\n    unique: bool = False,\n    default_factory: Optional[\"NoArgAnyCallable\"] = None,\n    # alias: str = None, # FIXME not supported yet\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    json_schema_extra: JsonDict | Callable[[JsonDict], None] | None = None,\n    const: Optional[bool] = None,\n    gt: Optional[float] = None,\n    ge: Optional[float] = None,\n    lt: Optional[float] = None,\n    le: Optional[float] = None,\n    multiple_of: Optional[float] = None,\n    min_items: Optional[int] = None,\n    max_items: Optional[int] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    regex: Optional[str] = None,\n    examples: list[Any] | None = None,\n) -&gt; Any:\n    \"\"\"Used to provide extra information about a field, either for the model schema or\n    complex validation. Some arguments apply only to number fields (``int``, ``float``,\n     ``Decimal``) and some apply only to ``str``.\n\n    Tip:\n        The main additions of ODMantic to the regular pydantic `Field` are the\n        `key_name`, `index`, `unique` and the `primary_field` options.\n\n    Warning:\n        If both `default` and `default_factory` are set, an error is raised.\n\n    Warning:\n        `primary_field` can't be used along with `key_name` since the key_name will be\n        set to `_id`.\n\n\n    Args:\n        default: since this is replacing the field\u2019s default, its first argument is\n            used to set the default, use ellipsis (``...``) to indicate the field has no\n            default value\n        key_name: the name to use in the the mongo document structure\n        primary_field: this field should be considered as a primary key.\n        index: this field should be considered as an index\n        unique: this field should be considered as a unique index\n        default_factory: callable that will be called when a default value is needed\n            for this field.\n        title: can be any string, used in the schema\n        description: can be any string, used in the schema\n        examples: can be any list, used in the schema\n        json_schema_extra: Any additional JSON schema data for the schema property.\n        const: this field is required and *must* take it's default value\n        gt: only applies to numbers, requires the field to be \"greater than\". The\n            schema will have an ``exclusiveMinimum`` validation keyword\n        ge: only applies to numbers, requires the field to be \"greater than or equal\n            to\". The schema will have a ``minimum`` validation keyword\n        lt: only applies to numbers, requires the field to be \"less than\". The schema\n            will have an ``exclusiveMaximum`` validation keyword\n        le: only applies to numbers, requires the field to be \"less than or equal to\"\n            . The schema will have a ``maximum`` validation keyword\n        multiple_of: only applies to numbers, requires the field to be \"a multiple of\n            \". The schema will have a ``multipleOf`` validation keyword\n        min_items: only applies to sequences, requires the field to have a minimum\n            item count.\n        max_items: only applies to sequences, requires the field to have a maximum\n            item count.\n        min_length: only applies to strings, requires the field to have a minimum\n            length. The schema will have a ``maximum`` validation keyword\n        max_length: only applies to strings, requires the field to have a maximum\n            length. The schema will have a ``maxLength`` validation keyword\n        regex: only applies to strings, requires the field match agains a regular\n            expression pattern string. The schema will have a ``pattern`` validation\n            keyword\n\n    &lt;!---\n    # noqa: DAR201\n    # noqa: DAR003\n    # noqa: DAR401\n    # noqa: DAR101\n    --&gt;\n    \"\"\"\n    # Perform casts on optional fields to avoid incompatibility due to the strict\n    # optional mypy setting\n    # TODO: add remaining validation fields from pydantic\n    pydantic_field = PDField(\n        default,\n        default_factory=default_factory,\n        # alias=alias,  # FIXME check aliases compatibility\n        title=cast(str, title),\n        description=cast(str, description),\n        examples=examples,\n        json_schema_extra=json_schema_extra,\n        const=cast(bool, const),\n        gt=cast(float, gt),\n        ge=cast(float, ge),\n        lt=cast(float, lt),\n        le=cast(float, le),\n        multiple_of=cast(float, multiple_of),\n        min_items=cast(int, min_items),\n        max_items=cast(int, max_items),\n        min_length=cast(int, min_length),\n        max_length=cast(int, max_length),\n        regex=cast(str, regex),\n    )\n    if primary_field:\n        if key_name is not None and key_name != \"_id\":\n            raise ValueError(\n                \"cannot specify a primary field with a custom key_name,\"\n                \"key_name='_id' enforced\"\n            )\n        else:\n            key_name = \"_id\"\n    elif key_name == \"_id\":\n        raise ValueError(\n            \"cannot specify key_name='_id' without defining the field as primary\"\n        )\n\n    return ODMFieldInfo(\n        pydantic_field_info=pydantic_field,\n        primary_field=primary_field,\n        key_name=key_name,\n        index=index,\n        unique=unique,\n    )\n</code></pre>"},{"location":"api_reference/model/","title":"odmantic.model","text":"<p>             Bases: <code>BaseModel</code></p> <p>Base class for Model and EmbeddedModel.</p> <p>Warning</p> <p>This internal class should never be instanciated directly.</p> Source code in <code>odmantic/model.py</code> <pre><code>class _BaseODMModel(pydantic.BaseModel, metaclass=ABCMeta):\n    \"\"\"Base class for [Model][odmantic.model.Model] and\n    [EmbeddedModel][odmantic.model.EmbeddedModel].\n\n    !!! warning\n        This internal class should never be instanciated directly.\n    \"\"\"\n\n    if TYPE_CHECKING:\n        __odm_fields__: ClassVar[Dict[str, ODMBaseField]] = {}\n        __bson_serializers__: ClassVar[Dict[str, Callable[[Any], Any]]] = {}\n        __mutable_fields__: ClassVar[FrozenSet[str]] = frozenset()\n        __references__: ClassVar[Tuple[str, ...]] = ()\n        __pydantic_model__: ClassVar[Type[BaseBSONModel]]\n        # __fields_modified__ is not a ClassVar but this allows to hide this field from\n        # the dataclass transform generated constructor\n        __fields_modified__: ClassVar[Set[str]] = set()\n\n    model_config: ClassVar[ODMConfigDict]\n\n    __slots__ = (\"__fields_modified__\",)\n\n    def __init__(self, **data: Any):\n        super().__init__(**data)\n        object.__setattr__(self, \"__fields_modified__\", set(self.__odm_fields__.keys()))\n\n    @classmethod\n    # TODO: rename to model_validate\n    def validate(cls: Type[BaseT], value: Any) -&gt; BaseT:\n        if isinstance(value, cls):\n            # Do not copy the object as done in pydantic\n            # This enable to keep the same python object\n            return value\n        return super().model_validate(value)\n\n    def __repr_args__(self) -&gt; \"ReprArgs\":\n        # Place the id field first in the repr string\n        args = list(super().__repr_args__())\n        id_arg = next((arg for arg in args if arg[0] == \"id\"), None)\n        if id_arg is None:\n            return args\n        args.remove(id_arg)\n        args = [id_arg] + args\n        return args\n\n    @deprecated(\n        \"copy is deprecated, please use model_copy instead\",\n    )\n    def copy(\n        self: BaseT,\n        *,\n        include: Union[\"AbstractSetIntStr\", \"MappingIntStrAny\", None] = None,\n        exclude: Union[\"AbstractSetIntStr\", \"MappingIntStrAny\", None] = None,\n        update: Dict[str, Any] | None = None,\n        deep: bool = False,\n    ) -&gt; BaseT:\n        if include is not None or exclude is not None:\n            raise NotImplementedError(\n                \"copy with include or exclude is not supported anymore, \"\n                \"please use `model_copy` instead\"\n            )\n        return self.model_copy(update=update, deep=deep)\n\n    def model_copy(\n        self: BaseT,\n        *,\n        update: Optional[\"DictStrAny\"] = None,\n        deep: bool = False,\n    ) -&gt; BaseT:\n        \"\"\"Duplicate a model, optionally choose which fields to change.\n\n        Danger:\n            The data is not validated before creating the new model: **you should trust\n            this data**.\n\n        Arguments:\n            update: values to change/add in the new model.\n            deep: set to `True` to make a deep copy of the model\n\n        Returns:\n            new model instance\n\n        \"\"\"\n        copied = super().model_copy(update=update, deep=deep)\n        copied._post_copy_update()\n        return copied\n\n    def _post_copy_update(self: BaseT) -&gt; None:\n        \"\"\"Recursively update internal fields of the copied model after it has been\n        copied.\n\n        Set them as if they were modified to make sure they are saved in the database.\n        \"\"\"\n        object.__setattr__(self, \"__fields_modified__\", set(self.model_fields))\n        for field_name, field in self.__odm_fields__.items():\n            if isinstance(field, ODMEmbedded):\n                value = getattr(self, field_name)\n                value._post_copy_update()\n\n    @deprecated(\n        \"update is deprecated, please use model_update instead\",\n    )\n    def update(\n        self,\n        patch_object: Union[BaseModel, Dict[str, Any]],\n        *,\n        include: \"IncEx\" = None,\n        exclude: \"IncEx\" = None,\n        exclude_unset: bool = True,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n    ) -&gt; None:\n        self.model_update(\n            patch_object,\n            include=include,\n            exclude=exclude,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n        )\n\n    def model_update(\n        self,\n        patch_object: Union[BaseModel, Dict[str, Any]],\n        *,\n        include: \"IncEx\" = None,\n        exclude: \"IncEx\" = None,\n        exclude_unset: bool = True,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n    ) -&gt; None:\n        \"\"\"Update instance fields from a Pydantic model or a dictionary.\n\n        If a pydantic model is provided, only the **fields set** will be\n        applied by default.\n\n        Args:\n            patch_object: object containing the values to update\n            include: fields to include from the `patch_object` (include all fields if\n                `None`)\n            exclude: fields to exclude from the `patch_object`, this takes\n                precedence over include\n            exclude_unset: only update fields explicitly set in the patch object (only\n                applies to Pydantic models)\n            exclude_defaults: only update fields that are different from their default\n                value in the patch object (only applies to Pydantic models)\n            exclude_none: only update fields different from None in the patch object\n                (only applies to Pydantic models)\n\n        Raises:\n            ValidationError: the modifications would make the instance invalid\n\n        &lt;!--\n        #noqa: DAR402 ValidationError\n        --&gt;\n        \"\"\"\n        if isinstance(patch_object, BaseModel):\n            patch_dict = patch_object.model_dump(\n                include=include,\n                exclude=exclude,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n            )\n        else:\n            odm_fields = set(self.__odm_fields__.keys())\n            patch_dict = {}\n            for k, v in patch_object.items():\n                if include is not None and k not in include:\n                    continue\n                if exclude is not None and k in exclude:\n                    continue\n                if k not in odm_fields:\n                    continue\n                patch_dict[k] = v\n        patched_instance_dict = {**self.model_dump(), **patch_dict}\n        # FIXME: improve performance by only running updated field validators and then\n        # model validators\n        patched_instance = self.validate(patched_instance_dict)\n        for name, new_value in patched_instance.__dict__.items():\n            if self.__dict__[name] != new_value:\n                # Manually change the field to avoid running the validators again\n                self.__dict__[name] = new_value\n                self.model_fields_set.add(name)\n                self.__fields_modified__.add(name)\n\n    def __setattr__(self, name: str, value: Any) -&gt; None:\n        super().__setattr__(name, value)\n        self.__fields_modified__.add(name)\n\n    @deprecated(\n        \"doc is deprecated, please use model_dump_doc instead\",\n    )\n    def doc(self, include: Optional[\"AbstractSetIntStr\"] = None) -&gt; Dict[str, Any]:\n        return self.model_dump_doc(include=include)\n\n    def model_dump_doc(\n        self, include: Optional[\"AbstractSetIntStr\"] = None\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Generate a document (BSON) representation of the instance (as a dictionary).\n\n        Args:\n            include: field that should be included; if None, every fields will be\n                included\n\n        Returns:\n            the document associated to the instance\n        \"\"\"\n        raw_doc = self.model_dump()\n        doc = self.__doc(raw_doc, type(self), include)\n        return doc\n\n    def __doc(  # noqa C901 # TODO: refactor document generation\n        self,\n        raw_doc: Dict[str, Any],\n        model: Type[\"_BaseODMModel\"],\n        include: Optional[\"AbstractSetIntStr\"] = None,\n    ) -&gt; Dict[str, Any]:\n        doc: Dict[str, Any] = {}\n        for field_name, field in model.__odm_fields__.items():\n            if include is not None and field_name not in include:\n                continue\n            if isinstance(field, ODMReference):\n                doc[field.key_name] = raw_doc[field_name][field.model.__primary_field__]\n            elif isinstance(field, ODMEmbedded):\n                doc[field.key_name] = self.__doc(raw_doc[field_name], field.model, None)\n            elif isinstance(field, ODMEmbeddedGeneric):\n                if field.generic_origin is dict:\n                    doc[field.key_name] = {\n                        item_key: self.__doc(item_value, field.model)\n                        for item_key, item_value in raw_doc[field_name].items()\n                    }\n                else:\n                    doc[field.key_name] = [\n                        self.__doc(item, field.model) for item in raw_doc[field_name]\n                    ]\n            elif field_name in model.__bson_serializers__:\n                doc[field.key_name] = model.__bson_serializers__[field_name](\n                    raw_doc[field_name]\n                )\n            else:\n                doc[field.key_name] = raw_doc[field_name]\n\n        if model.model_config[\"extra\"] == \"allow\":\n            # raw_doc is indexed by field name so we compare against odm field names\n            extras = set(raw_doc.keys()) - set(self.__odm_fields__.keys())\n            for extra in extras:\n                value = raw_doc[extra]\n                subst_type = validate_type(type(value))\n                bson_serializer = _get_bson_serializer(subst_type)\n                if bson_serializer is not None:\n                    doc[extra] = bson_serializer(value)\n                else:\n                    doc[extra] = value\n        return doc\n\n    @classmethod\n    @deprecated(\n        \"parse_doc is deprecated, please use model_validate_doc instead\",\n    )\n    def parse_doc(cls: Type[BaseT], raw_doc: Dict) -&gt; BaseT:\n        return cls.model_validate_doc(raw_doc)\n\n    @classmethod\n    def model_validate_doc(cls: Type[BaseT], raw_doc: Dict) -&gt; BaseT:\n        \"\"\"Parse a BSON document into an instance of the Model\n\n        Args:\n            raw_doc: document to parse (as Dict)\n\n        Raises:\n            DocumentParsingError: the specified document is invalid\n\n        Returns:\n            an instance of the Model class this method is called on.\n        \"\"\"\n        errors, obj = cls._parse_doc_to_obj(raw_doc)\n        if len(errors) &gt; 0:\n            raise DocumentParsingError(\n                errors=errors,\n                model=cls,\n            )\n        try:\n            instance = cls.model_validate(obj)\n        except ValidationError as e:\n            raise DocumentParsingError(\n                errors=e.errors(),  # type: ignore\n                model=cls,\n            )\n\n        return instance\n\n    @classmethod\n    def _parse_doc_to_obj(  # noqa C901 # TODO: refactor document parsing\n        cls: Type[BaseT], raw_doc: Dict, base_loc: Tuple[str, ...] = ()\n    ) -&gt; Tuple[List[InitErrorDetails], Dict[str, Any]]:\n        errors: List[InitErrorDetails] = []\n        obj: Dict[str, Any] = {}\n        for field_name, field in cls.__odm_fields__.items():\n            if isinstance(field, ODMReference):\n                sub_doc = raw_doc.get(field.key_name)\n                if sub_doc is None:\n                    errors.append(\n                        InitErrorDetails(\n                            type=ReferencedDocumentNotFoundError(field.key_name),\n                            loc=base_loc + (field_name,),\n                            input=raw_doc,\n                        )\n                    )\n\n                else:\n                    sub_errors, sub_obj = field.model._parse_doc_to_obj(\n                        sub_doc, base_loc=base_loc + (field_name,)\n                    )\n                    errors.extend(sub_errors)\n                    obj[field_name] = sub_obj\n            elif isinstance(field, ODMEmbedded):\n                value = raw_doc.get(field.key_name, Undefined)\n                if value is not Undefined:\n                    sub_errors, value = field.model._parse_doc_to_obj(\n                        value, base_loc=base_loc + (field_name,)\n                    )\n                    errors.extend(sub_errors)\n                else:\n                    if not field.is_required_in_doc():\n                        value = field.get_default_importing_value()\n                    if value is Undefined:\n                        errors.append(\n                            InitErrorDetails(\n                                type=KeyNotFoundInDocumentError(field.key_name),\n                                loc=base_loc + (field_name,),\n                                input=raw_doc,\n                            )\n                        )\n\n                obj[field_name] = value\n            elif isinstance(field, ODMEmbeddedGeneric):\n                value = Undefined\n                raw_value = raw_doc.get(field.key_name, Undefined)\n                if raw_value is not Undefined:\n                    if isinstance(raw_value, list) and (\n                        field.generic_origin is list\n                        or field.generic_origin is tuple\n                        or field.generic_origin is set\n                    ):\n                        value = []\n                        for i, item in enumerate(raw_value):\n                            sub_errors, item = field.model._parse_doc_to_obj(\n                                item, base_loc=base_loc + (field_name, f\"[{i}]\")\n                            )\n                            if len(sub_errors) &gt; 0:\n                                errors.extend(sub_errors)\n                            else:\n                                value.append(item)\n                        obj[field_name] = value\n                    elif isinstance(raw_value, dict) and field.generic_origin is dict:\n                        value = {}\n                        for item_key, item_value in raw_value.items():\n                            sub_errors, item_value = field.model._parse_doc_to_obj(\n                                item_value,\n                                base_loc=base_loc + (field_name, f'[\"{item_key}\"]'),\n                            )\n                            if len(sub_errors) &gt; 0:\n                                errors.extend(sub_errors)\n                            else:\n                                value[item_key] = item_value\n                        obj[field_name] = value\n                    else:\n                        errors.append(\n                            InitErrorDetails(\n                                type=IncorrectGenericEmbeddedModelValue(raw_value),\n                                loc=base_loc + (field_name,),\n                                input=raw_doc,\n                            )\n                        )\n\n                else:\n                    if not field.is_required_in_doc():\n                        value = field.get_default_importing_value()\n                    if value is Undefined:\n                        errors.append(\n                            InitErrorDetails(\n                                type=KeyNotFoundInDocumentError(field.key_name),\n                                loc=base_loc + (field_name,),\n                                input=raw_doc,\n                            )\n                        )\n                    else:\n                        obj[field_name] = value\n            else:\n                field = cast(ODMField, field)\n                value = raw_doc.get(field.key_name, Undefined)\n                if value is Undefined and not field.is_required_in_doc():\n                    value = field.get_default_importing_value()\n\n                if value is Undefined:\n                    errors.append(\n                        InitErrorDetails(\n                            type=KeyNotFoundInDocumentError(field.key_name),\n                            loc=base_loc + (field_name,),\n                            input=raw_doc,\n                        )\n                    )\n                else:\n                    obj[field_name] = value\n\n        if cls.model_config[\"extra\"] == \"allow\":\n            extras = set(raw_doc.keys()) - set(obj.keys())\n            for extra in extras:\n                obj[extra] = raw_doc[extra]\n\n        return errors, obj\n</code></pre> <p>             Bases: <code>_BaseODMModel</code></p> <p>Class that can be extended to create an ODMantic Model.</p> <p>Each model will be bound to a MongoDB collection. You can customize the collection name by setting the <code>__collection__</code> class variable in the model classes.</p> Source code in <code>odmantic/model.py</code> <pre><code>class Model(_BaseODMModel, metaclass=ModelMetaclass):\n    \"\"\"Class that can be extended to create an ODMantic Model.\n\n    Each model will be bound to a MongoDB collection. You can customize the collection\n    name by setting the `__collection__` class variable in the model classes.\n    \"\"\"\n\n    if TYPE_CHECKING:\n        __collection__: ClassVar[str] = \"\"\n        __primary_field__: ClassVar[str] = \"\"\n\n        id: Union[ObjectId, Any] = Field()  # TODO fix basic id field typing\n\n    def __setattr__(self, name: str, value: Any) -&gt; None:\n        if name == self.__primary_field__:\n            # TODO implement\n            raise NotImplementedError(\n                \"Reassigning a new primary key is not supported yet\"\n            )\n        super().__setattr__(name, value)\n\n    @classmethod\n    def __indexes__(cls) -&gt; Tuple[Union[ODMBaseIndex, pymongo.IndexModel], ...]:\n        indexes: List[Union[ODMBaseIndex, pymongo.IndexModel]] = []\n        for field in cls.__odm_fields__.values():\n            if isinstance(field, ODMBaseIndexableField) and (\n                field.index or field.unique\n            ):\n                indexes.append(\n                    ODMSingleFieldIndex(\n                        key_name=field.key_name,\n                        unique=field.unique,\n                    )\n                )\n        get_indexes_from_config = cls.model_config[\"indexes\"]\n        if get_indexes_from_config is not None:\n            for index in get_indexes_from_config():\n                indexes.append(\n                    index.to_odm_index() if isinstance(index, Index) else index\n                )\n        return tuple(indexes)\n\n    @deprecated(\n        \"update is deprecated, please use model_update instead\",\n    )\n    def update(\n        self,\n        patch_object: Union[BaseModel, Dict[str, Any]],\n        *,\n        include: \"IncEx\" = None,\n        exclude: \"IncEx\" = None,\n        exclude_unset: bool = True,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n    ) -&gt; None:\n        return self.model_update(\n            patch_object,\n            include=include,\n            exclude=exclude,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n        )\n\n    def model_update(\n        self,\n        patch_object: Union[BaseModel, Dict[str, Any]],\n        *,\n        include: \"IncEx\" = None,\n        exclude: \"IncEx\" = None,\n        exclude_unset: bool = True,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n    ) -&gt; None:\n        is_primary_field_in_patch = (\n            isinstance(patch_object, BaseModel)\n            and self.__primary_field__ in patch_object.model_fields\n        ) or (isinstance(patch_object, dict) and self.__primary_field__ in patch_object)\n        if is_primary_field_in_patch:\n            if (\n                include is None\n                and (exclude is None or self.__primary_field__ not in exclude)\n            ) or (\n                include is not None\n                and self.__primary_field__ in include\n                and (exclude is None or self.__primary_field__ not in exclude)\n            ):\n                raise ValueError(\n                    \"Updating the primary key is not supported. \"\n                    \"See the copy method if you want to modify the primary field.\"\n                )\n        return super().model_update(\n            patch_object,\n            include=include,\n            exclude=exclude,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n        )\n</code></pre> <p>             Bases: <code>_BaseODMModel</code></p> <p>Class that can be extended to create an ODMantic Embedded Model.</p> <p>An embedded document cannot be persisted directly to the database but should be integrated in a regular ODMantic Model.</p> Source code in <code>odmantic/model.py</code> <pre><code>class EmbeddedModel(_BaseODMModel, metaclass=EmbeddedModelMetaclass):\n    \"\"\"Class that can be extended to create an ODMantic Embedded Model.\n\n    An embedded document cannot be persisted directly to the database but should be\n    integrated in a regular ODMantic Model.\n    \"\"\"\n</code></pre>"},{"location":"api_reference/model/#odmantic.model._BaseODMModel.model_copy","title":"<code>model_copy(*, update=None, deep=False)</code>","text":"<p>Duplicate a model, optionally choose which fields to change.</p> Danger <p>The data is not validated before creating the new model: you should trust this data.</p> <p>Parameters:</p> Name Type Description Default <code>update</code> <code>Optional['DictStrAny']</code> <p>values to change/add in the new model.</p> <code>None</code> <code>deep</code> <code>bool</code> <p>set to <code>True</code> to make a deep copy of the model</p> <code>False</code> <p>Returns:</p> Type Description <code>BaseT</code> <p>new model instance</p> Source code in <code>odmantic/model.py</code> <pre><code>def model_copy(\n    self: BaseT,\n    *,\n    update: Optional[\"DictStrAny\"] = None,\n    deep: bool = False,\n) -&gt; BaseT:\n    \"\"\"Duplicate a model, optionally choose which fields to change.\n\n    Danger:\n        The data is not validated before creating the new model: **you should trust\n        this data**.\n\n    Arguments:\n        update: values to change/add in the new model.\n        deep: set to `True` to make a deep copy of the model\n\n    Returns:\n        new model instance\n\n    \"\"\"\n    copied = super().model_copy(update=update, deep=deep)\n    copied._post_copy_update()\n    return copied\n</code></pre>"},{"location":"api_reference/model/#odmantic.model._BaseODMModel.model_dump_doc","title":"<code>model_dump_doc(include=None)</code>","text":"<p>Generate a document (BSON) representation of the instance (as a dictionary).</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Optional['AbstractSetIntStr']</code> <p>field that should be included; if None, every fields will be included</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>the document associated to the instance</p> Source code in <code>odmantic/model.py</code> <pre><code>def model_dump_doc(\n    self, include: Optional[\"AbstractSetIntStr\"] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"Generate a document (BSON) representation of the instance (as a dictionary).\n\n    Args:\n        include: field that should be included; if None, every fields will be\n            included\n\n    Returns:\n        the document associated to the instance\n    \"\"\"\n    raw_doc = self.model_dump()\n    doc = self.__doc(raw_doc, type(self), include)\n    return doc\n</code></pre>"},{"location":"api_reference/model/#odmantic.model._BaseODMModel.model_update","title":"<code>model_update(patch_object, *, include=None, exclude=None, exclude_unset=True, exclude_defaults=False, exclude_none=False)</code>","text":"<p>Update instance fields from a Pydantic model or a dictionary.</p> <p>If a pydantic model is provided, only the fields set will be applied by default.</p> <p>Parameters:</p> Name Type Description Default <code>patch_object</code> <code>Union[BaseModel, Dict[str, Any]]</code> <p>object containing the values to update</p> required <code>include</code> <code>'IncEx'</code> <p>fields to include from the <code>patch_object</code> (include all fields if <code>None</code>)</p> <code>None</code> <code>exclude</code> <code>'IncEx'</code> <p>fields to exclude from the <code>patch_object</code>, this takes precedence over include</p> <code>None</code> <code>exclude_unset</code> <code>bool</code> <p>only update fields explicitly set in the patch object (only applies to Pydantic models)</p> <code>True</code> <code>exclude_defaults</code> <code>bool</code> <p>only update fields that are different from their default value in the patch object (only applies to Pydantic models)</p> <code>False</code> <code>exclude_none</code> <code>bool</code> <p>only update fields different from None in the patch object (only applies to Pydantic models)</p> <code>False</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>the modifications would make the instance invalid</p> Source code in <code>odmantic/model.py</code> <pre><code>def model_update(\n    self,\n    patch_object: Union[BaseModel, Dict[str, Any]],\n    *,\n    include: \"IncEx\" = None,\n    exclude: \"IncEx\" = None,\n    exclude_unset: bool = True,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -&gt; None:\n    \"\"\"Update instance fields from a Pydantic model or a dictionary.\n\n    If a pydantic model is provided, only the **fields set** will be\n    applied by default.\n\n    Args:\n        patch_object: object containing the values to update\n        include: fields to include from the `patch_object` (include all fields if\n            `None`)\n        exclude: fields to exclude from the `patch_object`, this takes\n            precedence over include\n        exclude_unset: only update fields explicitly set in the patch object (only\n            applies to Pydantic models)\n        exclude_defaults: only update fields that are different from their default\n            value in the patch object (only applies to Pydantic models)\n        exclude_none: only update fields different from None in the patch object\n            (only applies to Pydantic models)\n\n    Raises:\n        ValidationError: the modifications would make the instance invalid\n\n    &lt;!--\n    #noqa: DAR402 ValidationError\n    --&gt;\n    \"\"\"\n    if isinstance(patch_object, BaseModel):\n        patch_dict = patch_object.model_dump(\n            include=include,\n            exclude=exclude,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n        )\n    else:\n        odm_fields = set(self.__odm_fields__.keys())\n        patch_dict = {}\n        for k, v in patch_object.items():\n            if include is not None and k not in include:\n                continue\n            if exclude is not None and k in exclude:\n                continue\n            if k not in odm_fields:\n                continue\n            patch_dict[k] = v\n    patched_instance_dict = {**self.model_dump(), **patch_dict}\n    # FIXME: improve performance by only running updated field validators and then\n    # model validators\n    patched_instance = self.validate(patched_instance_dict)\n    for name, new_value in patched_instance.__dict__.items():\n        if self.__dict__[name] != new_value:\n            # Manually change the field to avoid running the validators again\n            self.__dict__[name] = new_value\n            self.model_fields_set.add(name)\n            self.__fields_modified__.add(name)\n</code></pre>"},{"location":"api_reference/model/#odmantic.model._BaseODMModel.model_validate_doc","title":"<code>model_validate_doc(raw_doc)</code>  <code>classmethod</code>","text":"<p>Parse a BSON document into an instance of the Model</p> <p>Parameters:</p> Name Type Description Default <code>raw_doc</code> <code>Dict</code> <p>document to parse (as Dict)</p> required <p>Raises:</p> Type Description <code>DocumentParsingError</code> <p>the specified document is invalid</p> <p>Returns:</p> Type Description <code>BaseT</code> <p>an instance of the Model class this method is called on.</p> Source code in <code>odmantic/model.py</code> <pre><code>@classmethod\ndef model_validate_doc(cls: Type[BaseT], raw_doc: Dict) -&gt; BaseT:\n    \"\"\"Parse a BSON document into an instance of the Model\n\n    Args:\n        raw_doc: document to parse (as Dict)\n\n    Raises:\n        DocumentParsingError: the specified document is invalid\n\n    Returns:\n        an instance of the Model class this method is called on.\n    \"\"\"\n    errors, obj = cls._parse_doc_to_obj(raw_doc)\n    if len(errors) &gt; 0:\n        raise DocumentParsingError(\n            errors=errors,\n            model=cls,\n        )\n    try:\n        instance = cls.model_validate(obj)\n    except ValidationError as e:\n        raise DocumentParsingError(\n            errors=e.errors(),  # type: ignore\n            model=cls,\n        )\n\n    return instance\n</code></pre>"},{"location":"api_reference/query/","title":"odmantic.query","text":"<p>             Bases: <code>Dict[str, Any]</code></p> <p>Base object used to build queries.</p> <p>All comparison and logical operators returns <code>QueryExpression</code> objects.</p> <p>The <code>|</code> and <code>&amp;</code> operators are supported for respectively the or and the and logical operators.</p> Warning <p>When using those operators make sure to correctly bracket the expressions to avoid python operator precedence issues.</p> Source code in <code>odmantic/query.py</code> <pre><code>class QueryExpression(Dict[str, Any]):\n    \"\"\"Base object used to build queries.\n\n    All comparison and logical operators returns `QueryExpression` objects.\n\n    The `|` and `&amp;` operators are supported for respectively the\n    [or][odmantic.query.or_] and the [and][odmantic.query.and_] logical operators.\n\n    Warning:\n        When using those operators make sure to correctly bracket the expressions\n        to avoid python operator precedence issues.\n    \"\"\"\n\n    def __repr__(self) -&gt; str:\n        parent_repr = super().__repr__()\n        if parent_repr == \"{}\":\n            parent_repr = \"\"\n        return f\"QueryExpression({parent_repr})\"\n\n    def __or__(self, other: \"QueryExpression\") -&gt; \"QueryExpression\":  # type: ignore\n        return or_(self, other)\n\n    def __and__(self, other: \"QueryExpression\") -&gt; \"QueryExpression\":\n        return and_(self, other)\n</code></pre>"},{"location":"api_reference/query/#logical-operators","title":"Logical Operators","text":"<p>Logical AND operation between multiple <code>QueryExpression</code> objects.</p> Source code in <code>odmantic/query.py</code> <pre><code>def and_(*elements: QueryDictBool) -&gt; QueryExpression:\n    \"\"\"Logical **AND** operation between multiple `QueryExpression` objects.\"\"\"\n    return QueryExpression({\"$and\": elements})\n</code></pre> <p>Logical OR operation between multiple <code>QueryExpression</code> objects.</p> Source code in <code>odmantic/query.py</code> <pre><code>def or_(*elements: QueryDictBool) -&gt; QueryExpression:\n    \"\"\"Logical **OR** operation between multiple `QueryExpression` objects.\"\"\"\n    return QueryExpression({\"$or\": elements})\n</code></pre> <p>Logical NOR operation between multiple <code>QueryExpression</code> objects.</p> Source code in <code>odmantic/query.py</code> <pre><code>def nor_(*elements: QueryDictBool) -&gt; QueryExpression:\n    \"\"\"Logical **NOR** operation between multiple `QueryExpression` objects.\"\"\"\n    return QueryExpression({\"$nor\": elements})\n</code></pre>"},{"location":"api_reference/query/#comparison-operators","title":"Comparison Operators","text":"<p>Equality comparison operator.</p> Source code in <code>odmantic/query.py</code> <pre><code>def eq(field: FieldProxyAny, value: Any) -&gt; QueryExpression:\n    \"\"\"Equality comparison operator.\"\"\"\n    return _cmp_expression(field, \"$eq\", value)\n</code></pre> <p>Inequality comparison operator (includes documents not containing the field).</p> Source code in <code>odmantic/query.py</code> <pre><code>def ne(field: FieldProxyAny, value: Any) -&gt; QueryExpression:\n    \"\"\"Inequality comparison operator (includes documents not containing the field).\"\"\"\n    return _cmp_expression(field, \"$ne\", value)\n</code></pre> <p>Greater than (strict) comparison operator (i.e. &gt;).</p> Source code in <code>odmantic/query.py</code> <pre><code>def gt(field: FieldProxyAny, value: Any) -&gt; QueryExpression:\n    \"\"\"Greater than (strict) comparison operator (i.e. &gt;).\"\"\"\n    return _cmp_expression(field, \"$gt\", value)\n</code></pre> <p>Greater than or equal comparison operator (i.e. &gt;=).</p> Source code in <code>odmantic/query.py</code> <pre><code>def gte(field: FieldProxyAny, value: Any) -&gt; QueryExpression:\n    \"\"\"Greater than or equal comparison operator (i.e. &gt;=).\"\"\"\n    return _cmp_expression(field, \"$gte\", value)\n</code></pre> <p>Less than (strict) comparison operator (i.e. &lt;).</p> Source code in <code>odmantic/query.py</code> <pre><code>def lt(field: FieldProxyAny, value: Any) -&gt; QueryExpression:\n    \"\"\"Less than (strict) comparison operator (i.e. &lt;).\"\"\"\n    return _cmp_expression(field, \"$lt\", value)\n</code></pre> <p>Less than or equal comparison operator (i.e. &lt;=).</p> Source code in <code>odmantic/query.py</code> <pre><code>def lte(field: FieldProxyAny, value: Any) -&gt; QueryExpression:\n    \"\"\"Less than or equal comparison operator (i.e. &lt;=).\"\"\"\n    return _cmp_expression(field, \"$lte\", value)\n</code></pre> <p>Select instances where <code>field</code> is contained in <code>sequence</code>.</p> Source code in <code>odmantic/query.py</code> <pre><code>def in_(field: FieldProxyAny, sequence: Iterable) -&gt; QueryExpression:\n    \"\"\"Select instances where `field` is contained in `sequence`.\"\"\"\n    return _cmp_expression(field, \"$in\", list(sequence))\n</code></pre> <p>Select instances where <code>field</code> is not contained in <code>sequence</code>.</p> Source code in <code>odmantic/query.py</code> <pre><code>def not_in(field: FieldProxyAny, sequence: Iterable) -&gt; QueryExpression:\n    \"\"\"Select instances where `field` is **not** contained in `sequence`.\"\"\"\n    return _cmp_expression(field, \"$nin\", list(sequence))\n</code></pre> <p>Select instances where <code>field</code> matches the <code>pattern</code> regular expression.</p> Source code in <code>odmantic/query.py</code> <pre><code>def match(field: FieldProxyAny, pattern: Union[Pattern, str]) -&gt; QueryExpression:\n    \"\"\"Select instances where `field` matches the `pattern` regular expression.\"\"\"\n    # FIXME might create incompatibilities\n    # https://docs.mongodb.com/manual/reference/operator/query/regex/#regex-and-not\n    if isinstance(pattern, str):\n        r = re.compile(pattern)\n    else:\n        r = pattern\n    return QueryExpression({+field: r})\n</code></pre>"},{"location":"api_reference/query/#sort-helpers","title":"Sort helpers","text":"<p>             Bases: <code>Dict[str, Literal[-1, 1]]</code></p> <p>Base object used to build sort queries.</p> Source code in <code>odmantic/query.py</code> <pre><code>class SortExpression(Dict[str, Literal[-1, 1]]):\n    \"\"\"Base object used to build sort queries.\"\"\"\n\n    def __repr__(self) -&gt; str:\n        parent_repr = super().__repr__()\n        if parent_repr == \"{}\":\n            parent_repr = \"\"\n        return f\"SortExpression({parent_repr})\"\n</code></pre> <p>Sort by ascending <code>field</code>.</p> Source code in <code>odmantic/query.py</code> <pre><code>def asc(field: FieldProxyAny) -&gt; SortExpression:\n    \"\"\"Sort by ascending `field`.\"\"\"\n    return _build_sort_expression(field, 1)\n</code></pre> <p>Sort by descending <code>field</code>.</p> Source code in <code>odmantic/query.py</code> <pre><code>def desc(field: FieldProxyAny) -&gt; SortExpression:\n    \"\"\"Sort by descending `field`.\"\"\"\n    return _build_sort_expression(field, -1)\n</code></pre>"},{"location":"api_reference/reference/","title":"odmantic.reference","text":"<p>Used to define reference fields.</p> <p>Parameters:</p> Name Type Description Default <code>key_name</code> <code>Optional[str]</code> <p>name of the Mongo key that stores the foreign key</p> <code>None</code> Source code in <code>odmantic/reference.py</code> <pre><code>def Reference(*, key_name: Optional[str] = None) -&gt; Any:\n    \"\"\"Used to define reference fields.\n\n    Args:\n        key_name: name of the Mongo key that stores the foreign key\n\n    &lt;!--\n    #noqa: DAR201\n    --&gt;\n    \"\"\"\n    return ODMReferenceInfo(key_name=key_name)\n</code></pre>"},{"location":"api_reference/session/","title":"odmantic.session","text":"<p>             Bases: <code>AIOSessionBase</code>, <code>AsyncContextManager</code></p> <p>An AsyncIO session object for ordering sequential operations.</p> <p>Sessions can be created from the engine directly by using the AIOEngine.session method.</p> <p>Example usage as a context manager: <pre><code>engine = AIOEngine(...)\nasync with engine.session() as session:\n    john = await session.find(User, User.name == \"John\")\n    john.name = \"Doe\"\n    await session.save(john)\n</code></pre></p> <p>Example raw usage: <pre><code>engine = AIOEngine(...)\nsession = engine.session()\nawait session.start()\njohn = await session.find(User, User.name == \"John\")\njohn.name = \"Doe\"\nawait session.save(john)\nawait session.end()\n</code></pre></p> Source code in <code>odmantic/session.py</code> <pre><code>class AIOSession(AIOSessionBase, AsyncContextManager):\n    \"\"\"An AsyncIO session object for ordering sequential operations.\n\n\n    Sessions can be created from the engine directly by using the\n    [AIOEngine.session][odmantic.engine.AIOEngine.session] method.\n\n    Example usage as a context manager:\n    ```python\n    engine = AIOEngine(...)\n    async with engine.session() as session:\n        john = await session.find(User, User.name == \"John\")\n        john.name = \"Doe\"\n        await session.save(john)\n    ```\n\n    Example raw usage:\n    ```python\n    engine = AIOEngine(...)\n    session = engine.session()\n    await session.start()\n    john = await session.find(User, User.name == \"John\")\n    john.name = \"Doe\"\n    await session.save(john)\n    await session.end()\n    ```\n    \"\"\"\n\n    def __init__(self, engine: ODMEngine.AIOEngine):\n        self.engine = engine\n        self.session: Optional[AsyncIOMotorClientSession] = None\n\n    @property\n    def is_started(self) -&gt; bool:\n        return self.session is not None\n\n    def get_driver_session(self) -&gt; AsyncIOMotorClientSession:\n        \"\"\"Return the underlying Motor Session\"\"\"\n        if self.session is None:\n            raise RuntimeError(\"session not started\")\n        return self.session\n\n    async def start(self) -&gt; None:\n        \"\"\"Start the logical Mongo session.\"\"\"\n        if self.is_started:\n            raise RuntimeError(\"Session is already started\")\n        self.session = await self.engine.client.start_session()\n\n    async def end(self) -&gt; None:\n        \"\"\"Finish the logical session.\"\"\"\n        if self.session is None:\n            raise RuntimeError(\"Session is not started\")\n        await self.session.end_session()\n        self.session = None\n\n    async def __aenter__(self) -&gt; \"AIOSession\":\n        await self.start()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc: Optional[BaseException],\n        traceback: Optional[TracebackType],\n    ) -&gt; None:\n        await self.end()\n\n    def transaction(self) -&gt; AIOTransaction:\n        \"\"\"Create a transaction in the existing session\"\"\"\n        return AIOTransaction(self)\n</code></pre> <p>             Bases: <code>AIOSessionBase</code>, <code>AsyncContextManager</code></p> <p>A transaction object to aggregate sequential operations.</p> <p>Transactions can be created from the engine using the AIOEngine.transaction method or they can be created during an existing session by using AIOSession.transaction.</p> <p>Example usage as a context manager: <pre><code>engine = AIOEngine(...)\nasync with engine.transaction() as transaction:\n    john = await transaction.find(User, User.name == \"John\")\n    john.name = \"Doe\"\n    await transaction.save(john)\n    await transaction.commit()\n</code></pre></p> <p>Example raw usage: <pre><code>engine = AIOEngine(...)\ntransaction = engine.transaction()\nawait transaction.start()\njohn = await transaction.find(User, User.name == \"John\")\njohn.name = \"Doe\"\nawait transaction.save(john)\nawait transaction.commit()\n</code></pre></p> Warning <p>MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled.</p> Source code in <code>odmantic/session.py</code> <pre><code>class AIOTransaction(AIOSessionBase, AsyncContextManager):\n    \"\"\"A transaction object to aggregate sequential operations.\n\n    Transactions can be created from the engine using the\n    [AIOEngine.transaction][odmantic.engine.AIOEngine.transaction]\n    method or they can be created during an existing session by using\n    [AIOSession.transaction][odmantic.session.AIOSession.transaction].\n\n    Example usage as a context manager:\n    ```python\n    engine = AIOEngine(...)\n    async with engine.transaction() as transaction:\n        john = await transaction.find(User, User.name == \"John\")\n        john.name = \"Doe\"\n        await transaction.save(john)\n        await transaction.commit()\n    ```\n\n    Example raw usage:\n    ```python\n    engine = AIOEngine(...)\n    transaction = engine.transaction()\n    await transaction.start()\n    john = await transaction.find(User, User.name == \"John\")\n    john.name = \"Doe\"\n    await transaction.save(john)\n    await transaction.commit()\n    ```\n\n    Warning:\n        MongoDB transaction are only supported on replicated clusters: either directly a\n        replicaSet or a sharded cluster with replication enabled.\n    \"\"\"\n\n    def __init__(self, context: Union[ODMEngine.AIOEngine, ODMEngine.AIOSession]):\n        self._session_provided = isinstance(context, ODMEngine.AIOSession)\n        if self._session_provided:\n            assert isinstance(context, ODMEngine.AIOSession)\n            if not context.is_started:\n                raise RuntimeError(\"provided session is not started\")\n            self.session = context\n            self.engine = context.engine\n        else:\n            assert isinstance(context, ODMEngine.AIOEngine)\n            self.session = AIOSession(context)\n            self.engine = context\n\n        self._transaction_started = False\n        self._transaction_context: Optional[AsyncContextManager] = None\n\n    def get_driver_session(self) -&gt; AsyncIOMotorClientSession:\n        \"\"\"Return the underlying Motor Session\"\"\"\n        if not self._transaction_started:\n            raise RuntimeError(\"transaction not started\")\n        return self.session.get_driver_session()\n\n    async def start(self) -&gt; None:\n        \"\"\"Initiate the transaction.\"\"\"\n        if self._transaction_started:\n            raise RuntimeError(\"Transaction already started\")\n        if not self._session_provided:\n            await self.session.start()\n        assert self.session.session is not None\n        self._transaction_context = (\n            await self.session.session.start_transaction().__aenter__()\n        )\n        self._transaction_started = True\n\n    async def commit(self) -&gt; None:\n        \"\"\"Commit the changes and close the transaction.\"\"\"\n        if not self._transaction_started:\n            raise RuntimeError(\"Transaction not started\")\n        assert self.session.session is not None\n        await self.session.session.commit_transaction()\n        self._transaction_started = False\n        if not self._session_provided:\n            await self.session.end()\n\n    async def abort(self) -&gt; None:\n        \"\"\"Discard the changes and drop the transaction\"\"\"\n        if not self._transaction_started:\n            raise RuntimeError(\"Transaction not started\")\n        assert self.session.session is not None\n        await self.session.session.abort_transaction()\n        self._transaction_started = False\n        if not self._session_provided:\n            await self.session.end()\n\n    async def __aenter__(self) -&gt; \"AIOTransaction\":\n        await self.start()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc: Optional[BaseException],\n        traceback: Optional[TracebackType],\n    ) -&gt; None:\n        assert self._transaction_context is not None\n        await self._transaction_context.__aexit__(exc_type, exc, traceback)\n        self._transaction_started = False\n</code></pre> Source code in <code>odmantic/session.py</code> <pre><code>class AIOSessionBase(metaclass=ABCMeta):\n    engine: ODMEngine.AIOEngine\n\n    def find(\n        self,\n        model: Type[ODMEngine.ModelType],\n        *queries: Union[\n            QueryExpression, Dict, bool\n        ],  # bool: allow using binary operators with mypy\n        sort: Optional[Any] = None,\n        skip: int = 0,\n        limit: Optional[int] = None,\n    ) -&gt; ODMEngine.AIOCursor[ODMEngine.ModelType]:\n        \"\"\"Search for Model instances matching the query filter provided\n\n        Args:\n            model: model to perform the operation on\n            *queries: query filter to apply\n            sort: sort expression\n            skip: number of document to skip\n            limit: maximum number of instance fetched\n\n        Returns:\n            [odmantic.engine.AIOCursor][] of the query\n\n        \"\"\"\n        return self.engine.find(\n            model,\n            *queries,\n            sort=sort,\n            skip=skip,\n            limit=limit,\n            session=self.engine._get_session(self),\n        )\n\n    async def find_one(\n        self,\n        model: Type[ODMEngine.ModelType],\n        *queries: Union[\n            QueryExpression, Dict, bool\n        ],  # bool: allow using binary operators w/o plugin\n        sort: Optional[Any] = None,\n    ) -&gt; Optional[ODMEngine.ModelType]:\n        \"\"\"Search for a Model instance matching the query filter provided\n\n        Args:\n            model: model to perform the operation on\n            *queries: query filter to apply\n            sort: sort expression\n\n        Raises:\n            DocumentParsingError: unable to parse the resulting document\n\n        Returns:\n            the fetched instance if found otherwise None\n\n        &lt;!---\n        #noqa: DAR402 DocumentParsingError\n        --&gt;\n        \"\"\"\n        return await self.engine.find_one(\n            model, *queries, sort=sort, session=self.engine._get_session(self)\n        )\n\n    async def count(\n        self,\n        model: Type[ODMEngine.ModelType],\n        *queries: Union[QueryExpression, Dict, bool],\n    ) -&gt; int:\n        \"\"\"Get the count of documents matching a query\n\n        Args:\n            model: model to perform the operation on\n            *queries: query filters to apply\n\n        Returns:\n            number of document matching the query\n        \"\"\"\n        return await self.engine.count(\n            model, *queries, session=self.engine._get_session(self)\n        )\n\n    async def save(\n        self,\n        instance: ODMEngine.ModelType,\n    ) -&gt; ODMEngine.ModelType:\n        \"\"\"Persist an instance to the database\n\n        This method behaves as an 'upsert' operation. If a document already exists\n        with the same primary key, it will be overwritten.\n\n        All the other models referenced by this instance will be saved as well.\n\n        Args:\n            instance: instance to persist\n\n        Returns:\n            the saved instance\n\n        NOTE:\n            The save operation actually modify the instance argument in place. However,\n            the instance is still returned for convenience.\n        \"\"\"\n        return await self.engine.save(instance, session=self.engine._get_session(self))\n\n    async def save_all(\n        self,\n        instances: Sequence[ODMEngine.ModelType],\n    ) -&gt; List[ODMEngine.ModelType]:\n        \"\"\"Persist instances to the database\n\n        This method behaves as multiple 'upsert' operations. If one of the document\n        already exists with the same primary key, it will be overwritten.\n\n        All the other models referenced by this instance will be recursively saved as\n        well.\n\n        Args:\n            instances: instances to persist\n\n        Returns:\n            the saved instances\n\n        NOTE:\n            The save_all operation actually modify the arguments in place. However, the\n            instances are still returned for convenience.\n        \"\"\"\n        return await self.engine.save_all(\n            instances, session=self.engine._get_session(self)\n        )\n\n    async def delete(\n        self,\n        instance: ODMEngine.ModelType,\n    ) -&gt; None:\n        \"\"\"Delete an instance from the database\n\n        Args:\n            instance: the instance to delete\n\n        Raises:\n            DocumentNotFoundError: the instance has not been persisted to the database\n\n        &lt;!---\n        #noqa: DAR402 DocumentNotFoundError\n        #noqa: DAR201\n        --&gt;\n        \"\"\"\n        return await self.engine.delete(\n            instance, session=self.engine._get_session(self)\n        )\n\n    async def remove(\n        self,\n        model: Type[ODMEngine.ModelType],\n        *queries: Union[QueryExpression, Dict, bool],\n        just_one: bool = False,\n    ) -&gt; int:\n        \"\"\"Delete Model instances matching the query filter provided\n\n        Args:\n            model: model to perform the operation on\n            *queries: query filter to apply\n            just_one: limit the deletion to just one document\n\n        Returns:\n            the number of instances deleted from the database.\n        \"\"\"\n        return await self.engine.remove(\n            model, *queries, just_one=just_one, session=self.engine._get_session(self)\n        )\n</code></pre> <p>             Bases: <code>SyncSessionBase</code>, <code>ContextManager</code></p> <p>A session object for ordering sequential operations.</p> <p>Sessions can be created from the engine directly by using the SyncEngine.session method.</p> <p>Example usage as a context manager: <pre><code>engine = SyncEngine(...)\nwith engine.session() as session:\n    john = session.find(User, User.name == \"John\")\n    john.name = \"Doe\"\n    session.save(john)\n</code></pre></p> <p>Example raw usage: <pre><code>engine = SyncEngine(...)\nsession = engine.session()\nsession.start()\njohn = session.find(User, User.name == \"John\")\njohn.name = \"Doe\"\nsession.save(john)\nsession.end()\n</code></pre></p> Source code in <code>odmantic/session.py</code> <pre><code>class SyncSession(SyncSessionBase, ContextManager):\n    \"\"\"A session object for ordering sequential operations.\n\n    Sessions can be created from the engine directly by using the\n    [SyncEngine.session][odmantic.engine.SyncEngine.session] method.\n\n    Example usage as a context manager:\n    ```python\n    engine = SyncEngine(...)\n    with engine.session() as session:\n        john = session.find(User, User.name == \"John\")\n        john.name = \"Doe\"\n        session.save(john)\n    ```\n\n    Example raw usage:\n    ```python\n    engine = SyncEngine(...)\n    session = engine.session()\n    session.start()\n    john = session.find(User, User.name == \"John\")\n    john.name = \"Doe\"\n    session.save(john)\n    session.end()\n    ```\n    \"\"\"\n\n    def __init__(self, engine: ODMEngine.SyncEngine):\n        self.engine = engine\n        self.session: Optional[ClientSession] = None\n\n    @property\n    def is_started(self) -&gt; bool:\n        return self.session is not None\n\n    def get_driver_session(self) -&gt; ClientSession:\n        \"\"\"Return the underlying PyMongo Session\"\"\"\n        if self.session is None:\n            raise RuntimeError(\"session not started\")\n        return self.session\n\n    def start(self) -&gt; None:\n        \"\"\"Start the logical session.\"\"\"\n        if self.is_started:\n            raise RuntimeError(\"Session is already started\")\n        self.session = self.engine.client.start_session()\n\n    def end(self) -&gt; None:\n        \"\"\"Finish the logical session.\"\"\"\n        if self.session is None:\n            raise RuntimeError(\"Session is not started\")\n        self.session.end_session()\n        self.session = None\n\n    def __enter__(self) -&gt; \"SyncSession\":\n        self.start()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc: Optional[BaseException],\n        traceback: Optional[TracebackType],\n    ) -&gt; None:\n        self.end()\n\n    def transaction(self) -&gt; SyncTransaction:\n        \"\"\"Create a transaction in the existing session\"\"\"\n        return SyncTransaction(self)\n</code></pre> <p>             Bases: <code>SyncSessionBase</code>, <code>ContextManager</code></p> <p>A transaction object to aggregate sequential operations.</p> <p>Transactions can be created from the engine using the SyncEngine.transaction method or they can be created during an existing session by using SyncSession.transaction.</p> <p>Example usage as a context manager: <pre><code>engine = SyncEngine(...)\nwith engine.transaction() as transaction:\n    john = transaction.find(User, User.name == \"John\")\n    john.name = \"Doe\"\n    transaction.save(john)\n    transaction.commit()\n</code></pre></p> <p>Example raw usage: <pre><code>engine = SyncEngine(...)\ntransaction = engine.transaction()\ntransaction.start()\njohn = transaction.find(User, User.name == \"John\")\njohn.name = \"Doe\"\ntransaction.save(john)\ntransaction.commit()\n</code></pre></p> Warning <p>MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled.</p> Source code in <code>odmantic/session.py</code> <pre><code>class SyncTransaction(SyncSessionBase, ContextManager):\n    \"\"\"A transaction object to aggregate sequential operations.\n\n    Transactions can be created from the engine using the\n    [SyncEngine.transaction][odmantic.engine.SyncEngine.transaction]\n    method or they can be created during an existing session by using\n    [SyncSession.transaction][odmantic.session.SyncSession.transaction].\n\n    Example usage as a context manager:\n    ```python\n    engine = SyncEngine(...)\n    with engine.transaction() as transaction:\n        john = transaction.find(User, User.name == \"John\")\n        john.name = \"Doe\"\n        transaction.save(john)\n        transaction.commit()\n    ```\n\n    Example raw usage:\n    ```python\n    engine = SyncEngine(...)\n    transaction = engine.transaction()\n    transaction.start()\n    john = transaction.find(User, User.name == \"John\")\n    john.name = \"Doe\"\n    transaction.save(john)\n    transaction.commit()\n    ```\n\n    Warning:\n        MongoDB transaction are only supported on replicated clusters: either directly a\n        replicaSet or a sharded cluster with replication enabled.\n    \"\"\"\n\n    def __init__(self, context: Union[ODMEngine.SyncEngine, ODMEngine.SyncSession]):\n        self._session_provided = isinstance(context, ODMEngine.SyncSession)\n        if self._session_provided:\n            assert isinstance(context, ODMEngine.SyncSession)\n            if not context.is_started:\n                raise RuntimeError(\"provided session is not started\")\n            self.session = context\n            self.engine = context.engine\n        else:\n            assert isinstance(context, ODMEngine.SyncEngine)\n            self.session = SyncSession(context)\n            self.engine = context\n\n        self._transaction_started = False\n        self._transaction_context: Optional[ContextManager] = None\n\n    def get_driver_session(self) -&gt; ClientSession:\n        \"\"\"Return the underlying PyMongo Session\"\"\"\n        if not self._transaction_started:\n            raise RuntimeError(\"transaction not started\")\n        return self.session.get_driver_session()\n\n    def start(self) -&gt; None:\n        \"\"\"Initiate the transaction.\"\"\"\n        if self._transaction_started:\n            raise RuntimeError(\"Transaction already started\")\n        if not self._session_provided:\n            self.session.start()\n        assert self.session.session is not None\n        self._transaction_context = self.session.session.start_transaction().__enter__()\n        self._transaction_started = True\n\n    def commit(self) -&gt; None:\n        \"\"\"Commit the changes and close the transaction.\"\"\"\n        if not self._transaction_started:\n            raise RuntimeError(\"Transaction not started\")\n        assert self.session.session is not None\n        self.session.session.commit_transaction()\n        self._transaction_started = False\n        if not self._session_provided:\n            self.session.end()\n\n    def abort(self) -&gt; None:\n        \"\"\"Discard the changes and drop the transaction.\"\"\"\n        if not self._transaction_started:\n            raise RuntimeError(\"Transaction not started\")\n        assert self.session.session is not None\n        self.session.session.abort_transaction()\n        self._transaction_started = False\n        if not self._session_provided:\n            self.session.end()\n\n    def __enter__(self) -&gt; \"SyncTransaction\":\n        self.start()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc: Optional[BaseException],\n        traceback: Optional[TracebackType],\n    ) -&gt; None:\n        assert self._transaction_context is not None\n        self._transaction_context.__exit__(exc_type, exc, traceback)\n        self._transaction_started = False\n</code></pre> Source code in <code>odmantic/session.py</code> <pre><code>class SyncSessionBase(metaclass=ABCMeta):\n    engine: ODMEngine.SyncEngine\n\n    def find(\n        self,\n        model: Type[ODMEngine.ModelType],\n        *queries: Union[\n            QueryExpression, Dict, bool\n        ],  # bool: allow using binary operators with mypy\n        sort: Optional[Any] = None,\n        skip: int = 0,\n        limit: Optional[int] = None,\n    ) -&gt; ODMEngine.SyncCursor[ODMEngine.ModelType]:\n        \"\"\"Search for Model instances matching the query filter provided\n\n        Args:\n            model: model to perform the operation on\n            *queries: query filter to apply\n            sort: sort expression\n            skip: number of document to skip\n            limit: maximum number of instance fetched\n\n        Returns:\n            [odmantic.engine.SyncCursor][] of the query\n\n        \"\"\"\n        return self.engine.find(\n            model,\n            *queries,\n            sort=sort,\n            skip=skip,\n            limit=limit,\n            session=self.engine._get_session(self),\n        )\n\n    def find_one(\n        self,\n        model: Type[ODMEngine.ModelType],\n        *queries: Union[\n            QueryExpression, Dict, bool\n        ],  # bool: allow using binary operators w/o plugin\n        sort: Optional[Any] = None,\n    ) -&gt; Optional[ODMEngine.ModelType]:\n        \"\"\"Search for a Model instance matching the query filter provided\n\n        Args:\n            model: model to perform the operation on\n            *queries: query filter to apply\n            sort: sort expression\n\n        Raises:\n            DocumentParsingError: unable to parse the resulting document\n\n        Returns:\n            the fetched instance if found otherwise None\n\n        &lt;!---\n        #noqa: DAR402 DocumentParsingError\n        --&gt;\n        \"\"\"\n        return self.engine.find_one(\n            model, *queries, sort=sort, session=self.engine._get_session(self)\n        )\n\n    def count(\n        self,\n        model: Type[ODMEngine.ModelType],\n        *queries: Union[QueryExpression, Dict, bool],\n    ) -&gt; int:\n        \"\"\"Get the count of documents matching a query\n\n        Args:\n            model: model to perform the operation on\n            *queries: query filters to apply\n\n        Returns:\n            number of document matching the query\n        \"\"\"\n        return self.engine.count(\n            model, *queries, session=self.engine._get_session(self)\n        )\n\n    def save(\n        self,\n        instance: ODMEngine.ModelType,\n    ) -&gt; ODMEngine.ModelType:\n        \"\"\"Persist an instance to the database\n\n        This method behaves as an 'upsert' operation. If a document already exists\n        with the same primary key, it will be overwritten.\n\n        All the other models referenced by this instance will be saved as well.\n\n        Args:\n            instance: instance to persist\n\n        Returns:\n            the saved instance\n\n        NOTE:\n            The save operation actually modify the instance argument in place. However,\n            the instance is still returned for convenience.\n        \"\"\"\n        return self.engine.save(instance, session=self.engine._get_session(self))\n\n    def save_all(\n        self,\n        instances: Sequence[ODMEngine.ModelType],\n    ) -&gt; List[ODMEngine.ModelType]:\n        \"\"\"Persist instances to the database\n\n        This method behaves as multiple 'upsert' operations. If one of the document\n        already exists with the same primary key, it will be overwritten.\n\n        All the other models referenced by this instance will be recursively saved as\n        well.\n\n        Args:\n            instances: instances to persist\n\n        Returns:\n            the saved instances\n\n        NOTE:\n            The save_all operation actually modify the arguments in place. However, the\n            instances are still returned for convenience.\n        \"\"\"\n        return self.engine.save_all(instances, session=self.engine._get_session(self))\n\n    def delete(\n        self,\n        instance: ODMEngine.ModelType,\n    ) -&gt; None:\n        \"\"\"Delete an instance from the database\n\n        Args:\n            instance: the instance to delete\n\n        Raises:\n            DocumentNotFoundError: the instance has not been persisted to the database\n\n        &lt;!---\n        #noqa: DAR402 DocumentNotFoundError\n        #noqa: DAR201\n        --&gt;\n        \"\"\"\n        return self.engine.delete(instance, session=self.engine._get_session(self))\n\n    def remove(\n        self,\n        model: Type[ODMEngine.ModelType],\n        *queries: Union[QueryExpression, Dict, bool],\n        just_one: bool = False,\n    ) -&gt; int:\n        \"\"\"Delete Model instances matching the query filter provided\n\n        Args:\n            model: model to perform the operation on\n            *queries: query filter to apply\n            just_one: limit the deletion to just one document\n\n        Returns:\n            the number of instances deleted from the database.\n\n        \"\"\"\n        return self.engine.remove(\n            model, *queries, just_one=just_one, session=self.engine._get_session(self)\n        )\n</code></pre>"},{"location":"api_reference/session/#odmantic.session.AIOSession.end","title":"<code>end()</code>  <code>async</code>","text":"<p>Finish the logical session.</p> Source code in <code>odmantic/session.py</code> <pre><code>async def end(self) -&gt; None:\n    \"\"\"Finish the logical session.\"\"\"\n    if self.session is None:\n        raise RuntimeError(\"Session is not started\")\n    await self.session.end_session()\n    self.session = None\n</code></pre>"},{"location":"api_reference/session/#odmantic.session.AIOSession.get_driver_session","title":"<code>get_driver_session()</code>","text":"<p>Return the underlying Motor Session</p> Source code in <code>odmantic/session.py</code> <pre><code>def get_driver_session(self) -&gt; AsyncIOMotorClientSession:\n    \"\"\"Return the underlying Motor Session\"\"\"\n    if self.session is None:\n        raise RuntimeError(\"session not started\")\n    return self.session\n</code></pre>"},{"location":"api_reference/session/#odmantic.session.AIOSession.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Start the logical Mongo session.</p> Source code in <code>odmantic/session.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"Start the logical Mongo session.\"\"\"\n    if self.is_started:\n        raise RuntimeError(\"Session is already started\")\n    self.session = await self.engine.client.start_session()\n</code></pre>"},{"location":"api_reference/session/#odmantic.session.AIOSession.transaction","title":"<code>transaction()</code>","text":"<p>Create a transaction in the existing session</p> Source code in <code>odmantic/session.py</code> <pre><code>def transaction(self) -&gt; AIOTransaction:\n    \"\"\"Create a transaction in the existing session\"\"\"\n    return AIOTransaction(self)\n</code></pre>"},{"location":"api_reference/session/#odmantic.engine.AIOTransaction.abort","title":"<code>abort()</code>  <code>async</code>","text":"<p>Discard the changes and drop the transaction</p> Source code in <code>odmantic/session.py</code> <pre><code>async def abort(self) -&gt; None:\n    \"\"\"Discard the changes and drop the transaction\"\"\"\n    if not self._transaction_started:\n        raise RuntimeError(\"Transaction not started\")\n    assert self.session.session is not None\n    await self.session.session.abort_transaction()\n    self._transaction_started = False\n    if not self._session_provided:\n        await self.session.end()\n</code></pre>"},{"location":"api_reference/session/#odmantic.engine.AIOTransaction.commit","title":"<code>commit()</code>  <code>async</code>","text":"<p>Commit the changes and close the transaction.</p> Source code in <code>odmantic/session.py</code> <pre><code>async def commit(self) -&gt; None:\n    \"\"\"Commit the changes and close the transaction.\"\"\"\n    if not self._transaction_started:\n        raise RuntimeError(\"Transaction not started\")\n    assert self.session.session is not None\n    await self.session.session.commit_transaction()\n    self._transaction_started = False\n    if not self._session_provided:\n        await self.session.end()\n</code></pre>"},{"location":"api_reference/session/#odmantic.engine.AIOTransaction.get_driver_session","title":"<code>get_driver_session()</code>","text":"<p>Return the underlying Motor Session</p> Source code in <code>odmantic/session.py</code> <pre><code>def get_driver_session(self) -&gt; AsyncIOMotorClientSession:\n    \"\"\"Return the underlying Motor Session\"\"\"\n    if not self._transaction_started:\n        raise RuntimeError(\"transaction not started\")\n    return self.session.get_driver_session()\n</code></pre>"},{"location":"api_reference/session/#odmantic.engine.AIOTransaction.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Initiate the transaction.</p> Source code in <code>odmantic/session.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"Initiate the transaction.\"\"\"\n    if self._transaction_started:\n        raise RuntimeError(\"Transaction already started\")\n    if not self._session_provided:\n        await self.session.start()\n    assert self.session.session is not None\n    self._transaction_context = (\n        await self.session.session.start_transaction().__aenter__()\n    )\n    self._transaction_started = True\n</code></pre>"},{"location":"api_reference/session/#odmantic.session.AIOSessionBase.count","title":"<code>count(model, *queries)</code>  <code>async</code>","text":"<p>Get the count of documents matching a query</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[ModelType]</code> <p>model to perform the operation on</p> required <code>*queries</code> <code>Union[QueryExpression, Dict, bool]</code> <p>query filters to apply</p> <code>()</code> <p>Returns:</p> Type Description <code>int</code> <p>number of document matching the query</p> Source code in <code>odmantic/session.py</code> <pre><code>async def count(\n    self,\n    model: Type[ODMEngine.ModelType],\n    *queries: Union[QueryExpression, Dict, bool],\n) -&gt; int:\n    \"\"\"Get the count of documents matching a query\n\n    Args:\n        model: model to perform the operation on\n        *queries: query filters to apply\n\n    Returns:\n        number of document matching the query\n    \"\"\"\n    return await self.engine.count(\n        model, *queries, session=self.engine._get_session(self)\n    )\n</code></pre>"},{"location":"api_reference/session/#odmantic.session.AIOSessionBase.delete","title":"<code>delete(instance)</code>  <code>async</code>","text":"<p>Delete an instance from the database</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>ModelType</code> <p>the instance to delete</p> required <p>Raises:</p> Type Description <code>DocumentNotFoundError</code> <p>the instance has not been persisted to the database</p> Source code in <code>odmantic/session.py</code> <pre><code>async def delete(\n    self,\n    instance: ODMEngine.ModelType,\n) -&gt; None:\n    \"\"\"Delete an instance from the database\n\n    Args:\n        instance: the instance to delete\n\n    Raises:\n        DocumentNotFoundError: the instance has not been persisted to the database\n\n    &lt;!---\n    #noqa: DAR402 DocumentNotFoundError\n    #noqa: DAR201\n    --&gt;\n    \"\"\"\n    return await self.engine.delete(\n        instance, session=self.engine._get_session(self)\n    )\n</code></pre>"},{"location":"api_reference/session/#odmantic.session.AIOSessionBase.find","title":"<code>find(model, *queries, sort=None, skip=0, limit=None)</code>","text":"<p>Search for Model instances matching the query filter provided</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[ModelType]</code> <p>model to perform the operation on</p> required <code>*queries</code> <code>Union[QueryExpression, Dict, bool]</code> <p>query filter to apply</p> <code>()</code> <code>sort</code> <code>Optional[Any]</code> <p>sort expression</p> <code>None</code> <code>skip</code> <code>int</code> <p>number of document to skip</p> <code>0</code> <code>limit</code> <code>Optional[int]</code> <p>maximum number of instance fetched</p> <code>None</code> <p>Returns:</p> Type Description <code>AIOCursor[ModelType]</code> <p>odmantic.engine.AIOCursor of the query</p> Source code in <code>odmantic/session.py</code> <pre><code>def find(\n    self,\n    model: Type[ODMEngine.ModelType],\n    *queries: Union[\n        QueryExpression, Dict, bool\n    ],  # bool: allow using binary operators with mypy\n    sort: Optional[Any] = None,\n    skip: int = 0,\n    limit: Optional[int] = None,\n) -&gt; ODMEngine.AIOCursor[ODMEngine.ModelType]:\n    \"\"\"Search for Model instances matching the query filter provided\n\n    Args:\n        model: model to perform the operation on\n        *queries: query filter to apply\n        sort: sort expression\n        skip: number of document to skip\n        limit: maximum number of instance fetched\n\n    Returns:\n        [odmantic.engine.AIOCursor][] of the query\n\n    \"\"\"\n    return self.engine.find(\n        model,\n        *queries,\n        sort=sort,\n        skip=skip,\n        limit=limit,\n        session=self.engine._get_session(self),\n    )\n</code></pre>"},{"location":"api_reference/session/#odmantic.session.AIOSessionBase.find_one","title":"<code>find_one(model, *queries, sort=None)</code>  <code>async</code>","text":"<p>Search for a Model instance matching the query filter provided</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[ModelType]</code> <p>model to perform the operation on</p> required <code>*queries</code> <code>Union[QueryExpression, Dict, bool]</code> <p>query filter to apply</p> <code>()</code> <code>sort</code> <code>Optional[Any]</code> <p>sort expression</p> <code>None</code> <p>Raises:</p> Type Description <code>DocumentParsingError</code> <p>unable to parse the resulting document</p> <p>Returns:</p> Type Description <code>Optional[ModelType]</code> <p>the fetched instance if found otherwise None</p> Source code in <code>odmantic/session.py</code> <pre><code>async def find_one(\n    self,\n    model: Type[ODMEngine.ModelType],\n    *queries: Union[\n        QueryExpression, Dict, bool\n    ],  # bool: allow using binary operators w/o plugin\n    sort: Optional[Any] = None,\n) -&gt; Optional[ODMEngine.ModelType]:\n    \"\"\"Search for a Model instance matching the query filter provided\n\n    Args:\n        model: model to perform the operation on\n        *queries: query filter to apply\n        sort: sort expression\n\n    Raises:\n        DocumentParsingError: unable to parse the resulting document\n\n    Returns:\n        the fetched instance if found otherwise None\n\n    &lt;!---\n    #noqa: DAR402 DocumentParsingError\n    --&gt;\n    \"\"\"\n    return await self.engine.find_one(\n        model, *queries, sort=sort, session=self.engine._get_session(self)\n    )\n</code></pre>"},{"location":"api_reference/session/#odmantic.session.AIOSessionBase.remove","title":"<code>remove(model, *queries, just_one=False)</code>  <code>async</code>","text":"<p>Delete Model instances matching the query filter provided</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[ModelType]</code> <p>model to perform the operation on</p> required <code>*queries</code> <code>Union[QueryExpression, Dict, bool]</code> <p>query filter to apply</p> <code>()</code> <code>just_one</code> <code>bool</code> <p>limit the deletion to just one document</p> <code>False</code> <p>Returns:</p> Type Description <code>int</code> <p>the number of instances deleted from the database.</p> Source code in <code>odmantic/session.py</code> <pre><code>async def remove(\n    self,\n    model: Type[ODMEngine.ModelType],\n    *queries: Union[QueryExpression, Dict, bool],\n    just_one: bool = False,\n) -&gt; int:\n    \"\"\"Delete Model instances matching the query filter provided\n\n    Args:\n        model: model to perform the operation on\n        *queries: query filter to apply\n        just_one: limit the deletion to just one document\n\n    Returns:\n        the number of instances deleted from the database.\n    \"\"\"\n    return await self.engine.remove(\n        model, *queries, just_one=just_one, session=self.engine._get_session(self)\n    )\n</code></pre>"},{"location":"api_reference/session/#odmantic.session.AIOSessionBase.save","title":"<code>save(instance)</code>  <code>async</code>","text":"<p>Persist an instance to the database</p> <p>This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten.</p> <p>All the other models referenced by this instance will be saved as well.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>ModelType</code> <p>instance to persist</p> required <p>Returns:</p> Type Description <code>ModelType</code> <p>the saved instance</p> NOTE <p>The save operation actually modify the instance argument in place. However, the instance is still returned for convenience.</p> Source code in <code>odmantic/session.py</code> <pre><code>async def save(\n    self,\n    instance: ODMEngine.ModelType,\n) -&gt; ODMEngine.ModelType:\n    \"\"\"Persist an instance to the database\n\n    This method behaves as an 'upsert' operation. If a document already exists\n    with the same primary key, it will be overwritten.\n\n    All the other models referenced by this instance will be saved as well.\n\n    Args:\n        instance: instance to persist\n\n    Returns:\n        the saved instance\n\n    NOTE:\n        The save operation actually modify the instance argument in place. However,\n        the instance is still returned for convenience.\n    \"\"\"\n    return await self.engine.save(instance, session=self.engine._get_session(self))\n</code></pre>"},{"location":"api_reference/session/#odmantic.session.AIOSessionBase.save_all","title":"<code>save_all(instances)</code>  <code>async</code>","text":"<p>Persist instances to the database</p> <p>This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten.</p> <p>All the other models referenced by this instance will be recursively saved as well.</p> <p>Parameters:</p> Name Type Description Default <code>instances</code> <code>Sequence[ModelType]</code> <p>instances to persist</p> required <p>Returns:</p> Type Description <code>List[ModelType]</code> <p>the saved instances</p> NOTE <p>The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience.</p> Source code in <code>odmantic/session.py</code> <pre><code>async def save_all(\n    self,\n    instances: Sequence[ODMEngine.ModelType],\n) -&gt; List[ODMEngine.ModelType]:\n    \"\"\"Persist instances to the database\n\n    This method behaves as multiple 'upsert' operations. If one of the document\n    already exists with the same primary key, it will be overwritten.\n\n    All the other models referenced by this instance will be recursively saved as\n    well.\n\n    Args:\n        instances: instances to persist\n\n    Returns:\n        the saved instances\n\n    NOTE:\n        The save_all operation actually modify the arguments in place. However, the\n        instances are still returned for convenience.\n    \"\"\"\n    return await self.engine.save_all(\n        instances, session=self.engine._get_session(self)\n    )\n</code></pre>"},{"location":"api_reference/session/#odmantic.engine.SyncSession.end","title":"<code>end()</code>","text":"<p>Finish the logical session.</p> Source code in <code>odmantic/session.py</code> <pre><code>def end(self) -&gt; None:\n    \"\"\"Finish the logical session.\"\"\"\n    if self.session is None:\n        raise RuntimeError(\"Session is not started\")\n    self.session.end_session()\n    self.session = None\n</code></pre>"},{"location":"api_reference/session/#odmantic.engine.SyncSession.get_driver_session","title":"<code>get_driver_session()</code>","text":"<p>Return the underlying PyMongo Session</p> Source code in <code>odmantic/session.py</code> <pre><code>def get_driver_session(self) -&gt; ClientSession:\n    \"\"\"Return the underlying PyMongo Session\"\"\"\n    if self.session is None:\n        raise RuntimeError(\"session not started\")\n    return self.session\n</code></pre>"},{"location":"api_reference/session/#odmantic.engine.SyncSession.start","title":"<code>start()</code>","text":"<p>Start the logical session.</p> Source code in <code>odmantic/session.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the logical session.\"\"\"\n    if self.is_started:\n        raise RuntimeError(\"Session is already started\")\n    self.session = self.engine.client.start_session()\n</code></pre>"},{"location":"api_reference/session/#odmantic.engine.SyncSession.transaction","title":"<code>transaction()</code>","text":"<p>Create a transaction in the existing session</p> Source code in <code>odmantic/session.py</code> <pre><code>def transaction(self) -&gt; SyncTransaction:\n    \"\"\"Create a transaction in the existing session\"\"\"\n    return SyncTransaction(self)\n</code></pre>"},{"location":"api_reference/session/#odmantic.engine.SyncTransaction.abort","title":"<code>abort()</code>","text":"<p>Discard the changes and drop the transaction.</p> Source code in <code>odmantic/session.py</code> <pre><code>def abort(self) -&gt; None:\n    \"\"\"Discard the changes and drop the transaction.\"\"\"\n    if not self._transaction_started:\n        raise RuntimeError(\"Transaction not started\")\n    assert self.session.session is not None\n    self.session.session.abort_transaction()\n    self._transaction_started = False\n    if not self._session_provided:\n        self.session.end()\n</code></pre>"},{"location":"api_reference/session/#odmantic.engine.SyncTransaction.commit","title":"<code>commit()</code>","text":"<p>Commit the changes and close the transaction.</p> Source code in <code>odmantic/session.py</code> <pre><code>def commit(self) -&gt; None:\n    \"\"\"Commit the changes and close the transaction.\"\"\"\n    if not self._transaction_started:\n        raise RuntimeError(\"Transaction not started\")\n    assert self.session.session is not None\n    self.session.session.commit_transaction()\n    self._transaction_started = False\n    if not self._session_provided:\n        self.session.end()\n</code></pre>"},{"location":"api_reference/session/#odmantic.engine.SyncTransaction.get_driver_session","title":"<code>get_driver_session()</code>","text":"<p>Return the underlying PyMongo Session</p> Source code in <code>odmantic/session.py</code> <pre><code>def get_driver_session(self) -&gt; ClientSession:\n    \"\"\"Return the underlying PyMongo Session\"\"\"\n    if not self._transaction_started:\n        raise RuntimeError(\"transaction not started\")\n    return self.session.get_driver_session()\n</code></pre>"},{"location":"api_reference/session/#odmantic.engine.SyncTransaction.start","title":"<code>start()</code>","text":"<p>Initiate the transaction.</p> Source code in <code>odmantic/session.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Initiate the transaction.\"\"\"\n    if self._transaction_started:\n        raise RuntimeError(\"Transaction already started\")\n    if not self._session_provided:\n        self.session.start()\n    assert self.session.session is not None\n    self._transaction_context = self.session.session.start_transaction().__enter__()\n    self._transaction_started = True\n</code></pre>"},{"location":"api_reference/session/#odmantic.engine.SyncSessionBase.count","title":"<code>count(model, *queries)</code>","text":"<p>Get the count of documents matching a query</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[ModelType]</code> <p>model to perform the operation on</p> required <code>*queries</code> <code>Union[QueryExpression, Dict, bool]</code> <p>query filters to apply</p> <code>()</code> <p>Returns:</p> Type Description <code>int</code> <p>number of document matching the query</p> Source code in <code>odmantic/session.py</code> <pre><code>def count(\n    self,\n    model: Type[ODMEngine.ModelType],\n    *queries: Union[QueryExpression, Dict, bool],\n) -&gt; int:\n    \"\"\"Get the count of documents matching a query\n\n    Args:\n        model: model to perform the operation on\n        *queries: query filters to apply\n\n    Returns:\n        number of document matching the query\n    \"\"\"\n    return self.engine.count(\n        model, *queries, session=self.engine._get_session(self)\n    )\n</code></pre>"},{"location":"api_reference/session/#odmantic.engine.SyncSessionBase.delete","title":"<code>delete(instance)</code>","text":"<p>Delete an instance from the database</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>ModelType</code> <p>the instance to delete</p> required <p>Raises:</p> Type Description <code>DocumentNotFoundError</code> <p>the instance has not been persisted to the database</p> Source code in <code>odmantic/session.py</code> <pre><code>def delete(\n    self,\n    instance: ODMEngine.ModelType,\n) -&gt; None:\n    \"\"\"Delete an instance from the database\n\n    Args:\n        instance: the instance to delete\n\n    Raises:\n        DocumentNotFoundError: the instance has not been persisted to the database\n\n    &lt;!---\n    #noqa: DAR402 DocumentNotFoundError\n    #noqa: DAR201\n    --&gt;\n    \"\"\"\n    return self.engine.delete(instance, session=self.engine._get_session(self))\n</code></pre>"},{"location":"api_reference/session/#odmantic.engine.SyncSessionBase.find","title":"<code>find(model, *queries, sort=None, skip=0, limit=None)</code>","text":"<p>Search for Model instances matching the query filter provided</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[ModelType]</code> <p>model to perform the operation on</p> required <code>*queries</code> <code>Union[QueryExpression, Dict, bool]</code> <p>query filter to apply</p> <code>()</code> <code>sort</code> <code>Optional[Any]</code> <p>sort expression</p> <code>None</code> <code>skip</code> <code>int</code> <p>number of document to skip</p> <code>0</code> <code>limit</code> <code>Optional[int]</code> <p>maximum number of instance fetched</p> <code>None</code> <p>Returns:</p> Type Description <code>SyncCursor[ModelType]</code> <p>odmantic.engine.SyncCursor of the query</p> Source code in <code>odmantic/session.py</code> <pre><code>def find(\n    self,\n    model: Type[ODMEngine.ModelType],\n    *queries: Union[\n        QueryExpression, Dict, bool\n    ],  # bool: allow using binary operators with mypy\n    sort: Optional[Any] = None,\n    skip: int = 0,\n    limit: Optional[int] = None,\n) -&gt; ODMEngine.SyncCursor[ODMEngine.ModelType]:\n    \"\"\"Search for Model instances matching the query filter provided\n\n    Args:\n        model: model to perform the operation on\n        *queries: query filter to apply\n        sort: sort expression\n        skip: number of document to skip\n        limit: maximum number of instance fetched\n\n    Returns:\n        [odmantic.engine.SyncCursor][] of the query\n\n    \"\"\"\n    return self.engine.find(\n        model,\n        *queries,\n        sort=sort,\n        skip=skip,\n        limit=limit,\n        session=self.engine._get_session(self),\n    )\n</code></pre>"},{"location":"api_reference/session/#odmantic.engine.SyncSessionBase.find_one","title":"<code>find_one(model, *queries, sort=None)</code>","text":"<p>Search for a Model instance matching the query filter provided</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[ModelType]</code> <p>model to perform the operation on</p> required <code>*queries</code> <code>Union[QueryExpression, Dict, bool]</code> <p>query filter to apply</p> <code>()</code> <code>sort</code> <code>Optional[Any]</code> <p>sort expression</p> <code>None</code> <p>Raises:</p> Type Description <code>DocumentParsingError</code> <p>unable to parse the resulting document</p> <p>Returns:</p> Type Description <code>Optional[ModelType]</code> <p>the fetched instance if found otherwise None</p> Source code in <code>odmantic/session.py</code> <pre><code>def find_one(\n    self,\n    model: Type[ODMEngine.ModelType],\n    *queries: Union[\n        QueryExpression, Dict, bool\n    ],  # bool: allow using binary operators w/o plugin\n    sort: Optional[Any] = None,\n) -&gt; Optional[ODMEngine.ModelType]:\n    \"\"\"Search for a Model instance matching the query filter provided\n\n    Args:\n        model: model to perform the operation on\n        *queries: query filter to apply\n        sort: sort expression\n\n    Raises:\n        DocumentParsingError: unable to parse the resulting document\n\n    Returns:\n        the fetched instance if found otherwise None\n\n    &lt;!---\n    #noqa: DAR402 DocumentParsingError\n    --&gt;\n    \"\"\"\n    return self.engine.find_one(\n        model, *queries, sort=sort, session=self.engine._get_session(self)\n    )\n</code></pre>"},{"location":"api_reference/session/#odmantic.engine.SyncSessionBase.remove","title":"<code>remove(model, *queries, just_one=False)</code>","text":"<p>Delete Model instances matching the query filter provided</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[ModelType]</code> <p>model to perform the operation on</p> required <code>*queries</code> <code>Union[QueryExpression, Dict, bool]</code> <p>query filter to apply</p> <code>()</code> <code>just_one</code> <code>bool</code> <p>limit the deletion to just one document</p> <code>False</code> <p>Returns:</p> Type Description <code>int</code> <p>the number of instances deleted from the database.</p> Source code in <code>odmantic/session.py</code> <pre><code>def remove(\n    self,\n    model: Type[ODMEngine.ModelType],\n    *queries: Union[QueryExpression, Dict, bool],\n    just_one: bool = False,\n) -&gt; int:\n    \"\"\"Delete Model instances matching the query filter provided\n\n    Args:\n        model: model to perform the operation on\n        *queries: query filter to apply\n        just_one: limit the deletion to just one document\n\n    Returns:\n        the number of instances deleted from the database.\n\n    \"\"\"\n    return self.engine.remove(\n        model, *queries, just_one=just_one, session=self.engine._get_session(self)\n    )\n</code></pre>"},{"location":"api_reference/session/#odmantic.engine.SyncSessionBase.save","title":"<code>save(instance)</code>","text":"<p>Persist an instance to the database</p> <p>This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten.</p> <p>All the other models referenced by this instance will be saved as well.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>ModelType</code> <p>instance to persist</p> required <p>Returns:</p> Type Description <code>ModelType</code> <p>the saved instance</p> NOTE <p>The save operation actually modify the instance argument in place. However, the instance is still returned for convenience.</p> Source code in <code>odmantic/session.py</code> <pre><code>def save(\n    self,\n    instance: ODMEngine.ModelType,\n) -&gt; ODMEngine.ModelType:\n    \"\"\"Persist an instance to the database\n\n    This method behaves as an 'upsert' operation. If a document already exists\n    with the same primary key, it will be overwritten.\n\n    All the other models referenced by this instance will be saved as well.\n\n    Args:\n        instance: instance to persist\n\n    Returns:\n        the saved instance\n\n    NOTE:\n        The save operation actually modify the instance argument in place. However,\n        the instance is still returned for convenience.\n    \"\"\"\n    return self.engine.save(instance, session=self.engine._get_session(self))\n</code></pre>"},{"location":"api_reference/session/#odmantic.engine.SyncSessionBase.save_all","title":"<code>save_all(instances)</code>","text":"<p>Persist instances to the database</p> <p>This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten.</p> <p>All the other models referenced by this instance will be recursively saved as well.</p> <p>Parameters:</p> Name Type Description Default <code>instances</code> <code>Sequence[ModelType]</code> <p>instances to persist</p> required <p>Returns:</p> Type Description <code>List[ModelType]</code> <p>the saved instances</p> NOTE <p>The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience.</p> Source code in <code>odmantic/session.py</code> <pre><code>def save_all(\n    self,\n    instances: Sequence[ODMEngine.ModelType],\n) -&gt; List[ODMEngine.ModelType]:\n    \"\"\"Persist instances to the database\n\n    This method behaves as multiple 'upsert' operations. If one of the document\n    already exists with the same primary key, it will be overwritten.\n\n    All the other models referenced by this instance will be recursively saved as\n    well.\n\n    Args:\n        instances: instances to persist\n\n    Returns:\n        the saved instances\n\n    NOTE:\n        The save_all operation actually modify the arguments in place. However, the\n        instances are still returned for convenience.\n    \"\"\"\n    return self.engine.save_all(instances, session=self.engine._get_session(self))\n</code></pre>"}]}