{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ODMantic Documentation : https://art049.github.io/odmantic/ Sync and Async ODM (Object Document Mapper) for MongoDB based on standard python type hints. Built on top of pydantic for model definition and validation. Core features: Simple : define your model by typing your fields using python types, build queries using python comparison operators Developer experience : field/method autocompletion, type hints, data validation, perform database operations with a functional API Fully typed : leverage static analysis to reduce runtime issues AsyncIO support : works well with ASGI frameworks ( FastAPI , quart , sanic , Starlette , ...) but works also perfectly in synchronous environments Serialization : built in JSON serialization and JSON schema generation Requirements \u00b6 Python : 3.7 and later (tested against 3.7, 3.8, 3.9 and 3.10) MongoDB : 4.0 and later Installation \u00b6 pip install odmantic Example \u00b6 To enjoy an async context without any code boilerplate, you can reproduce the following steps using the AsyncIO REPL (only for Python 3.8+). python3.8 -m asyncio If you are using an earlier version of Python you can use IPython which provide an Autoawait feature (starting from Python 3.6). Define your first model \u00b6 from typing import Optional from odmantic import Field , Model class Publisher ( Model ): name : str founded : int = Field ( ge = 1440 ) location : Optional [ str ] = None By defining the Publisher class, we've just created an ODMantic model \ud83c\udf89. In this example, the model will represent book publishers. This model contains three fields: name : This is the name of the Publisher. This is a simple string field without any specific validation but it will be required to build a new Publisher. founded : This is the year of foundation of the Publisher. Since the printing press has been invented in 1440, it would be handy to allow only values above 1440. The ge keyword argument passed to the Field is exactly doing this. The model will require a founded value greater or equal than 1440. location : This field will contain the country code of the Publisher. Defining this field as Optional with a None default value makes it a non required field that will be set automatically when not specified. The collection name has been defined by ODMantic as well. In this case it will be publisher . Create some instances \u00b6 instances = [ Publisher ( name = \"HarperCollins\" , founded = 1989 , location = \"US\" ), Publisher ( name = \"Hachette Livre\" , founded = 1826 , location = \"FR\" ), Publisher ( name = \"Lulu\" , founded = 2002 ) ] We defined three instances of the Publisher model. They all have a name property as it was required. All the foundations years are later than 1440. The last publisher has no location specified so by default this field is set to None (it will be stored as null in the database). For now, those instances only exists locally. We will persist them in a database in the next step. Populate the database with your instances \u00b6 For the next steps, you'll need to start a local MongoDB server.The easiest way is to use docker. Simply run the next command in a terminal (closing the terminal will terminate the MongoDB instance and remove the container). docker run --rm -p 27017 :27017 mongo First, let's connect to the database using the engine. In ODMantic, every database operation is performed using the engine object. from odmantic import AIOEngine engine = AIOEngine () By default, the AIOEngine (stands for AsyncIOEngine) automatically tries to connect to a MongoDB instance running locally (on port 27017). Since we didn't provide any database name, it will use the database named test by default. The next step is to persist the instances we created before. We can perform this operation using the AIOEngine.save_all method. await engine . save_all ( instances ) Most of the engine I/O methods are asynchronous, hence the await keyword used here. Once the operation is complete, we should be able to see our created documents in the database. You can use Compass or RoboMongo if you'd like to have a graphical interface. Another possibility is to use mongo CLI directly: mongo --eval \"db.publisher.find({})\" Output: co nne c t i n g t o : mo n godb : //127.0.0.1:27017 { \"_id\" : Objec t Id( \"5f67b331514d6855bc5c54c9\" ) , \"founded\" : 1989 , \"location\" : \"US\" , \"name\" : \"HarperCollins\" }, { \"_id\" : Objec t Id( \"5f67b331514d6855bc5c54ca\" ) , \"founded\" : 1826 , \"location\" : \"FR\" , \"name\" : \"Hachette Livre\" }, { \"_id\" : Objec t Id( \"5f67b331514d6855bc5c54cb\" ) , \"founded\" : 2002 , \"location\" : null , \"name\" : \"Lulu\" } The created instances are stored in the test database under the publisher collection. We can see that an _id field has been added to each document. MongoDB need this field to act as a primary key. Actually, this field is added by ODMantic and you can access it under the name id . print ( instances [ 0 ] . id ) #> ObjectId(\"5f67b331514d6855bc5c54c9\") Find instances matching a criteria \u00b6 Since we now have some documents in the database, we can start building some queries. First, let's find publishers created before the 2000s: early_publishers = await engine . find ( Publisher , Publisher . founded <= 2000 ) print ( early_publishers ) #> [Publisher(name=\"HarperCollins\", founded=1989, location=\"US), #> Publisher(name=\"Hachette Livre\", founded=1826, location=\"FR\")] Here, we called the engine.find method. The first argument we need to specify is the Model class we want to query on (in our case Publisher ). The second argument is the actual query. Similarly to SQLAlchemy , you can build ODMantic queries using the regular python operators. When awaited, the engine.find method will return the list of matching instances stored in the database. Another possibility is to query for at most one instance. For example, if we want to retrieve a publisher from Canada (CA): ca_publisher = await engine . find_one ( Publisher , Publisher . location == \"CA\" ) print ( ca_publisher ) #> None Here the result is None because no matching instances have been found in the database. The engine.find_one method returns an instance if one exists in the database otherwise, it will return None . Modify an instance \u00b6 Finally, let's edit some instances. For example, we can set the location for the publisher named Lulu . First, we need to gather the instance from the database: lulu = await engine . find_one ( Publisher , Publisher . name == \"Lulu\" ) print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=None) We still have the same instance, with no location set. We can change this field: lulu . location = \"US\" print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=\"US) The location has been changed locally but the last step to persist this change is to save the document: await engine . save ( lulu ) We can now check the database state: mongo --eval \"db.publisher.find({name: 'Lulu'})\" Output: co nne c t i n g t o : mo n godb : //127.0.0.1:27017 { \"_id\" : Objec t Id( \"5f67b331514d6855bc5c54cb\" ) , \"founded\" : 2002 , \"location\" : \"US\" , \"name\" : \"Lulu\" } The document have been successfully updated ! Now, what if we would like to change the foundation date with an invalid one (before 1440) ? lulu . founded = 1000 #> ValidationError: 1 validation error for Publisher #> founded #> ensure this value is greater than 1440 #> (type=value_error.number.not_gt; limit_value=1440) This will raise an exception as it's not matching the model definition. The raised exception is actually a ValidationError created by from pydantic . Next steps \u00b6 If you already have experience with Pydantic and FastAPI, the Usage with FastAPI example sould be interesting for you to get kickstarted. Otherwise, to get started on more advanced practices like relations and building more advanced queries, you can directly check the other sections of the documentation . If you wish to contribute to the project (Thank you! ), you can have a look to the Contributing section of the documentation. License \u00b6 This project is licensed under the terms of the ISC license .","title":"Overview"},{"location":"#requirements","text":"Python : 3.7 and later (tested against 3.7, 3.8, 3.9 and 3.10) MongoDB : 4.0 and later","title":"Requirements"},{"location":"#installation","text":"pip install odmantic","title":"Installation"},{"location":"#example","text":"To enjoy an async context without any code boilerplate, you can reproduce the following steps using the AsyncIO REPL (only for Python 3.8+). python3.8 -m asyncio If you are using an earlier version of Python you can use IPython which provide an Autoawait feature (starting from Python 3.6).","title":"Example"},{"location":"#define-your-first-model","text":"from typing import Optional from odmantic import Field , Model class Publisher ( Model ): name : str founded : int = Field ( ge = 1440 ) location : Optional [ str ] = None By defining the Publisher class, we've just created an ODMantic model \ud83c\udf89. In this example, the model will represent book publishers. This model contains three fields: name : This is the name of the Publisher. This is a simple string field without any specific validation but it will be required to build a new Publisher. founded : This is the year of foundation of the Publisher. Since the printing press has been invented in 1440, it would be handy to allow only values above 1440. The ge keyword argument passed to the Field is exactly doing this. The model will require a founded value greater or equal than 1440. location : This field will contain the country code of the Publisher. Defining this field as Optional with a None default value makes it a non required field that will be set automatically when not specified. The collection name has been defined by ODMantic as well. In this case it will be publisher .","title":"Define your first model"},{"location":"#create-some-instances","text":"instances = [ Publisher ( name = \"HarperCollins\" , founded = 1989 , location = \"US\" ), Publisher ( name = \"Hachette Livre\" , founded = 1826 , location = \"FR\" ), Publisher ( name = \"Lulu\" , founded = 2002 ) ] We defined three instances of the Publisher model. They all have a name property as it was required. All the foundations years are later than 1440. The last publisher has no location specified so by default this field is set to None (it will be stored as null in the database). For now, those instances only exists locally. We will persist them in a database in the next step.","title":"Create some instances"},{"location":"#populate-the-database-with-your-instances","text":"For the next steps, you'll need to start a local MongoDB server.The easiest way is to use docker. Simply run the next command in a terminal (closing the terminal will terminate the MongoDB instance and remove the container). docker run --rm -p 27017 :27017 mongo First, let's connect to the database using the engine. In ODMantic, every database operation is performed using the engine object. from odmantic import AIOEngine engine = AIOEngine () By default, the AIOEngine (stands for AsyncIOEngine) automatically tries to connect to a MongoDB instance running locally (on port 27017). Since we didn't provide any database name, it will use the database named test by default. The next step is to persist the instances we created before. We can perform this operation using the AIOEngine.save_all method. await engine . save_all ( instances ) Most of the engine I/O methods are asynchronous, hence the await keyword used here. Once the operation is complete, we should be able to see our created documents in the database. You can use Compass or RoboMongo if you'd like to have a graphical interface. Another possibility is to use mongo CLI directly: mongo --eval \"db.publisher.find({})\" Output: co nne c t i n g t o : mo n godb : //127.0.0.1:27017 { \"_id\" : Objec t Id( \"5f67b331514d6855bc5c54c9\" ) , \"founded\" : 1989 , \"location\" : \"US\" , \"name\" : \"HarperCollins\" }, { \"_id\" : Objec t Id( \"5f67b331514d6855bc5c54ca\" ) , \"founded\" : 1826 , \"location\" : \"FR\" , \"name\" : \"Hachette Livre\" }, { \"_id\" : Objec t Id( \"5f67b331514d6855bc5c54cb\" ) , \"founded\" : 2002 , \"location\" : null , \"name\" : \"Lulu\" } The created instances are stored in the test database under the publisher collection. We can see that an _id field has been added to each document. MongoDB need this field to act as a primary key. Actually, this field is added by ODMantic and you can access it under the name id . print ( instances [ 0 ] . id ) #> ObjectId(\"5f67b331514d6855bc5c54c9\")","title":"Populate the database with your instances"},{"location":"#find-instances-matching-a-criteria","text":"Since we now have some documents in the database, we can start building some queries. First, let's find publishers created before the 2000s: early_publishers = await engine . find ( Publisher , Publisher . founded <= 2000 ) print ( early_publishers ) #> [Publisher(name=\"HarperCollins\", founded=1989, location=\"US), #> Publisher(name=\"Hachette Livre\", founded=1826, location=\"FR\")] Here, we called the engine.find method. The first argument we need to specify is the Model class we want to query on (in our case Publisher ). The second argument is the actual query. Similarly to SQLAlchemy , you can build ODMantic queries using the regular python operators. When awaited, the engine.find method will return the list of matching instances stored in the database. Another possibility is to query for at most one instance. For example, if we want to retrieve a publisher from Canada (CA): ca_publisher = await engine . find_one ( Publisher , Publisher . location == \"CA\" ) print ( ca_publisher ) #> None Here the result is None because no matching instances have been found in the database. The engine.find_one method returns an instance if one exists in the database otherwise, it will return None .","title":"Find instances matching a criteria"},{"location":"#modify-an-instance","text":"Finally, let's edit some instances. For example, we can set the location for the publisher named Lulu . First, we need to gather the instance from the database: lulu = await engine . find_one ( Publisher , Publisher . name == \"Lulu\" ) print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=None) We still have the same instance, with no location set. We can change this field: lulu . location = \"US\" print ( lulu ) #> Publisher(name=\"Lulu\", founded=2002, location=\"US) The location has been changed locally but the last step to persist this change is to save the document: await engine . save ( lulu ) We can now check the database state: mongo --eval \"db.publisher.find({name: 'Lulu'})\" Output: co nne c t i n g t o : mo n godb : //127.0.0.1:27017 { \"_id\" : Objec t Id( \"5f67b331514d6855bc5c54cb\" ) , \"founded\" : 2002 , \"location\" : \"US\" , \"name\" : \"Lulu\" } The document have been successfully updated ! Now, what if we would like to change the foundation date with an invalid one (before 1440) ? lulu . founded = 1000 #> ValidationError: 1 validation error for Publisher #> founded #> ensure this value is greater than 1440 #> (type=value_error.number.not_gt; limit_value=1440) This will raise an exception as it's not matching the model definition. The raised exception is actually a ValidationError created by from pydantic .","title":"Modify an instance"},{"location":"#next-steps","text":"If you already have experience with Pydantic and FastAPI, the Usage with FastAPI example sould be interesting for you to get kickstarted. Otherwise, to get started on more advanced practices like relations and building more advanced queries, you can directly check the other sections of the documentation . If you wish to contribute to the project (Thank you! ), you can have a look to the Contributing section of the documentation.","title":"Next steps"},{"location":"#license","text":"This project is licensed under the terms of the ISC license .","title":"License"},{"location":"changelog/","text":"Changelog \u00b6 The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased \u00b6 0.9.0 - 2022-09-25 \u00b6 Added \u00b6 Create new generic types to support generic collection types ( #240 by @erny & @art049 ) Thus, it's now possible to define models like this in python 3.9+ \ud83d\ude80: class User ( Model ): scopes : list [ str ] friendsIds : list [ ObjectId ] skills : set [ str ] Allow using generators with in_ and not_in ( #270 by @art049 ) Fixed \u00b6 Fix EmbeddedModel generics definition with a custom key_name ( #269 by @art049 ) Raise a TypeError when defining a Reference in a generic(List, Dict, Tuple, ...) containing EmbeddedModels ( #269 by @art049 ) 0.8.0 - 2022-09-09 \u00b6 Added \u00b6 Allow Index definition ( feature documentation ) ( #255 by @art049 ) Allow using the Config.extra attribute from pydantic ( #259 by @art049 ) Fixed \u00b6 Fix embedded models parsing with custom key_name ( #262 by @iXB3 ) Fix engine.save using an embedded model as a primary key ( #258 by @art049 ) Fix engine creation typo in the documentation ( #257 by @art049 ) 0.7.1 - 2022-09-02 \u00b6 Fixed \u00b6 Fix dataclass transform constructor type hints ( #249 by @art049 ) Internals \u00b6 Update Mongo version in the CI build matrix ( #247 by @art049 ) 0.7.0 - 2022-08-30 \u00b6 Added \u00b6 Add new SyncEngine, support async and sync code ( #231 by @tiangolo ) Sync engine documentation ( #238 by @art049 ) Friendly interface for session and transactions ( #244 by @art049 ) Implement the engine.remove method to allow instance deletion from a query ( #147 & #237 by @joeriddles & @art049 ) Internals \u00b6 Remove unnecessary Python 3.6 type fixes ( #243 by @art049 ) Switch Mongo action to art049/mongodb-cluster-action ( #245 by @art049 ) Add Realworld API integrated test ( #246 by @art049 ) 0.6.0 - 2022-08-24 \u00b6 Breaking Changes \u00b6 Drop support for Python 3.6 ( #230 by @tiangolo ) Added \u00b6 Upgrade types and add support for instance autocompletion with dataclass_transform (VS Code autocompletion) ( #230 by @tiangolo ) Support Python 3.10 ( #235 by @art049 ) Fixed \u00b6 Fix using the shared session when updating a document ( #227 by @tiangolo ) Fix EmbeddedModel deep copy mutability ( #239 by @art049 ) Allow models to contain string-based datetime fields that indicate UTC ( #136 by @kfox ) Fix Reference usage with non the non default primary key ( #184 by @dynalz ) Fix key_name use on EmbeddedModels ( #195 by @jvanegmond ) Internals \u00b6 Support Python 3.10 in tox ( #236 by @art049 ) Fix missing f string in an exception message ( #222 by @voglster ) Finalize flit migration ( #232 by @art049 ) 0.5.0 - 2022-06-01 \u00b6 Support motor 3.0 ( #224 by @art049 ) Support pydantic 1.9.0 ( #218 by @art049 ) 0.4.0 - 2022-04-23 \u00b6 Added \u00b6 Update and copy methods: Updating multiple fields at once is now directly possible from a pydantic model or a dictionary ( feature documentation , sample use case with FastAPI ) Changing the primary field of an instance is now easier ( documentation ) Patch and copy Model instances ( #39 by @art049 ) Fixed \u00b6 Update example in README ( #192 by @jasper-moment ) Update README.md ( #129 by @Kludex ) Internals \u00b6 \u2b06\ufe0f Update motor requirement from >=2.1.0,<2.5.0 to >=2.1.0,<2.6.0 ( #160 by @dependabot[bot] ) \u2b06\ufe0f Update typer requirement from ^0.3.2 to ^0.4.1 ( #214 by @dependabot[bot] ) \u2b06\ufe0f Update mypy requirement from ^0.910 to ^0.942 ( #215 by @dependabot[bot] ) \u2b06\ufe0f Update fastapi requirement from >=0.61.1,<0.67.0 to >=0.61.1,<0.69.0 ( #166 by @dependabot[bot] ) \u2b06\ufe0f Update fastapi requirement from >=0.61.1,<0.64.0 to >=0.61.1,<0.67.0 ( #150 by @dependabot[bot] ) \u2b06\ufe0f Update mypy requirement from ^0.812 to ^0.910 ( #142 by @dependabot[bot] ) \u2b06\ufe0f Update pytest-asyncio requirement from ^0.14.0 to ^0.15.0 ( #125 by @dependabot[bot] ) \u2b06\ufe0f Update motor requirement from >=2.1.0,<2.4.0 to >=2.1.0,<2.5.0 ( #124 by @dependabot[bot] ) \u2b06\ufe0f Update importlib-metadata requirement from >=1,<4 to >=1,<5 ( #126 by @dependabot[bot] ) \u2b06\ufe0f Update pydocstyle requirement from ^5.1.1 to ^6.0.0 ( #119 by @dependabot[bot] ) \u2b06\ufe0f Update isort requirement from ~=5.7.0 to ~=5.8.0 ( #122 by @dependabot[bot] ) \u2b06\ufe0f Update flake8 requirement from ~=3.8.4 to ~=3.9.0 ( #116 by @dependabot[bot] ) 0.3.5 - 2021-05-12 \u00b6 Security \u00b6 Change allowed pydantic versions to handle CVE-2021-29510 by @art049 0.3.4 - 2021-03-04 \u00b6 Fixed \u00b6 Fix modified mark clearing on save for nested models ( #88 by @Olegt0rr ) Don't replace default field description for ObjectId ( #82 by @Olegt0rr ) Internals \u00b6 Support pydantic 1.8 ( #113 by @art049 ) Add nightly builds ( #114 by @art049 ) CI Matrix with Standalone instances, ReplicaSets and Sharded clusters ( #91 by @art049 ) Update mkdocstrings requirement from ^0.14.0 to ^0.15.0 ( #110 by @dependabot[bot] ) Update mkdocs-material requirement from ^6.0.2 to ^7.0.3 ( #111 by @dependabot[bot] ) Update mypy requirement from ^0.800 to ^0.812 ( #106 by @dependabot[bot] ) 0.3.3 - 2021-02-13 \u00b6 Fixed \u00b6 Remove bypass_document_validation save option to avoid Not Authorized errors ( #85 by @Olegt0rr ) Fix microseconds issue: use truncation instead of round ( #100 by @erny ) Add py.typed to ship typing information for mypy ( #101 by @art049 ) Fix datetime field default example value naiveness ( #103 by @art049 ) Internals \u00b6 Update pytz requirement from ^2020.1 to ^2021.1 ( #98 by @dependabot[bot] ) Update mkdocstrings requirement from ^0.13.2 to ^0.14.0 ( #92 by @dependabot[bot] ) Update mypy requirement from ^0.790 to ^0.800 ( #97 by @dependabot[bot] ) Update isort requirement from ~=5.6.4 to ~=5.7.0 ( #90 by @dependabot[bot] ) Update fastapi requirement from >=0.61.1,<0.63.0 to >=0.61.1,<0.64.0 ( #84 by @dependabot[bot] ) 0.3.2 - 2020-12-15 \u00b6 Added \u00b6 Fix embedded model field update ( #77 by @art049 ) Fix datetime bson inheritance issue ( #78 by @Olegt0rr ) Internals \u00b6 Migrate to the updated prettier precommit hook ( #74 by @art049 ) Fix tox dependency install ( #72 by @art049 ) Update uvicorn requirement from ^0.12.1 to ^0.13.0 ( #67 by @dependabot[bot] ) Update mypy requirement from ^0.782 to ^0.790 ( #48 by @dependabot[bot] ) Update importlib-metadata requirement from ^1.0 to >=1,<4 ( #54 by @dependabot[bot] ) Update flake8 requirement from ==3.8.3 to ==3.8.4 ( #47 by @dependabot[bot] ) Update fastapi requirement from ^0.61.1 to >=0.61.1,<0.63.0 ( #59 by @dependabot[bot] ) 0.3.1 - 2020-11-16 \u00b6 Added \u00b6 Add schema_extra config option ( #41 by @art049 ) Fixed \u00b6 Fix setattr error on a manually initialized EmbeddedModel ( #40 by @art049 ) 0.3.0 - 2020-11-09 \u00b6 Deprecated \u00b6 Deprecate usage of __collection__ to customize the collection name. Prefer the collection Config option ( more details ) Added \u00b6 Allow parsing document with unset fields defaults ( documentation ) ( #28 by @art049 ) Integration with Pydantic Config class ( #37 by @art049 ): It's now possible to define custom json_encoders on the Models Some other Config options provided by Pydantic are now available ( more details ) Support CPython 3.9 ( #32 by @art049 ) Unpin pydantic to support 1.7.0 ( #29 by @art049 ) 0.2.1 - 2020-10-25 \u00b6 Fixed \u00b6 Fix combined use of skip and limit with engine.find ( #25 by @art049 ) 0.2.0 - 2020-10-25 \u00b6 Deprecated \u00b6 Deprecate AIOEngineDependency to prefer a global engine object, more details ( #21 by @art049 ) Added \u00b6 Add sorting support ( #17 by @adriencaccia ) Support motor 2.3.0 ( #20 by @art049 ) Fixed \u00b6 Fix FastAPI usage with References ( #19 by @art049 ) Docs \u00b6 Adding a CONTRIBUTING.md file to the root directory with link to docs ( #8 by @sanders41 ) Raw Query Usage Documentation Fix ( #10 by @adeelsohailahmed ) Update Filtering to include Bitwise Operator Warning ( #24 by @adeelsohailahmed ) 0.1.0 - 2020-10-19 \u00b6 Initial Release \u00b6","title":"Changelog"},{"location":"changelog/#changelog","text":"The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#090-2022-09-25","text":"","title":"0.9.0 - 2022-09-25"},{"location":"changelog/#added","text":"Create new generic types to support generic collection types ( #240 by @erny & @art049 ) Thus, it's now possible to define models like this in python 3.9+ \ud83d\ude80: class User ( Model ): scopes : list [ str ] friendsIds : list [ ObjectId ] skills : set [ str ] Allow using generators with in_ and not_in ( #270 by @art049 )","title":"Added"},{"location":"changelog/#fixed","text":"Fix EmbeddedModel generics definition with a custom key_name ( #269 by @art049 ) Raise a TypeError when defining a Reference in a generic(List, Dict, Tuple, ...) containing EmbeddedModels ( #269 by @art049 )","title":"Fixed"},{"location":"changelog/#080-2022-09-09","text":"","title":"0.8.0 - 2022-09-09"},{"location":"changelog/#added_1","text":"Allow Index definition ( feature documentation ) ( #255 by @art049 ) Allow using the Config.extra attribute from pydantic ( #259 by @art049 )","title":"Added"},{"location":"changelog/#fixed_1","text":"Fix embedded models parsing with custom key_name ( #262 by @iXB3 ) Fix engine.save using an embedded model as a primary key ( #258 by @art049 ) Fix engine creation typo in the documentation ( #257 by @art049 )","title":"Fixed"},{"location":"changelog/#071-2022-09-02","text":"","title":"0.7.1 - 2022-09-02"},{"location":"changelog/#fixed_2","text":"Fix dataclass transform constructor type hints ( #249 by @art049 )","title":"Fixed"},{"location":"changelog/#internals","text":"Update Mongo version in the CI build matrix ( #247 by @art049 )","title":"Internals"},{"location":"changelog/#070-2022-08-30","text":"","title":"0.7.0 - 2022-08-30"},{"location":"changelog/#added_2","text":"Add new SyncEngine, support async and sync code ( #231 by @tiangolo ) Sync engine documentation ( #238 by @art049 ) Friendly interface for session and transactions ( #244 by @art049 ) Implement the engine.remove method to allow instance deletion from a query ( #147 & #237 by @joeriddles & @art049 )","title":"Added"},{"location":"changelog/#internals_1","text":"Remove unnecessary Python 3.6 type fixes ( #243 by @art049 ) Switch Mongo action to art049/mongodb-cluster-action ( #245 by @art049 ) Add Realworld API integrated test ( #246 by @art049 )","title":"Internals"},{"location":"changelog/#060-2022-08-24","text":"","title":"0.6.0 - 2022-08-24"},{"location":"changelog/#breaking-changes","text":"Drop support for Python 3.6 ( #230 by @tiangolo )","title":"Breaking Changes"},{"location":"changelog/#added_3","text":"Upgrade types and add support for instance autocompletion with dataclass_transform (VS Code autocompletion) ( #230 by @tiangolo ) Support Python 3.10 ( #235 by @art049 )","title":"Added"},{"location":"changelog/#fixed_3","text":"Fix using the shared session when updating a document ( #227 by @tiangolo ) Fix EmbeddedModel deep copy mutability ( #239 by @art049 ) Allow models to contain string-based datetime fields that indicate UTC ( #136 by @kfox ) Fix Reference usage with non the non default primary key ( #184 by @dynalz ) Fix key_name use on EmbeddedModels ( #195 by @jvanegmond )","title":"Fixed"},{"location":"changelog/#internals_2","text":"Support Python 3.10 in tox ( #236 by @art049 ) Fix missing f string in an exception message ( #222 by @voglster ) Finalize flit migration ( #232 by @art049 )","title":"Internals"},{"location":"changelog/#050-2022-06-01","text":"Support motor 3.0 ( #224 by @art049 ) Support pydantic 1.9.0 ( #218 by @art049 )","title":"0.5.0 - 2022-06-01"},{"location":"changelog/#040-2022-04-23","text":"","title":"0.4.0 - 2022-04-23"},{"location":"changelog/#added_4","text":"Update and copy methods: Updating multiple fields at once is now directly possible from a pydantic model or a dictionary ( feature documentation , sample use case with FastAPI ) Changing the primary field of an instance is now easier ( documentation ) Patch and copy Model instances ( #39 by @art049 )","title":"Added"},{"location":"changelog/#fixed_4","text":"Update example in README ( #192 by @jasper-moment ) Update README.md ( #129 by @Kludex )","title":"Fixed"},{"location":"changelog/#internals_3","text":"\u2b06\ufe0f Update motor requirement from >=2.1.0,<2.5.0 to >=2.1.0,<2.6.0 ( #160 by @dependabot[bot] ) \u2b06\ufe0f Update typer requirement from ^0.3.2 to ^0.4.1 ( #214 by @dependabot[bot] ) \u2b06\ufe0f Update mypy requirement from ^0.910 to ^0.942 ( #215 by @dependabot[bot] ) \u2b06\ufe0f Update fastapi requirement from >=0.61.1,<0.67.0 to >=0.61.1,<0.69.0 ( #166 by @dependabot[bot] ) \u2b06\ufe0f Update fastapi requirement from >=0.61.1,<0.64.0 to >=0.61.1,<0.67.0 ( #150 by @dependabot[bot] ) \u2b06\ufe0f Update mypy requirement from ^0.812 to ^0.910 ( #142 by @dependabot[bot] ) \u2b06\ufe0f Update pytest-asyncio requirement from ^0.14.0 to ^0.15.0 ( #125 by @dependabot[bot] ) \u2b06\ufe0f Update motor requirement from >=2.1.0,<2.4.0 to >=2.1.0,<2.5.0 ( #124 by @dependabot[bot] ) \u2b06\ufe0f Update importlib-metadata requirement from >=1,<4 to >=1,<5 ( #126 by @dependabot[bot] ) \u2b06\ufe0f Update pydocstyle requirement from ^5.1.1 to ^6.0.0 ( #119 by @dependabot[bot] ) \u2b06\ufe0f Update isort requirement from ~=5.7.0 to ~=5.8.0 ( #122 by @dependabot[bot] ) \u2b06\ufe0f Update flake8 requirement from ~=3.8.4 to ~=3.9.0 ( #116 by @dependabot[bot] )","title":"Internals"},{"location":"changelog/#035-2021-05-12","text":"","title":"0.3.5 - 2021-05-12"},{"location":"changelog/#security","text":"Change allowed pydantic versions to handle CVE-2021-29510 by @art049","title":"Security"},{"location":"changelog/#034-2021-03-04","text":"","title":"0.3.4 - 2021-03-04"},{"location":"changelog/#fixed_5","text":"Fix modified mark clearing on save for nested models ( #88 by @Olegt0rr ) Don't replace default field description for ObjectId ( #82 by @Olegt0rr )","title":"Fixed"},{"location":"changelog/#internals_4","text":"Support pydantic 1.8 ( #113 by @art049 ) Add nightly builds ( #114 by @art049 ) CI Matrix with Standalone instances, ReplicaSets and Sharded clusters ( #91 by @art049 ) Update mkdocstrings requirement from ^0.14.0 to ^0.15.0 ( #110 by @dependabot[bot] ) Update mkdocs-material requirement from ^6.0.2 to ^7.0.3 ( #111 by @dependabot[bot] ) Update mypy requirement from ^0.800 to ^0.812 ( #106 by @dependabot[bot] )","title":"Internals"},{"location":"changelog/#033-2021-02-13","text":"","title":"0.3.3 - 2021-02-13"},{"location":"changelog/#fixed_6","text":"Remove bypass_document_validation save option to avoid Not Authorized errors ( #85 by @Olegt0rr ) Fix microseconds issue: use truncation instead of round ( #100 by @erny ) Add py.typed to ship typing information for mypy ( #101 by @art049 ) Fix datetime field default example value naiveness ( #103 by @art049 )","title":"Fixed"},{"location":"changelog/#internals_5","text":"Update pytz requirement from ^2020.1 to ^2021.1 ( #98 by @dependabot[bot] ) Update mkdocstrings requirement from ^0.13.2 to ^0.14.0 ( #92 by @dependabot[bot] ) Update mypy requirement from ^0.790 to ^0.800 ( #97 by @dependabot[bot] ) Update isort requirement from ~=5.6.4 to ~=5.7.0 ( #90 by @dependabot[bot] ) Update fastapi requirement from >=0.61.1,<0.63.0 to >=0.61.1,<0.64.0 ( #84 by @dependabot[bot] )","title":"Internals"},{"location":"changelog/#032-2020-12-15","text":"","title":"0.3.2 - 2020-12-15"},{"location":"changelog/#added_5","text":"Fix embedded model field update ( #77 by @art049 ) Fix datetime bson inheritance issue ( #78 by @Olegt0rr )","title":"Added"},{"location":"changelog/#internals_6","text":"Migrate to the updated prettier precommit hook ( #74 by @art049 ) Fix tox dependency install ( #72 by @art049 ) Update uvicorn requirement from ^0.12.1 to ^0.13.0 ( #67 by @dependabot[bot] ) Update mypy requirement from ^0.782 to ^0.790 ( #48 by @dependabot[bot] ) Update importlib-metadata requirement from ^1.0 to >=1,<4 ( #54 by @dependabot[bot] ) Update flake8 requirement from ==3.8.3 to ==3.8.4 ( #47 by @dependabot[bot] ) Update fastapi requirement from ^0.61.1 to >=0.61.1,<0.63.0 ( #59 by @dependabot[bot] )","title":"Internals"},{"location":"changelog/#031-2020-11-16","text":"","title":"0.3.1 - 2020-11-16"},{"location":"changelog/#added_6","text":"Add schema_extra config option ( #41 by @art049 )","title":"Added"},{"location":"changelog/#fixed_7","text":"Fix setattr error on a manually initialized EmbeddedModel ( #40 by @art049 )","title":"Fixed"},{"location":"changelog/#030-2020-11-09","text":"","title":"0.3.0 - 2020-11-09"},{"location":"changelog/#deprecated","text":"Deprecate usage of __collection__ to customize the collection name. Prefer the collection Config option ( more details )","title":"Deprecated"},{"location":"changelog/#added_7","text":"Allow parsing document with unset fields defaults ( documentation ) ( #28 by @art049 ) Integration with Pydantic Config class ( #37 by @art049 ): It's now possible to define custom json_encoders on the Models Some other Config options provided by Pydantic are now available ( more details ) Support CPython 3.9 ( #32 by @art049 ) Unpin pydantic to support 1.7.0 ( #29 by @art049 )","title":"Added"},{"location":"changelog/#021-2020-10-25","text":"","title":"0.2.1 - 2020-10-25"},{"location":"changelog/#fixed_8","text":"Fix combined use of skip and limit with engine.find ( #25 by @art049 )","title":"Fixed"},{"location":"changelog/#020-2020-10-25","text":"","title":"0.2.0 - 2020-10-25"},{"location":"changelog/#deprecated_1","text":"Deprecate AIOEngineDependency to prefer a global engine object, more details ( #21 by @art049 )","title":"Deprecated"},{"location":"changelog/#added_8","text":"Add sorting support ( #17 by @adriencaccia ) Support motor 2.3.0 ( #20 by @art049 )","title":"Added"},{"location":"changelog/#fixed_9","text":"Fix FastAPI usage with References ( #19 by @art049 )","title":"Fixed"},{"location":"changelog/#docs","text":"Adding a CONTRIBUTING.md file to the root directory with link to docs ( #8 by @sanders41 ) Raw Query Usage Documentation Fix ( #10 by @adeelsohailahmed ) Update Filtering to include Bitwise Operator Warning ( #24 by @adeelsohailahmed )","title":"Docs"},{"location":"changelog/#010-2020-10-19","text":"","title":"0.1.0 - 2020-10-19"},{"location":"changelog/#initial-release","text":"","title":"Initial Release"},{"location":"contributing/","text":"Contributing \u00b6 Sharing feedback \u00b6 This project is still quite new and therefore having your feedback will really help to prioritize relevant feature developments . The easiest way to share feedback and discuss about the project is to join the Gitter chatroom . If you want to contribute (thanks a lot ! ), you can open an issue on Github. Before creating a non obvious (typo, documentation fix) Pull Request, please make sure to open an issue. Developing locally \u00b6 With the VSCode's devcontainer feature \u00b6 This feature will make the tools/environment installation very simple as you will develop in a container that has already been configured to run this project. Here are the steps: Clone the repository and open it with Visual Studio Code . Make sure that the Remote - Containers ( ms-vscode-remote.remote-containers ) extension is installed. Run the Remote-Container: Reopen in Container command (press Ctrl + Shift + P and then type the command). After the setup script completes, the environment is ready. You can start the local development . You can go to the development tasks section to see the available task commands. MongoDB container In this containerized development environment, a MongoDB instance should already be running as a part of the development docker-compose.yml file internally used by VSCode. Regular environment setup \u00b6 Installing the tools \u00b6 Git LFS : used to store documentation assets in the repository Docker : used to run a local MongoDB instance Docker Compose (Optional): used to run a local MongoDB cluster (replica set or shards) Task : task manager Installing python based development tools In order to install the devtools written in python, it's recommended to use pipx . python3 -m pip install --user pipx python3 -m pipx ensurepath flit : packaging system and dependency manager pipx install flit tox : multi-environment test runner pipx install tox pre-commit : pre commit hook manager pipx install pre-commit Python versions If you want to test the project with multiple python versions, you'll need to install them manually. You can use pyenv to install them easily. # Install the versions pyenv install \"3.7.9\" pyenv install \"3.8.9\" pyenv install \"3.9.0\" # Make the versions available locally in the project pyenv local 3 .8.6 3 .7.9 3 .9.0 Configuring the local environment \u00b6 task setup Running development tasks \u00b6 The following tasks are available for the project: task setup : Configure the development environment. task lint : Run the linting checks. task format : Format the code (and imports). mongodb:standalone-docker : Start a standalone MongoDB instance using a docker container mongodb:standalone-docker:down : Stop the standalone instance mongodb:replica-compose : Start a replica set MongoDB cluster using docker-compose mongodb:replica-compose:down : Stop the replica set cluster mongodb:sharded-compose : Start a sharded MongoDB cluster using docker-compose mongodb:sharded-compose:down : Stop the sharded MongoDB cluster task test : Run the tests with the current version. task full-test : Run the tests against all supported versions. task coverage : Get the test coverage (xml and html) with the current version. task docs : Start the local documentation server.","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#sharing-feedback","text":"This project is still quite new and therefore having your feedback will really help to prioritize relevant feature developments . The easiest way to share feedback and discuss about the project is to join the Gitter chatroom . If you want to contribute (thanks a lot ! ), you can open an issue on Github. Before creating a non obvious (typo, documentation fix) Pull Request, please make sure to open an issue.","title":"Sharing feedback"},{"location":"contributing/#developing-locally","text":"","title":"Developing locally"},{"location":"contributing/#with-the-vscodes-devcontainer-feature","text":"This feature will make the tools/environment installation very simple as you will develop in a container that has already been configured to run this project. Here are the steps: Clone the repository and open it with Visual Studio Code . Make sure that the Remote - Containers ( ms-vscode-remote.remote-containers ) extension is installed. Run the Remote-Container: Reopen in Container command (press Ctrl + Shift + P and then type the command). After the setup script completes, the environment is ready. You can start the local development . You can go to the development tasks section to see the available task commands. MongoDB container In this containerized development environment, a MongoDB instance should already be running as a part of the development docker-compose.yml file internally used by VSCode.","title":"With the VSCode's devcontainer feature"},{"location":"contributing/#regular-environment-setup","text":"","title":"Regular environment setup"},{"location":"contributing/#installing-the-tools","text":"Git LFS : used to store documentation assets in the repository Docker : used to run a local MongoDB instance Docker Compose (Optional): used to run a local MongoDB cluster (replica set or shards) Task : task manager Installing python based development tools In order to install the devtools written in python, it's recommended to use pipx . python3 -m pip install --user pipx python3 -m pipx ensurepath flit : packaging system and dependency manager pipx install flit tox : multi-environment test runner pipx install tox pre-commit : pre commit hook manager pipx install pre-commit Python versions If you want to test the project with multiple python versions, you'll need to install them manually. You can use pyenv to install them easily. # Install the versions pyenv install \"3.7.9\" pyenv install \"3.8.9\" pyenv install \"3.9.0\" # Make the versions available locally in the project pyenv local 3 .8.6 3 .7.9 3 .9.0","title":"Installing the tools"},{"location":"contributing/#configuring-the-local-environment","text":"task setup","title":"Configuring the local environment"},{"location":"contributing/#running-development-tasks","text":"The following tasks are available for the project: task setup : Configure the development environment. task lint : Run the linting checks. task format : Format the code (and imports). mongodb:standalone-docker : Start a standalone MongoDB instance using a docker container mongodb:standalone-docker:down : Stop the standalone instance mongodb:replica-compose : Start a replica set MongoDB cluster using docker-compose mongodb:replica-compose:down : Stop the replica set cluster mongodb:sharded-compose : Start a sharded MongoDB cluster using docker-compose mongodb:sharded-compose:down : Stop the sharded MongoDB cluster task test : Run the tests with the current version. task full-test : Run the tests against all supported versions. task coverage : Get the test coverage (xml and html) with the current version. task docs : Start the local documentation server.","title":"Running development tasks"},{"location":"engine/","text":"Engine \u00b6 This engine documentation present how to work with both the Sync ( SyncEngine ) and the Async ( AIOEngine ) engines. The methods available for both are very close but the main difference is that the Async engine exposes coroutines instead of functions for the Sync engine. Creating the engine \u00b6 In the previous examples, we created the engine using default parameters: MongoDB: running on localhost port 27017 Database name: test It's possible to provide a custom client ( AsyncIOMotorClient or PyMongoClient ) to the engine constructor. In the same way, the database name can be changed using the database keyword argument. Async Sync 1 2 3 4 5 6 from motor.motor_asyncio import AsyncIOMotorClient from odmantic import AIOEngine client = AsyncIOMotorClient ( \"mongodb://localhost:27017/\" ) engine = AIOEngine ( client = client , database = \"example_db\" ) 1 2 3 4 5 6 from pymongo import MongoClient from odmantic import SyncEngine client = MongoClient ( \"mongodb://localhost:27017/\" ) engine = SyncEngine ( client = client , database = \"example_db\" ) For additional information about the MongoDB connection strings, see this section of the MongoDB documentation. Usage with DNS SRV records If you decide to use the DNS Seed List Connection Format (i.e mongodb+srv://... ), you will need to install the dnspython package. Create \u00b6 There are two ways of persisting instances to the database (i.e creating new documents): engine.save : to save a single instance engine.save_all : to save multiple instances at once Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () leeroy = Player ( name = \"Leeroy Jenkins\" , game = \"World of Warcraft\" ) await engine . save ( leeroy ) players = [ Player ( name = \"Shroud\" , game = \"Counter-Strike\" ), Player ( name = \"Serral\" , game = \"Starcraft\" ), Player ( name = \"TLO\" , game = \"Starcraft\" ), ] await engine . save_all ( players ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import SyncEngine , Model class Player ( Model ): name : str game : str engine = SyncEngine () leeroy = Player ( name = \"Leeroy Jenkins\" , game = \"World of Warcraft\" ) engine . save ( leeroy ) players = [ Player ( name = \"Shroud\" , game = \"Counter-Strike\" ), Player ( name = \"Serral\" , game = \"Starcraft\" ), Player ( name = \"TLO\" , game = \"Starcraft\" ), ] engine . save_all ( players ) Resulting documents in the player collection { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a46\" ) , \"game\" : \"World of Warcraft\" , \"name\" : \"Leeroy Jenkins\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a47\" ) , \"game\" : \"Counter-Strike\" , \"name\" : \"Shroud\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a49\" ) , \"game\" : \"Starcraft\" , \"name\" : \"TLO\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a48\" ) , \"game\" : \"Starcraft\" , \"name\" : \"Serral\" } Referenced instances When calling engine.save or engine.save_all , the referenced models will are persisted as well. Upsert behavior The save and save_all methods behave as upsert operations ( more details ). Hence, you might overwrite documents if you save instances with an existing primary key already existing in the database. Read \u00b6 Examples database content The next examples will consider that you have a player collection populated with the documents previously created. Fetch a single instance \u00b6 As with regular MongoDB driver, you can use the engine.find_one method to get at most one instance of a specific Model. This method will either return an instance matching the specified criteriums or None if no instances have been found. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player = await engine . find_one ( Player , Player . name == \"Serral\" ) print ( repr ( player )) #> Player(id=ObjectId(...), name=\"Serral\", game=\"Starcraft\") another_player = await engine . find_one ( Player , Player . name == \"Player_Not_Stored_In_Database\" ) print ( another_player ) #> None 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import Model , SyncEngine class Player ( Model ): name : str game : str engine = SyncEngine () player = engine . find_one ( Player , Player . name == \"Serral\" ) print ( repr ( player )) #> Player(id=ObjectId(...), name=\"Serral\", game=\"Starcraft\") another_player = engine . find_one ( Player , Player . name == \"Player_Not_Stored_In_Database\" ) print ( another_player ) #> None Missing values in documents While parsing the MongoDB documents into Model instances, ODMantic will use the provided default values to populate the missing fields. See this section for more details about document parsing. Fetch using sort We can use the sort parameter to fetch the Player instance with the first name in ascending order: await engine . find_one ( Player , sort = Player . name ) Find out more on sort in the dedicated section . Fetch multiple instances \u00b6 To get more than one instance from the database at once, you can use the engine.find method. This method will return a cursor: an AIOCursor object for the AIOEngine and a SyncCursor object for the SyncEngine . Those cursors can mainly be used in two different ways: Usage as an iterator \u00b6 Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () async for player in engine . find ( Player , Player . game == \"Starcraft\" ): print ( repr ( player )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') #> Player(id=ObjectId(...), name='Serral', game='Starcraft') 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from odmantic import Model , SyncEngine class Player ( Model ): name : str game : str engine = SyncEngine () for player in engine . find ( Player , Player . game == \"Starcraft\" ): print ( repr ( player )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') #> Player(id=ObjectId(...), name='Serral', game='Starcraft') Ordering instances The sort parameter allows to order the query in ascending or descending order on a single or multiple fields. engine . find ( Player , sort = ( Player . name , Player . game . desc ())) Find out more on sort in the dedicated section . Usage as an awaitable/list \u00b6 Even if the iterator usage should be preferred, in some cases it might be required to gather all the documents from the database before processing them. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () players = await engine . find ( Player , Player . game != \"Starcraft\" ) print ( players ) #> [ #> Player(id=ObjectId(...), name=\"Leeroy Jenkins\", game=\"World of Warcraft\"), #> Player(id=ObjectId(...), name=\"Shroud\", game=\"Counter-Strike\"), #> ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from odmantic import SyncEngine , Model class Player ( Model ): name : str game : str engine = SyncEngine () players = list ( engine . find ( Player , Player . game != \"Starcraft\" )) print ( players ) #> [ #> Player(id=ObjectId(...), name=\"Leeroy Jenkins\", game=\"World of Warcraft\"), #> Player(id=ObjectId(...), name=\"Shroud\", game=\"Counter-Strike\"), #> ] Pagination When using AIOEngine.find or SyncEngine.find you can as well use the skip and limit keyword arguments , respectively to skip a specified number of instances and to limit the number of fetched instances. Referenced instances When calling engine.find or engine.find_one , the referenced models will be recursively resolved as well by design. Passing the model class to find and find_one When using the method to retrieve instances from the database, you have to specify the Model you want to query on as the first positional parameter. Internally, this enables ODMantic to properly type the results. Count instances \u00b6 You can count instances in the database by using the engine.count method and as with other read methods, it's still possible to use this method with filtering queries. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player_count = await engine . count ( Player ) print ( player_count ) #> 4 cs_count = await engine . count ( Player , Player . game == \"Counter-Strike\" ) print ( cs_count ) #> 1 valorant_count = await engine . count ( Player , Player . game == \"Valorant\" ) print ( valorant_count ) #> 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import Model , SyncEngine class Player ( Model ): name : str game : str engine = SyncEngine () player_count = engine . count ( Player ) print ( player_count ) #> 4 cs_count = engine . count ( Player , Player . game == \"Counter-Strike\" ) print ( cs_count ) #> 1 valorant_count = engine . count ( Player , Player . game == \"Valorant\" ) print ( valorant_count ) #> 0 Combining multiple queries in read operations While using find , find_one or count , you may pass as many queries as you want as positional arguments. Those will be implicitly combined as single and_ query. Update \u00b6 Updating an instance in the database can be done by modifying the instance locally and saving it again to the database. The engine.save and engine.save_all methods are actually behaving as upsert operations. In other words, if the instance already exists it will be updated. Otherwise, the related document will be created in the database. Modifying one field \u00b6 Modifying a single field can be achieved by directly changing the instance attribute and saving the instance. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () shroud = await engine . find_one ( Player , Player . name == \"Shroud\" ) print ( shroud . game ) #> Counter-Strike shroud . game = \"Valorant\" await engine . save ( shroud ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import SyncEngine , Model class Player ( Model ): name : str game : str engine = SyncEngine () shroud = engine . find_one ( Player , Player . name == \"Shroud\" ) print ( shroud . game ) #> Counter-Strike shroud . game = \"Valorant\" engine . save ( shroud ) Resulting documents in the player collection { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a46\" ) , \"game\" : \"World of Warcraft\" , \"name\" : \"Leeroy Jenkins\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a47\" ) , \"game\" : \"Valorant\" , \"name\" : \"Shroud\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a49\" ) , \"game\" : \"Starcraft\" , \"name\" : \"TLO\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a48\" ) , \"game\" : \"Starcraft\" , \"name\" : \"Serral\" } Patching multiple fields at once \u00b6 The easiest way to change multiple fields at once is to use the Model.update method. This method will take either a Pydantic object or a dictionary and update the matching fields of the instance. From a Pydantic Model \u00b6 Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from pydantic import BaseModel from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player_tlo = await engine . find_one ( Player , Player . name == \"TLO\" ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') # Create the structure of the patch object with pydantic class PatchPlayerSchema ( BaseModel ): name : str game : str # Create the patch object containing the new values patch_object = PatchPlayerSchema ( name = \"TheLittleOne\" , game = \"Starcraft II\" ) # Apply the patch to the instance player_tlo . update ( patch_object ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TheLittleOne', game='Starcraft II') # Finally persist again the new instance await engine . save ( player_tlo ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from pydantic import BaseModel from odmantic import SyncEngine , Model class Player ( Model ): name : str game : str engine = SyncEngine () player_tlo = engine . find_one ( Player , Player . name == \"TLO\" ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') # Create the structure of the patch object with pydantic class PatchPlayerSchema ( BaseModel ): name : str game : str # Create the patch object containing the new values patch_object = PatchPlayerSchema ( name = \"TheLittleOne\" , game = \"Starcraft II\" ) # Apply the patch to the instance player_tlo . update ( patch_object ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TheLittleOne', game='Starcraft II') # Finally persist again the new instance engine . save ( player_tlo ) From a dictionary \u00b6 Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player_tlo = await engine . find_one ( Player , Player . name == \"TLO\" ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') # Create the patch dictionary containing the new values patch_object = { \"name\" : \"TheLittleOne\" , \"game\" : \"Starcraft II\" } # Update the local instance player_tlo . update ( patch_object ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TheLittleOne', game='Starcraft II') # Finally persist the instance await engine . save ( player_tlo ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from odmantic import SyncEngine , Model class Player ( Model ): name : str game : str engine = SyncEngine () player_tlo = engine . find_one ( Player , Player . name == \"TLO\" ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') # Create the patch dictionary containing the new values patch_object = { \"name\" : \"TheLittleOne\" , \"game\" : \"Starcraft II\" } # Update the local instance player_tlo . update ( patch_object ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TheLittleOne', game='Starcraft II') # Finally persist the instance engine . save ( player_tlo ) Resulting document associated to the player { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a49\" ) , \"game\" : \"Starcraft II\" , \"name\" : \"TheLittleOne\" } Changing the primary field \u00b6 Directly changing the primary field value as explained above is not possible and a NotImplementedError exception will be raised if you try to do so. The easiest way to change an instance primary field is to perform a local copy of the instance using the Model.copy method. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from bson import ObjectId from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () shroud = await engine . find_one ( Player , Player . name == \"Shroud\" ) print ( shroud . id ) #> 5f86074f6dfecacc68428a62 new_id = ObjectId ( \"ffffffffffffffffffffffff\" ) # Copy the player instance with a new primary key new_shroud = shroud . copy ( update = { \"id\" : new_id }) # Delete the initial player instance await engine . delete ( shroud ) # Finally persist again the new instance await engine . save ( new_shroud ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from bson import ObjectId from odmantic import SyncEngine , Model class Player ( Model ): name : str game : str engine = SyncEngine () shroud = engine . find_one ( Player , Player . name == \"Shroud\" ) print ( shroud . id ) #> 5f86074f6dfecacc68428a62 new_id = ObjectId ( \"ffffffffffffffffffffffff\" ) # Copy the player instance with a new primary key new_shroud = shroud . copy ( update = { \"id\" : new_id }) # Delete the initial player instance engine . delete ( shroud ) # Finally persist again the new instance engine . save ( new_shroud ) Resulting document associated to the player { \"_id\" : Objec t Id( \"ffffffffffffffffffffffff\" ) , \"game\" : \"Valorant\" , \"name\" : \"Shroud\" } Update data used with the copy The data updated by the copy method is not validated: you should absolutely trust this data. Delete \u00b6 Delete a single instance \u00b6 You can delete instance by passing them to the engine.delete method. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () players = await engine . find ( Player ) for player in players : await engine . delete ( player ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import SyncEngine , Model class Player ( Model ): name : str game : str engine = SyncEngine () players = engine . find ( Player ) for player in players : engine . delete ( player ) Remove \u00b6 You can delete instances that match a filter by using the engine.remove method. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () delete_count = await engine . remove ( Player , Player . game == \"Warzone\" ) print ( delete_count ) #> 2 1 2 3 4 5 6 7 8 9 10 11 12 13 from odmantic import SyncEngine , Model class Player ( Model ): name : str game : str engine = SyncEngine () delete_count = engine . remove ( Player , Player . game == \"Warzone\" ) print ( delete_count ) #> 2 Just one \u00b6 You can limit engine.remove to removing only one instance by passing just_one . Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () delete_count = await engine . remove ( Player , Player . game == \"Warzone\" , just_one = True ) print ( delete_count ) #> 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from odmantic import Model , SyncEngine class Player ( Model ): name : str game : str engine = SyncEngine () delete_count = engine . remove ( Player , Player . game == \"Warzone\" , just_one = True ) print ( delete_count ) #> 1 Consistency \u00b6 Using a Session \u00b6 Why are sessions needed ? A session is a way to guarantee that the data you read is consistent with the data you write. This is especially useful when you need to perform multiple operations on the same data. See this document for more details on causal consistency. You can create a session by using the engine.session method. This method will return either a SyncSession or an AIOSession object, depending on the type of engine used. Those session objects are context manager and can be used along with the with or the async with keywords. Once the context is entered the session object exposes the same database operation methods as the related engine object but execute each operation in the session context. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () leeroy = Player ( name = \"Leeroy Jenkins\" , game = \"World of Warcraft\" ) async with engine . session () as session : await session . save_all ( [ Player ( name = \"Shroud\" , game = \"Counter-Strike\" ), Player ( name = \"Serral\" , game = \"Starcraft\" ), Player ( name = \"TLO\" , game = \"Starcraft\" ), ] ) player_count = await session . count ( Player ) print ( player_count ) #> 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from odmantic import SyncEngine , Model class Player ( Model ): name : str game : str engine = SyncEngine () leeroy = Player ( name = \"Leeroy Jenkins\" , game = \"World of Warcraft\" ) with engine . session () as session : session . save_all ( [ Player ( name = \"Shroud\" , game = \"Counter-Strike\" ), Player ( name = \"Serral\" , game = \"Starcraft\" ), Player ( name = \"TLO\" , game = \"Starcraft\" ), ] ) player_count = session . count ( Player ) print ( player_count ) #> 3 Directly using driver sessions Every single engine method also accepts a session parameter. You can use this parameter to provide an existing driver (motor or PyMongo) session that you created manually. Accessing the underlying driver session object The session.get_driver_session method exposes the underlying driver session. This is useful if you want to use the driver session directly to perform raw operations. Using a Transaction \u00b6 Why are transactions needed ? A transaction is a mechanism that allows you to execute multiple operations in a single atomic operation. This is useful when you want to ensure that a set of operations is atomicly performed on a specific document. MongoDB transaction support Transactions are only supported in a replica sets (Mongo 4.0+) or sharded clusters with replication enabled (Mongo 4.2+), if you use them in a standalone MongoDB instance an error will be raised. You can create a transaction directly from the engine by using the engine.transaction method. This methods will either return a SyncTransaction or an AIOTransaction object. As for sessions, transaction objects exposes the same database operation methods as the related engine object but execute each operation in a transactional context. In order to terminate a transaction you must either call the commit method to persist all the changes or call the abort method to drop the changes introduced in the transaction. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () async with engine . transaction () as transaction : await transaction . save ( Player ( name = \"Leeroy Jenkins\" , game = \"WoW\" )) await transaction . commit () print ( engine . count ( Player )) #> 1 async with engine . transaction () as transaction : await transaction . save ( Player ( name = \"Shroud\" , game = \"Counter-Strike\" )) await transaction . save ( Player ( name = \"Serral\" , game = \"Starcraft\" )) await transaction . abort () print ( engine . count ( Player )) #> 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from odmantic import Model , SyncEngine class Player ( Model ): name : str game : str engine = SyncEngine () with engine . transaction () as transaction : transaction . save ( Player ( name = \"Leeroy Jenkins\" , game = \"WoW\" )) transaction . commit () print ( engine . count ( Player )) #> 1 with engine . transaction () as transaction : transaction . save ( Player ( name = \"Shroud\" , game = \"Counter-Strike\" )) transaction . save ( Player ( name = \"Serral\" , game = \"Starcraft\" )) transaction . abort () print ( engine . count ( Player )) #> 1 It is also possible to create a transaction within an existing session by using the session.transaction method: Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () async with engine . session () as session : leeroy = await session . save ( Player ( name = \"Leeroy Jenkins\" , game = \"WoW\" )) shroud = await session . save ( Player ( name = \"Shroud\" , game = \"Counter-Strike\" )) async with session . transaction () as transaction : leeroy . game = \"Fortnite\" await transaction . save ( leeroy ) shroud . game = \"Fortnite\" await transaction . save ( shroud ) await transaction . commit () print ( await engine . count ( Player , Player . game == \"Fortnite\" )) #> 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from odmantic import Model , SyncEngine class Player ( Model ): name : str game : str engine = SyncEngine () with engine . session () as session : leeroy = session . save ( Player ( name = \"Leeroy Jenkins\" , game = \"WoW\" )) shroud = session . save ( Player ( name = \"Shroud\" , game = \"Counter-Strike\" )) with session . transaction () as transaction : leeroy . game = \"Fortnite\" transaction . save ( leeroy ) shroud . game = \"Fortnite\" transaction . save ( shroud ) transaction . commit () print ( engine . count ( Player , Player . game == \"Fortnite\" )) #> 2","title":"Engine"},{"location":"engine/#engine","text":"This engine documentation present how to work with both the Sync ( SyncEngine ) and the Async ( AIOEngine ) engines. The methods available for both are very close but the main difference is that the Async engine exposes coroutines instead of functions for the Sync engine.","title":"Engine"},{"location":"engine/#creating-the-engine","text":"In the previous examples, we created the engine using default parameters: MongoDB: running on localhost port 27017 Database name: test It's possible to provide a custom client ( AsyncIOMotorClient or PyMongoClient ) to the engine constructor. In the same way, the database name can be changed using the database keyword argument. Async Sync 1 2 3 4 5 6 from motor.motor_asyncio import AsyncIOMotorClient from odmantic import AIOEngine client = AsyncIOMotorClient ( \"mongodb://localhost:27017/\" ) engine = AIOEngine ( client = client , database = \"example_db\" ) 1 2 3 4 5 6 from pymongo import MongoClient from odmantic import SyncEngine client = MongoClient ( \"mongodb://localhost:27017/\" ) engine = SyncEngine ( client = client , database = \"example_db\" ) For additional information about the MongoDB connection strings, see this section of the MongoDB documentation. Usage with DNS SRV records If you decide to use the DNS Seed List Connection Format (i.e mongodb+srv://... ), you will need to install the dnspython package.","title":"Creating the engine"},{"location":"engine/#create","text":"There are two ways of persisting instances to the database (i.e creating new documents): engine.save : to save a single instance engine.save_all : to save multiple instances at once Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () leeroy = Player ( name = \"Leeroy Jenkins\" , game = \"World of Warcraft\" ) await engine . save ( leeroy ) players = [ Player ( name = \"Shroud\" , game = \"Counter-Strike\" ), Player ( name = \"Serral\" , game = \"Starcraft\" ), Player ( name = \"TLO\" , game = \"Starcraft\" ), ] await engine . save_all ( players ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import SyncEngine , Model class Player ( Model ): name : str game : str engine = SyncEngine () leeroy = Player ( name = \"Leeroy Jenkins\" , game = \"World of Warcraft\" ) engine . save ( leeroy ) players = [ Player ( name = \"Shroud\" , game = \"Counter-Strike\" ), Player ( name = \"Serral\" , game = \"Starcraft\" ), Player ( name = \"TLO\" , game = \"Starcraft\" ), ] engine . save_all ( players ) Resulting documents in the player collection { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a46\" ) , \"game\" : \"World of Warcraft\" , \"name\" : \"Leeroy Jenkins\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a47\" ) , \"game\" : \"Counter-Strike\" , \"name\" : \"Shroud\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a49\" ) , \"game\" : \"Starcraft\" , \"name\" : \"TLO\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a48\" ) , \"game\" : \"Starcraft\" , \"name\" : \"Serral\" } Referenced instances When calling engine.save or engine.save_all , the referenced models will are persisted as well. Upsert behavior The save and save_all methods behave as upsert operations ( more details ). Hence, you might overwrite documents if you save instances with an existing primary key already existing in the database.","title":"Create"},{"location":"engine/#read","text":"Examples database content The next examples will consider that you have a player collection populated with the documents previously created.","title":"Read"},{"location":"engine/#fetch-a-single-instance","text":"As with regular MongoDB driver, you can use the engine.find_one method to get at most one instance of a specific Model. This method will either return an instance matching the specified criteriums or None if no instances have been found. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player = await engine . find_one ( Player , Player . name == \"Serral\" ) print ( repr ( player )) #> Player(id=ObjectId(...), name=\"Serral\", game=\"Starcraft\") another_player = await engine . find_one ( Player , Player . name == \"Player_Not_Stored_In_Database\" ) print ( another_player ) #> None 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import Model , SyncEngine class Player ( Model ): name : str game : str engine = SyncEngine () player = engine . find_one ( Player , Player . name == \"Serral\" ) print ( repr ( player )) #> Player(id=ObjectId(...), name=\"Serral\", game=\"Starcraft\") another_player = engine . find_one ( Player , Player . name == \"Player_Not_Stored_In_Database\" ) print ( another_player ) #> None Missing values in documents While parsing the MongoDB documents into Model instances, ODMantic will use the provided default values to populate the missing fields. See this section for more details about document parsing. Fetch using sort We can use the sort parameter to fetch the Player instance with the first name in ascending order: await engine . find_one ( Player , sort = Player . name ) Find out more on sort in the dedicated section .","title":"Fetch a single instance"},{"location":"engine/#fetch-multiple-instances","text":"To get more than one instance from the database at once, you can use the engine.find method. This method will return a cursor: an AIOCursor object for the AIOEngine and a SyncCursor object for the SyncEngine . Those cursors can mainly be used in two different ways:","title":"Fetch multiple instances"},{"location":"engine/#usage-as-an-iterator","text":"Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () async for player in engine . find ( Player , Player . game == \"Starcraft\" ): print ( repr ( player )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') #> Player(id=ObjectId(...), name='Serral', game='Starcraft') 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from odmantic import Model , SyncEngine class Player ( Model ): name : str game : str engine = SyncEngine () for player in engine . find ( Player , Player . game == \"Starcraft\" ): print ( repr ( player )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') #> Player(id=ObjectId(...), name='Serral', game='Starcraft') Ordering instances The sort parameter allows to order the query in ascending or descending order on a single or multiple fields. engine . find ( Player , sort = ( Player . name , Player . game . desc ())) Find out more on sort in the dedicated section .","title":"Usage as an iterator"},{"location":"engine/#usage-as-an-awaitablelist","text":"Even if the iterator usage should be preferred, in some cases it might be required to gather all the documents from the database before processing them. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () players = await engine . find ( Player , Player . game != \"Starcraft\" ) print ( players ) #> [ #> Player(id=ObjectId(...), name=\"Leeroy Jenkins\", game=\"World of Warcraft\"), #> Player(id=ObjectId(...), name=\"Shroud\", game=\"Counter-Strike\"), #> ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from odmantic import SyncEngine , Model class Player ( Model ): name : str game : str engine = SyncEngine () players = list ( engine . find ( Player , Player . game != \"Starcraft\" )) print ( players ) #> [ #> Player(id=ObjectId(...), name=\"Leeroy Jenkins\", game=\"World of Warcraft\"), #> Player(id=ObjectId(...), name=\"Shroud\", game=\"Counter-Strike\"), #> ] Pagination When using AIOEngine.find or SyncEngine.find you can as well use the skip and limit keyword arguments , respectively to skip a specified number of instances and to limit the number of fetched instances. Referenced instances When calling engine.find or engine.find_one , the referenced models will be recursively resolved as well by design. Passing the model class to find and find_one When using the method to retrieve instances from the database, you have to specify the Model you want to query on as the first positional parameter. Internally, this enables ODMantic to properly type the results.","title":"Usage as an awaitable/list"},{"location":"engine/#count-instances","text":"You can count instances in the database by using the engine.count method and as with other read methods, it's still possible to use this method with filtering queries. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player_count = await engine . count ( Player ) print ( player_count ) #> 4 cs_count = await engine . count ( Player , Player . game == \"Counter-Strike\" ) print ( cs_count ) #> 1 valorant_count = await engine . count ( Player , Player . game == \"Valorant\" ) print ( valorant_count ) #> 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import Model , SyncEngine class Player ( Model ): name : str game : str engine = SyncEngine () player_count = engine . count ( Player ) print ( player_count ) #> 4 cs_count = engine . count ( Player , Player . game == \"Counter-Strike\" ) print ( cs_count ) #> 1 valorant_count = engine . count ( Player , Player . game == \"Valorant\" ) print ( valorant_count ) #> 0 Combining multiple queries in read operations While using find , find_one or count , you may pass as many queries as you want as positional arguments. Those will be implicitly combined as single and_ query.","title":"Count instances"},{"location":"engine/#update","text":"Updating an instance in the database can be done by modifying the instance locally and saving it again to the database. The engine.save and engine.save_all methods are actually behaving as upsert operations. In other words, if the instance already exists it will be updated. Otherwise, the related document will be created in the database.","title":"Update"},{"location":"engine/#modifying-one-field","text":"Modifying a single field can be achieved by directly changing the instance attribute and saving the instance. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () shroud = await engine . find_one ( Player , Player . name == \"Shroud\" ) print ( shroud . game ) #> Counter-Strike shroud . game = \"Valorant\" await engine . save ( shroud ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import SyncEngine , Model class Player ( Model ): name : str game : str engine = SyncEngine () shroud = engine . find_one ( Player , Player . name == \"Shroud\" ) print ( shroud . game ) #> Counter-Strike shroud . game = \"Valorant\" engine . save ( shroud ) Resulting documents in the player collection { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a46\" ) , \"game\" : \"World of Warcraft\" , \"name\" : \"Leeroy Jenkins\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a47\" ) , \"game\" : \"Valorant\" , \"name\" : \"Shroud\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a49\" ) , \"game\" : \"Starcraft\" , \"name\" : \"TLO\" } { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a48\" ) , \"game\" : \"Starcraft\" , \"name\" : \"Serral\" }","title":"Modifying one field"},{"location":"engine/#patching-multiple-fields-at-once","text":"The easiest way to change multiple fields at once is to use the Model.update method. This method will take either a Pydantic object or a dictionary and update the matching fields of the instance.","title":"Patching multiple fields at once"},{"location":"engine/#from-a-pydantic-model","text":"Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from pydantic import BaseModel from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player_tlo = await engine . find_one ( Player , Player . name == \"TLO\" ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') # Create the structure of the patch object with pydantic class PatchPlayerSchema ( BaseModel ): name : str game : str # Create the patch object containing the new values patch_object = PatchPlayerSchema ( name = \"TheLittleOne\" , game = \"Starcraft II\" ) # Apply the patch to the instance player_tlo . update ( patch_object ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TheLittleOne', game='Starcraft II') # Finally persist again the new instance await engine . save ( player_tlo ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from pydantic import BaseModel from odmantic import SyncEngine , Model class Player ( Model ): name : str game : str engine = SyncEngine () player_tlo = engine . find_one ( Player , Player . name == \"TLO\" ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') # Create the structure of the patch object with pydantic class PatchPlayerSchema ( BaseModel ): name : str game : str # Create the patch object containing the new values patch_object = PatchPlayerSchema ( name = \"TheLittleOne\" , game = \"Starcraft II\" ) # Apply the patch to the instance player_tlo . update ( patch_object ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TheLittleOne', game='Starcraft II') # Finally persist again the new instance engine . save ( player_tlo )","title":"From a Pydantic Model"},{"location":"engine/#from-a-dictionary","text":"Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () player_tlo = await engine . find_one ( Player , Player . name == \"TLO\" ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') # Create the patch dictionary containing the new values patch_object = { \"name\" : \"TheLittleOne\" , \"game\" : \"Starcraft II\" } # Update the local instance player_tlo . update ( patch_object ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TheLittleOne', game='Starcraft II') # Finally persist the instance await engine . save ( player_tlo ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from odmantic import SyncEngine , Model class Player ( Model ): name : str game : str engine = SyncEngine () player_tlo = engine . find_one ( Player , Player . name == \"TLO\" ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TLO', game='Starcraft') # Create the patch dictionary containing the new values patch_object = { \"name\" : \"TheLittleOne\" , \"game\" : \"Starcraft II\" } # Update the local instance player_tlo . update ( patch_object ) print ( repr ( player_tlo )) #> Player(id=ObjectId(...), name='TheLittleOne', game='Starcraft II') # Finally persist the instance engine . save ( player_tlo ) Resulting document associated to the player { \"_id\" : Objec t Id( \"5f85f36d6dfecacc68428a49\" ) , \"game\" : \"Starcraft II\" , \"name\" : \"TheLittleOne\" }","title":"From a dictionary"},{"location":"engine/#changing-the-primary-field","text":"Directly changing the primary field value as explained above is not possible and a NotImplementedError exception will be raised if you try to do so. The easiest way to change an instance primary field is to perform a local copy of the instance using the Model.copy method. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from bson import ObjectId from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () shroud = await engine . find_one ( Player , Player . name == \"Shroud\" ) print ( shroud . id ) #> 5f86074f6dfecacc68428a62 new_id = ObjectId ( \"ffffffffffffffffffffffff\" ) # Copy the player instance with a new primary key new_shroud = shroud . copy ( update = { \"id\" : new_id }) # Delete the initial player instance await engine . delete ( shroud ) # Finally persist again the new instance await engine . save ( new_shroud ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from bson import ObjectId from odmantic import SyncEngine , Model class Player ( Model ): name : str game : str engine = SyncEngine () shroud = engine . find_one ( Player , Player . name == \"Shroud\" ) print ( shroud . id ) #> 5f86074f6dfecacc68428a62 new_id = ObjectId ( \"ffffffffffffffffffffffff\" ) # Copy the player instance with a new primary key new_shroud = shroud . copy ( update = { \"id\" : new_id }) # Delete the initial player instance engine . delete ( shroud ) # Finally persist again the new instance engine . save ( new_shroud ) Resulting document associated to the player { \"_id\" : Objec t Id( \"ffffffffffffffffffffffff\" ) , \"game\" : \"Valorant\" , \"name\" : \"Shroud\" } Update data used with the copy The data updated by the copy method is not validated: you should absolutely trust this data.","title":"Changing the primary field"},{"location":"engine/#delete","text":"","title":"Delete"},{"location":"engine/#delete-a-single-instance","text":"You can delete instance by passing them to the engine.delete method. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () players = await engine . find ( Player ) for player in players : await engine . delete ( player ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import SyncEngine , Model class Player ( Model ): name : str game : str engine = SyncEngine () players = engine . find ( Player ) for player in players : engine . delete ( player )","title":"Delete a single instance"},{"location":"engine/#remove","text":"You can delete instances that match a filter by using the engine.remove method. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () delete_count = await engine . remove ( Player , Player . game == \"Warzone\" ) print ( delete_count ) #> 2 1 2 3 4 5 6 7 8 9 10 11 12 13 from odmantic import SyncEngine , Model class Player ( Model ): name : str game : str engine = SyncEngine () delete_count = engine . remove ( Player , Player . game == \"Warzone\" ) print ( delete_count ) #> 2","title":"Remove"},{"location":"engine/#just-one","text":"You can limit engine.remove to removing only one instance by passing just_one . Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () delete_count = await engine . remove ( Player , Player . game == \"Warzone\" , just_one = True ) print ( delete_count ) #> 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from odmantic import Model , SyncEngine class Player ( Model ): name : str game : str engine = SyncEngine () delete_count = engine . remove ( Player , Player . game == \"Warzone\" , just_one = True ) print ( delete_count ) #> 1","title":"Just one"},{"location":"engine/#consistency","text":"","title":"Consistency"},{"location":"engine/#using-a-session","text":"Why are sessions needed ? A session is a way to guarantee that the data you read is consistent with the data you write. This is especially useful when you need to perform multiple operations on the same data. See this document for more details on causal consistency. You can create a session by using the engine.session method. This method will return either a SyncSession or an AIOSession object, depending on the type of engine used. Those session objects are context manager and can be used along with the with or the async with keywords. Once the context is entered the session object exposes the same database operation methods as the related engine object but execute each operation in the session context. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () leeroy = Player ( name = \"Leeroy Jenkins\" , game = \"World of Warcraft\" ) async with engine . session () as session : await session . save_all ( [ Player ( name = \"Shroud\" , game = \"Counter-Strike\" ), Player ( name = \"Serral\" , game = \"Starcraft\" ), Player ( name = \"TLO\" , game = \"Starcraft\" ), ] ) player_count = await session . count ( Player ) print ( player_count ) #> 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from odmantic import SyncEngine , Model class Player ( Model ): name : str game : str engine = SyncEngine () leeroy = Player ( name = \"Leeroy Jenkins\" , game = \"World of Warcraft\" ) with engine . session () as session : session . save_all ( [ Player ( name = \"Shroud\" , game = \"Counter-Strike\" ), Player ( name = \"Serral\" , game = \"Starcraft\" ), Player ( name = \"TLO\" , game = \"Starcraft\" ), ] ) player_count = session . count ( Player ) print ( player_count ) #> 3 Directly using driver sessions Every single engine method also accepts a session parameter. You can use this parameter to provide an existing driver (motor or PyMongo) session that you created manually. Accessing the underlying driver session object The session.get_driver_session method exposes the underlying driver session. This is useful if you want to use the driver session directly to perform raw operations.","title":"Using a Session"},{"location":"engine/#using-a-transaction","text":"Why are transactions needed ? A transaction is a mechanism that allows you to execute multiple operations in a single atomic operation. This is useful when you want to ensure that a set of operations is atomicly performed on a specific document. MongoDB transaction support Transactions are only supported in a replica sets (Mongo 4.0+) or sharded clusters with replication enabled (Mongo 4.2+), if you use them in a standalone MongoDB instance an error will be raised. You can create a transaction directly from the engine by using the engine.transaction method. This methods will either return a SyncTransaction or an AIOTransaction object. As for sessions, transaction objects exposes the same database operation methods as the related engine object but execute each operation in a transactional context. In order to terminate a transaction you must either call the commit method to persist all the changes or call the abort method to drop the changes introduced in the transaction. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () async with engine . transaction () as transaction : await transaction . save ( Player ( name = \"Leeroy Jenkins\" , game = \"WoW\" )) await transaction . commit () print ( engine . count ( Player )) #> 1 async with engine . transaction () as transaction : await transaction . save ( Player ( name = \"Shroud\" , game = \"Counter-Strike\" )) await transaction . save ( Player ( name = \"Serral\" , game = \"Starcraft\" )) await transaction . abort () print ( engine . count ( Player )) #> 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from odmantic import Model , SyncEngine class Player ( Model ): name : str game : str engine = SyncEngine () with engine . transaction () as transaction : transaction . save ( Player ( name = \"Leeroy Jenkins\" , game = \"WoW\" )) transaction . commit () print ( engine . count ( Player )) #> 1 with engine . transaction () as transaction : transaction . save ( Player ( name = \"Shroud\" , game = \"Counter-Strike\" )) transaction . save ( Player ( name = \"Serral\" , game = \"Starcraft\" )) transaction . abort () print ( engine . count ( Player )) #> 1 It is also possible to create a transaction within an existing session by using the session.transaction method: Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from odmantic import AIOEngine , Model class Player ( Model ): name : str game : str engine = AIOEngine () async with engine . session () as session : leeroy = await session . save ( Player ( name = \"Leeroy Jenkins\" , game = \"WoW\" )) shroud = await session . save ( Player ( name = \"Shroud\" , game = \"Counter-Strike\" )) async with session . transaction () as transaction : leeroy . game = \"Fortnite\" await transaction . save ( leeroy ) shroud . game = \"Fortnite\" await transaction . save ( shroud ) await transaction . commit () print ( await engine . count ( Player , Player . game == \"Fortnite\" )) #> 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from odmantic import Model , SyncEngine class Player ( Model ): name : str game : str engine = SyncEngine () with engine . session () as session : leeroy = session . save ( Player ( name = \"Leeroy Jenkins\" , game = \"WoW\" )) shroud = session . save ( Player ( name = \"Shroud\" , game = \"Counter-Strike\" )) with session . transaction () as transaction : leeroy . game = \"Fortnite\" transaction . save ( leeroy ) shroud . game = \"Fortnite\" transaction . save ( shroud ) transaction . commit () print ( engine . count ( Player , Player . game == \"Fortnite\" )) #> 2","title":"Using a Transaction"},{"location":"fields/","text":"Fields \u00b6 The id field \u00b6 The ObjectId data type is the default primary key type used by MongoDB. An ObjectId comes with many information embedded into it (timestamp, machine identifier, ...). Since by default MongoDB will create a field _id containing an ObjectId primary key, ODMantic will bind it automatically to an implicit field named id . 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model class Player ( Model ): name : str leeroy = Player ( name = \"Leeroy Jenkins\" ) print ( leeroy . id ) #> ObjectId('5ed50fcad11d1975aa3d7a28') print ( repr ( leeroy )) #> Player(id=ObjectId('5ed50fcad11d1975aa3d7a28'), name=\"Leeroy Jenkins\") ObjectId creation This id field will be generated on instance creation, before saving the instance to the database. This helps to keep consistency between the instances persisted to the database and the ones only created locally. Even if this behavior is convenient, it is still possible to define custom primary keys . Field types \u00b6 Optional fields \u00b6 By default, every single field will be required. To specify a field as non-required, the easiest way is to use the typing.Optional generic type that will allow the field to take the None value as well (it will be stored as null in the database). 1 2 3 4 5 6 7 8 9 10 11 12 from typing import Optional from odmantic import Model class Person ( Model ): name : str age : Optional [ int ] john = Person ( name = \"John\" ) print ( john . age ) #> None Union fields \u00b6 As explained in the Python Typing documentation , Optional[X] is equivalent to Union[X, None] . That implies that the field type will be either X or None . It's possible to combine any kind of type using the typ\u00eeng.Union type constructor. For example if we want to allow both string and int in a field: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from typing import Union from odmantic import Model class Thing ( Model ): ref_id : Union [ int , str ] thing_1 = Thing ( ref_id = 42 ) print ( thing_1 . ref_id ) #> 42 thing_2 = Thing ( ref_id = \"i am a string\" ) print ( thing_2 . ref_id ) #> i am a string NoneType Internally python describes the type of the None object as NoneType but in practice, None is used directly in type annotations ( more details ). Enum fields \u00b6 To define choices, it's possible to use the standard enum classes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from enum import Enum from odmantic import AIOEngine , Model class TreeKind ( str , Enum ): BIG = \"big\" SMALL = \"small\" class Tree ( Model ): name : str kind : TreeKind sequoia = Tree ( name = \"Sequoia\" , kind = TreeKind . BIG ) print ( sequoia . kind ) #> TreeKind.BIG print ( sequoia . kind == \"big\" ) #> True spruce = Tree ( name = \"Spruce\" , kind = \"small\" ) print ( spruce . kind ) #> TreeKind.SMALL print ( spruce . kind == TreeKind . SMALL ) #> True engine = AIOEngine () await engine . save_all ([ sequoia , spruce ]) Resulting documents in the collection tree after execution { \"_id\" : Objec t Id( \"5f818f2dd5708527282c49b6\" ) , \"kind\" : \"big\" , \"name\" : \"Sequoia\" } { \"_id\" : Objec t Id( \"5f818f2dd5708527282c49b7\" ) , \"kind\" : \"small\" , \"name\" : \"Spruce\" } If you try to use a value not present in the allowed choices, a ValidationError exception will be raised. Usage of enum.auto If you might add some values to an Enum , it's strongly recommended not to use the enum.auto value generator. Depending on the order you add choices, it could completely break the consistency with documents stored in the database. Unwanted behavior example 1 2 3 4 5 6 7 8 9 10 11 12 from enum import Enum , auto class Color ( Enum ): RED = auto () BLUE = auto () print ( Color . RED . value ) #> 1 print ( Color . BLUE . value ) #> 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from enum import Enum , auto class Color ( Enum ): RED = auto () GREEN = auto () BLUE = auto () print ( Color . RED . value ) #> 1 print ( Color . GREEN . value ) #> 2 print ( Color . BLUE . value ) #> 3 Container fields \u00b6 List \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from typing import List , Union from odmantic import Model class SimpleListModel ( Model ): field : list print ( SimpleListModel ( field = [ 1 , \"a\" , True ]) . field ) #> [1, 'a', True] print ( SimpleListModel ( field = ( 1 , \"a\" , True )) . field ) #> [1, 'a', True] class IntListModel ( Model ): field : List [ int ] print ( IntListModel ( field = [ 1 , 5 ]) . field ) #> [1, 5] print ( IntListModel ( field = ( 1 , 5 )) . field ) #> [1, 5] class IntStrListModel ( Model ): field : List [ Union [ int , str ]] print ( IntStrListModel ( field = [ 1 , \"b\" ]) . field ) #> [1, 'b'] print ( IntStrListModel ( field = ( 1 , \"b\" )) . field ) #> [1, 'b'] Tip It's possible to define element count constraints for a list field using the Field descriptor. Tuple \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from typing import Tuple from odmantic import Model class SimpleTupleModel ( Model ): field : tuple print ( SimpleTupleModel ( field = [ 1 , \"a\" , True ]) . field ) #> (1, 'a', True) print ( SimpleTupleModel ( field = ( 1 , \"a\" , True )) . field ) #> (1, 'a', True) class TwoIntTupleModel ( Model ): field : Tuple [ int , int ] print ( SimpleTupleModel ( field = ( 1 , 10 )) . field ) #> (1, 10) print ( SimpleTupleModel ( field = [ 1 , 10 ]) . field ) #> (1, 10) class IntTupleModel ( Model ): field : Tuple [ int , ... ] print ( IntTupleModel ( field = ( 1 ,)) . field ) #> (1,) print ( IntTupleModel ( field = [ 1 , 2 , 3 , 10 ]) . field ) #> (1, 2, 3, 10) Dict \u00b6 Tip For mapping types with already known keys, you can see the embedded models section . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from typing import Dict , Union from odmantic import Model class SimpleDictModel ( Model ): field : dict print ( SimpleDictModel ( field = { 18 : \"a string\" , True : 42 , 18.3 : [ 1 , 2 , 3 ]}) . field ) #> {18: 'a string', True: 42, 18.3: [1, 2, 3]} class IntStrDictModel ( Model ): field : Dict [ int , str ] print ( IntStrDictModel ( field = { 1 : \"one\" , 2 : \"two\" }) . field ) #> {1: 'one', 2: 'two'} class IntBoolStrDictModel ( Model ): field : Dict [ int , Union [ bool , str ]] print ( IntBoolStrDictModel ( field = { 0 : False , 1 : True , 3 : \"three\" }) . field ) #> {0: False, 1: True, 3: 'three'} Performance tip Whenever possible, try to avoid mutable container types ( List , Set , ...) and prefer their Immutable alternatives ( Tuple , FrozenSet , ...). This will allow ODMantic to speedup database writes by only saving the modified container fields. BSON types integration \u00b6 ODMantic supports native python BSON types ( bson package ). Those types can be used directly as field types: bson.ObjectId bson.Int64 bson.Decimal128 bson.Regex bson.Binary Generic python to BSON type map Python type BSON type Comment bson.ObjectId objectId bool bool int int value between -2^31 and 2^31 - 1 int long value not between -2^31 and 2^31 - 1 bson.Int64 long float double bson.Decimal128 decimal decimal.Decimal decimal str string typing.Pattern regex bson.Regex regex bytes binData bson.Binary binData datetime.datetime date microseconds are truncated, only naive datetimes are allowed typing.Dict object typing.List array typing.Sequence array typing.Tuple[T, ...] array Pydantic fields \u00b6 Most of the types supported by pydantic are supported by ODMantic. See pydantic: Field Types for more field types. Unsupported fields: typing.Callable Fields with a specific behavior: datetime.datetime : Only naive datetime objects will be allowed as MongoDB doesn't store the timezone information. Also, the microsecond information will be truncated. Customization \u00b6 The field customization can mainly be performed using the Field descriptor. This descriptor is here to define everything about the field except its type. Default values \u00b6 The easiest way to set a default value to a field is by assigning this default value directly while defining the model. 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Model class Player ( Model ): name : str level : int = 0 p = Player ( name = \"Dash\" ) print ( repr ( p )) #> Player(id=ObjectId('5f7cd4be16af832772f1615e'), name='Dash', level=0) You can combine default values and an existing Field descriptor using the default keyword argument. 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Field , Model class Player ( Model ): name : str level : int = Field ( default = 1 , ge = 1 ) p = Player ( name = \"Dash\" ) print ( repr ( p )) #> Player(id=ObjectId('5f7cdbfbb54a94e9e8717c77'), name='Dash', level=1) Default factory You may as well define a factory function instead of a value using the default_factory argument of the Field descriptor. By default, the default factories won't be used while parsing MongoDB documents. It's possible to enable this behavior with the parse_doc_with_default_factories Config option. Tip For typing.Optional fields, None is already set as the default value Default values validation Currently the default values are not validated yet during the model creation. An inconsistent default value might raise a ValidationError while building an instance. Document structure \u00b6 By default, the MongoDB documents fields will be named after the field name. It is possible to override this naming policy by using the key_name argument in the Field descriptor. Async Sync 1 2 3 4 5 6 7 8 9 from odmantic import AIOEngine , Field , Model class Player ( Model ): name : str = Field ( key_name = \"username\" ) engine = AIOEngine () await engine . save ( Player ( name = \"Jack\" )) 1 2 3 4 5 6 7 8 9 from odmantic import SyncEngine , Field , Model class Player ( Model ): name : str = Field ( key_name = \"username\" ) engine = SyncEngine () engine . save ( Player ( name = \"Jack\" )) Resulting documents in the collection player after execution { \"_id\" : Objec t Id( \"5ed50fcad11d1975aa3d7a28\" ) , \"username\" : \"Jack\" , } See this section for more details about the _id field that has been added. Primary key \u00b6 While ODMantic will by default populate the id field as a primary key, you can use any other field as the primary key. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 from odmantic import AIOEngine , Field , Model class Player ( Model ): name : str = Field ( primary_field = True ) leeroy = Player ( name = \"Leeroy Jenkins\" ) print ( repr ( leeroy )) #> Player(name=\"Leeroy Jenkins\") engine = AIOEngine () await engine . save ( leeroy ) 1 2 3 4 5 6 7 8 9 10 11 12 13 from odmantic import SyncEngine , Field , Model class Player ( Model ): name : str = Field ( primary_field = True ) leeroy = Player ( name = \"Leeroy Jenkins\" ) print ( repr ( leeroy )) #> Player(name=\"Leeroy Jenkins\") engine = SyncEngine () engine . save ( leeroy ) Resulting documents in the collection player after execution { \"_id\" : \"Leeroy Jenkins\" } Info The Mongo name of the primary field will be enforced to _id and you will not be able to change it. Warning Using mutable types (Set, List, ...) as primary field might result in inconsistent behaviors. Indexed fields \u00b6 You can define an index on a single field by using the index argument of the Field descriptor. More details about index creation can be found in the Indexes section. Async Sync 1 2 3 4 5 6 7 8 9 10 from odmantic import AIOEngine , Field , Model class Player ( Model ): name : str score : int = Field ( index = True ) engine = AIOEngine () await engine . configure_database ([ Player ]) 1 2 3 4 5 6 7 8 9 10 from odmantic import Field , Model , SyncEngine class Player ( Model ): name : str score : int = Field ( index = True ) engine = SyncEngine () engine . configure_database ([ Player ]) Warning When using indexes, make sure to call the configure_database method ( AIOEngine.configure_database or SyncEngine.configure_database ) to persist the indexes to the database. Unique fields \u00b6 In the same way, you can define unique constrains on a single field by using the unique argument of the Field descriptor. This will ensure that values of this fields are unique among all the instances saved in the database. More details about unique index creation can be found in the Indexes section. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from odmantic import AIOEngine , Field , Model class Player ( Model ): name : str = Field ( unique = True ) engine = AIOEngine () await engine . configure_database ([ Player ]) leeroy = Player ( name = \"Leeroy\" ) await engine . save ( leeroy ) another_leeroy = Player ( name = \"Leeroy\" ) await engine . save ( another_leeroy ) #> Raises odmantic.exceptions.DuplicateKeyError: #> Duplicate key error for: Player. #> Instance: id=ObjectId('6314b4c25a19444bfe0c0be5') name='Leeroy' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from odmantic import Field , Model , SyncEngine class Player ( Model ): name : str = Field ( unique = True ) engine = SyncEngine () engine . configure_database ([ Player ]) leeroy = Player ( name = \"Leeroy\" ) engine . save ( leeroy ) another_leeroy = Player ( name = \"Leeroy\" ) engine . save ( another_leeroy ) #> Raises odmantic.exceptions.DuplicateKeyError: #> Duplicate key error for: Player. #> Instance: id=ObjectId('6314b4c25a19444bfe0c0be5') name='Leeroy' Warning When using indexes, make sure to call the configure_database method ( AIOEngine.configure_database or SyncEngine.configure_database ) to persist the indexes to the database. Validation \u00b6 As ODMantic strongly relies on pydantic when it comes to data validation, most of the validation features provided by pydantic are available: Add field validation constraints by using the Field descriptor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from typing import List from odmantic import Field , Model class ExampleModel ( Model ): small_int : int = Field ( le = 10 ) big_int : int = Field ( gt = 1000 ) even_int : int = Field ( multiple_of = 2 ) small_float : float = Field ( lt = 10 ) big_float : float = Field ( ge = 1e10 ) short_string : str = Field ( max_length = 10 ) long_string : str = Field ( min_length = 100 ) string_starting_with_the : str = Field ( regex = r \"^The\" ) short_str_list : List [ str ] = Field ( max_items = 5 ) long_str_list : List [ str ] = Field ( min_items = 15 ) Use strict types to prevent to coercion from compatible types ( pydantic: Strict Types ) 1 2 3 4 5 6 7 8 9 from pydantic import StrictBool , StrictFloat , StrictStr from odmantic import Model class ExampleModel ( Model ): strict_bool : StrictBool strict_float : StrictFloat strict_str : StrictStr Define custom field validators ( pydantic: Validators ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 from typing import ClassVar from pydantic import ValidationError , validator from odmantic import Model class SmallRectangle ( Model ): MAX_SIDE_SIZE : ClassVar [ float ] = 10 length : float width : float @validator ( \"width\" , \"length\" ) def check_small_sides ( cls , v ): if v > cls . MAX_SIDE_SIZE : raise ValueError ( f \"side is greater than { cls . MAX_SIDE_SIZE } \" ) return v @validator ( \"width\" ) def check_width_length ( cls , width , values , ** kwargs ): length = values . get ( \"length\" ) if length is not None and width > length : raise ValueError ( \"width can't be greater than length\" ) return width print ( SmallRectangle ( length = 2 , width = 1 )) #> id=ObjectId('5f81e3c073103f509f97e374'), length=2.0, width=1.0 try : SmallRectangle ( length = 2 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width field required (type=value_error.missing) \"\"\" try : SmallRectangle ( length = 2 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width width can't be greater than length (type=value_error) \"\"\" try : SmallRectangle ( length = 40 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle length side is greater than 10 (type=value_error) \"\"\" Define custom model validators: more details Custom field types \u00b6 Exactly in the same way pydantic allows it, it's possible to define custom field types as well with ODMantic ( pydantic: Custom data types ). Sometimes, it might be required to customize as well the field BSON serialization. In order to do this, the field class will have to implement the __bson__ class method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from bson import Binary from odmantic import AIOEngine , Model class ASCIISerializedAsBinary ( str ): @classmethod def __get_validators__ ( cls ): yield cls . validate @classmethod def validate ( cls , v ): if isinstance ( v , bytes ): # Handle data coming from MongoDB return v . decode ( \"ascii\" ) if not isinstance ( v , str ): raise TypeError ( \"string required\" ) if not v . isascii (): raise ValueError ( \"Only ascii characters are allowed\" ) return v @classmethod def __bson__ ( cls , v : str ): # We can encode this string as ascii since it contains # only ascii characters bytes_ = v . encode ( \"ascii\" ) return bytes_ class Example ( Model ): field : ASCIISerializedAsBinary engine = AIOEngine () await engine . save ( Example ( field = \"hello world\" )) fetched = await engine . find_one ( Example ) print ( fetched . field ) #> hello world In this example, we decide to store string data manually encoded in the ASCII encoding. The encoding is handled in the __bson__ class method. On top of this, we handle the decoding by attempting to decode bytes object in the validate method. Resulting documents in the collection example after execution { \"_id\" : Objec t Id( \"5f81fa5e8adaf4bf33f05035\" ) , \"field\" : Bi n Da ta ( 0 , \"aGVsbG8gd29ybGQ=\" ) } Warning When using custom bson serialization, it's important to handle as well the data validation for data retrieved from Mongo. In the previous example it's done by handling bytes objects in the validate method.","title":"Fields"},{"location":"fields/#fields","text":"","title":"Fields"},{"location":"fields/#the-id-field","text":"The ObjectId data type is the default primary key type used by MongoDB. An ObjectId comes with many information embedded into it (timestamp, machine identifier, ...). Since by default MongoDB will create a field _id containing an ObjectId primary key, ODMantic will bind it automatically to an implicit field named id . 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model class Player ( Model ): name : str leeroy = Player ( name = \"Leeroy Jenkins\" ) print ( leeroy . id ) #> ObjectId('5ed50fcad11d1975aa3d7a28') print ( repr ( leeroy )) #> Player(id=ObjectId('5ed50fcad11d1975aa3d7a28'), name=\"Leeroy Jenkins\") ObjectId creation This id field will be generated on instance creation, before saving the instance to the database. This helps to keep consistency between the instances persisted to the database and the ones only created locally. Even if this behavior is convenient, it is still possible to define custom primary keys .","title":"The id field"},{"location":"fields/#field-types","text":"","title":"Field types"},{"location":"fields/#optional-fields","text":"By default, every single field will be required. To specify a field as non-required, the easiest way is to use the typing.Optional generic type that will allow the field to take the None value as well (it will be stored as null in the database). 1 2 3 4 5 6 7 8 9 10 11 12 from typing import Optional from odmantic import Model class Person ( Model ): name : str age : Optional [ int ] john = Person ( name = \"John\" ) print ( john . age ) #> None","title":"Optional fields"},{"location":"fields/#union-fields","text":"As explained in the Python Typing documentation , Optional[X] is equivalent to Union[X, None] . That implies that the field type will be either X or None . It's possible to combine any kind of type using the typ\u00eeng.Union type constructor. For example if we want to allow both string and int in a field: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from typing import Union from odmantic import Model class Thing ( Model ): ref_id : Union [ int , str ] thing_1 = Thing ( ref_id = 42 ) print ( thing_1 . ref_id ) #> 42 thing_2 = Thing ( ref_id = \"i am a string\" ) print ( thing_2 . ref_id ) #> i am a string NoneType Internally python describes the type of the None object as NoneType but in practice, None is used directly in type annotations ( more details ).","title":"Union fields"},{"location":"fields/#enum-fields","text":"To define choices, it's possible to use the standard enum classes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from enum import Enum from odmantic import AIOEngine , Model class TreeKind ( str , Enum ): BIG = \"big\" SMALL = \"small\" class Tree ( Model ): name : str kind : TreeKind sequoia = Tree ( name = \"Sequoia\" , kind = TreeKind . BIG ) print ( sequoia . kind ) #> TreeKind.BIG print ( sequoia . kind == \"big\" ) #> True spruce = Tree ( name = \"Spruce\" , kind = \"small\" ) print ( spruce . kind ) #> TreeKind.SMALL print ( spruce . kind == TreeKind . SMALL ) #> True engine = AIOEngine () await engine . save_all ([ sequoia , spruce ]) Resulting documents in the collection tree after execution { \"_id\" : Objec t Id( \"5f818f2dd5708527282c49b6\" ) , \"kind\" : \"big\" , \"name\" : \"Sequoia\" } { \"_id\" : Objec t Id( \"5f818f2dd5708527282c49b7\" ) , \"kind\" : \"small\" , \"name\" : \"Spruce\" } If you try to use a value not present in the allowed choices, a ValidationError exception will be raised. Usage of enum.auto If you might add some values to an Enum , it's strongly recommended not to use the enum.auto value generator. Depending on the order you add choices, it could completely break the consistency with documents stored in the database. Unwanted behavior example 1 2 3 4 5 6 7 8 9 10 11 12 from enum import Enum , auto class Color ( Enum ): RED = auto () BLUE = auto () print ( Color . RED . value ) #> 1 print ( Color . BLUE . value ) #> 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from enum import Enum , auto class Color ( Enum ): RED = auto () GREEN = auto () BLUE = auto () print ( Color . RED . value ) #> 1 print ( Color . GREEN . value ) #> 2 print ( Color . BLUE . value ) #> 3","title":"Enum fields"},{"location":"fields/#container-fields","text":"","title":"Container fields"},{"location":"fields/#list","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from typing import List , Union from odmantic import Model class SimpleListModel ( Model ): field : list print ( SimpleListModel ( field = [ 1 , \"a\" , True ]) . field ) #> [1, 'a', True] print ( SimpleListModel ( field = ( 1 , \"a\" , True )) . field ) #> [1, 'a', True] class IntListModel ( Model ): field : List [ int ] print ( IntListModel ( field = [ 1 , 5 ]) . field ) #> [1, 5] print ( IntListModel ( field = ( 1 , 5 )) . field ) #> [1, 5] class IntStrListModel ( Model ): field : List [ Union [ int , str ]] print ( IntStrListModel ( field = [ 1 , \"b\" ]) . field ) #> [1, 'b'] print ( IntStrListModel ( field = ( 1 , \"b\" )) . field ) #> [1, 'b'] Tip It's possible to define element count constraints for a list field using the Field descriptor.","title":"List"},{"location":"fields/#tuple","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from typing import Tuple from odmantic import Model class SimpleTupleModel ( Model ): field : tuple print ( SimpleTupleModel ( field = [ 1 , \"a\" , True ]) . field ) #> (1, 'a', True) print ( SimpleTupleModel ( field = ( 1 , \"a\" , True )) . field ) #> (1, 'a', True) class TwoIntTupleModel ( Model ): field : Tuple [ int , int ] print ( SimpleTupleModel ( field = ( 1 , 10 )) . field ) #> (1, 10) print ( SimpleTupleModel ( field = [ 1 , 10 ]) . field ) #> (1, 10) class IntTupleModel ( Model ): field : Tuple [ int , ... ] print ( IntTupleModel ( field = ( 1 ,)) . field ) #> (1,) print ( IntTupleModel ( field = [ 1 , 2 , 3 , 10 ]) . field ) #> (1, 2, 3, 10)","title":"Tuple"},{"location":"fields/#dict","text":"Tip For mapping types with already known keys, you can see the embedded models section . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from typing import Dict , Union from odmantic import Model class SimpleDictModel ( Model ): field : dict print ( SimpleDictModel ( field = { 18 : \"a string\" , True : 42 , 18.3 : [ 1 , 2 , 3 ]}) . field ) #> {18: 'a string', True: 42, 18.3: [1, 2, 3]} class IntStrDictModel ( Model ): field : Dict [ int , str ] print ( IntStrDictModel ( field = { 1 : \"one\" , 2 : \"two\" }) . field ) #> {1: 'one', 2: 'two'} class IntBoolStrDictModel ( Model ): field : Dict [ int , Union [ bool , str ]] print ( IntBoolStrDictModel ( field = { 0 : False , 1 : True , 3 : \"three\" }) . field ) #> {0: False, 1: True, 3: 'three'} Performance tip Whenever possible, try to avoid mutable container types ( List , Set , ...) and prefer their Immutable alternatives ( Tuple , FrozenSet , ...). This will allow ODMantic to speedup database writes by only saving the modified container fields.","title":"Dict"},{"location":"fields/#bson-types-integration","text":"ODMantic supports native python BSON types ( bson package ). Those types can be used directly as field types: bson.ObjectId bson.Int64 bson.Decimal128 bson.Regex bson.Binary Generic python to BSON type map Python type BSON type Comment bson.ObjectId objectId bool bool int int value between -2^31 and 2^31 - 1 int long value not between -2^31 and 2^31 - 1 bson.Int64 long float double bson.Decimal128 decimal decimal.Decimal decimal str string typing.Pattern regex bson.Regex regex bytes binData bson.Binary binData datetime.datetime date microseconds are truncated, only naive datetimes are allowed typing.Dict object typing.List array typing.Sequence array typing.Tuple[T, ...] array","title":"BSON types integration"},{"location":"fields/#pydantic-fields","text":"Most of the types supported by pydantic are supported by ODMantic. See pydantic: Field Types for more field types. Unsupported fields: typing.Callable Fields with a specific behavior: datetime.datetime : Only naive datetime objects will be allowed as MongoDB doesn't store the timezone information. Also, the microsecond information will be truncated.","title":"Pydantic fields"},{"location":"fields/#customization","text":"The field customization can mainly be performed using the Field descriptor. This descriptor is here to define everything about the field except its type.","title":"Customization"},{"location":"fields/#default-values","text":"The easiest way to set a default value to a field is by assigning this default value directly while defining the model. 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Model class Player ( Model ): name : str level : int = 0 p = Player ( name = \"Dash\" ) print ( repr ( p )) #> Player(id=ObjectId('5f7cd4be16af832772f1615e'), name='Dash', level=0) You can combine default values and an existing Field descriptor using the default keyword argument. 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Field , Model class Player ( Model ): name : str level : int = Field ( default = 1 , ge = 1 ) p = Player ( name = \"Dash\" ) print ( repr ( p )) #> Player(id=ObjectId('5f7cdbfbb54a94e9e8717c77'), name='Dash', level=1) Default factory You may as well define a factory function instead of a value using the default_factory argument of the Field descriptor. By default, the default factories won't be used while parsing MongoDB documents. It's possible to enable this behavior with the parse_doc_with_default_factories Config option. Tip For typing.Optional fields, None is already set as the default value Default values validation Currently the default values are not validated yet during the model creation. An inconsistent default value might raise a ValidationError while building an instance.","title":"Default values"},{"location":"fields/#document-structure","text":"By default, the MongoDB documents fields will be named after the field name. It is possible to override this naming policy by using the key_name argument in the Field descriptor. Async Sync 1 2 3 4 5 6 7 8 9 from odmantic import AIOEngine , Field , Model class Player ( Model ): name : str = Field ( key_name = \"username\" ) engine = AIOEngine () await engine . save ( Player ( name = \"Jack\" )) 1 2 3 4 5 6 7 8 9 from odmantic import SyncEngine , Field , Model class Player ( Model ): name : str = Field ( key_name = \"username\" ) engine = SyncEngine () engine . save ( Player ( name = \"Jack\" )) Resulting documents in the collection player after execution { \"_id\" : Objec t Id( \"5ed50fcad11d1975aa3d7a28\" ) , \"username\" : \"Jack\" , } See this section for more details about the _id field that has been added.","title":"Document structure"},{"location":"fields/#primary-key","text":"While ODMantic will by default populate the id field as a primary key, you can use any other field as the primary key. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 from odmantic import AIOEngine , Field , Model class Player ( Model ): name : str = Field ( primary_field = True ) leeroy = Player ( name = \"Leeroy Jenkins\" ) print ( repr ( leeroy )) #> Player(name=\"Leeroy Jenkins\") engine = AIOEngine () await engine . save ( leeroy ) 1 2 3 4 5 6 7 8 9 10 11 12 13 from odmantic import SyncEngine , Field , Model class Player ( Model ): name : str = Field ( primary_field = True ) leeroy = Player ( name = \"Leeroy Jenkins\" ) print ( repr ( leeroy )) #> Player(name=\"Leeroy Jenkins\") engine = SyncEngine () engine . save ( leeroy ) Resulting documents in the collection player after execution { \"_id\" : \"Leeroy Jenkins\" } Info The Mongo name of the primary field will be enforced to _id and you will not be able to change it. Warning Using mutable types (Set, List, ...) as primary field might result in inconsistent behaviors.","title":"Primary key"},{"location":"fields/#indexed-fields","text":"You can define an index on a single field by using the index argument of the Field descriptor. More details about index creation can be found in the Indexes section. Async Sync 1 2 3 4 5 6 7 8 9 10 from odmantic import AIOEngine , Field , Model class Player ( Model ): name : str score : int = Field ( index = True ) engine = AIOEngine () await engine . configure_database ([ Player ]) 1 2 3 4 5 6 7 8 9 10 from odmantic import Field , Model , SyncEngine class Player ( Model ): name : str score : int = Field ( index = True ) engine = SyncEngine () engine . configure_database ([ Player ]) Warning When using indexes, make sure to call the configure_database method ( AIOEngine.configure_database or SyncEngine.configure_database ) to persist the indexes to the database.","title":"Indexed fields"},{"location":"fields/#unique-fields","text":"In the same way, you can define unique constrains on a single field by using the unique argument of the Field descriptor. This will ensure that values of this fields are unique among all the instances saved in the database. More details about unique index creation can be found in the Indexes section. Async Sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from odmantic import AIOEngine , Field , Model class Player ( Model ): name : str = Field ( unique = True ) engine = AIOEngine () await engine . configure_database ([ Player ]) leeroy = Player ( name = \"Leeroy\" ) await engine . save ( leeroy ) another_leeroy = Player ( name = \"Leeroy\" ) await engine . save ( another_leeroy ) #> Raises odmantic.exceptions.DuplicateKeyError: #> Duplicate key error for: Player. #> Instance: id=ObjectId('6314b4c25a19444bfe0c0be5') name='Leeroy' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from odmantic import Field , Model , SyncEngine class Player ( Model ): name : str = Field ( unique = True ) engine = SyncEngine () engine . configure_database ([ Player ]) leeroy = Player ( name = \"Leeroy\" ) engine . save ( leeroy ) another_leeroy = Player ( name = \"Leeroy\" ) engine . save ( another_leeroy ) #> Raises odmantic.exceptions.DuplicateKeyError: #> Duplicate key error for: Player. #> Instance: id=ObjectId('6314b4c25a19444bfe0c0be5') name='Leeroy' Warning When using indexes, make sure to call the configure_database method ( AIOEngine.configure_database or SyncEngine.configure_database ) to persist the indexes to the database.","title":"Unique fields"},{"location":"fields/#validation","text":"As ODMantic strongly relies on pydantic when it comes to data validation, most of the validation features provided by pydantic are available: Add field validation constraints by using the Field descriptor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from typing import List from odmantic import Field , Model class ExampleModel ( Model ): small_int : int = Field ( le = 10 ) big_int : int = Field ( gt = 1000 ) even_int : int = Field ( multiple_of = 2 ) small_float : float = Field ( lt = 10 ) big_float : float = Field ( ge = 1e10 ) short_string : str = Field ( max_length = 10 ) long_string : str = Field ( min_length = 100 ) string_starting_with_the : str = Field ( regex = r \"^The\" ) short_str_list : List [ str ] = Field ( max_items = 5 ) long_str_list : List [ str ] = Field ( min_items = 15 ) Use strict types to prevent to coercion from compatible types ( pydantic: Strict Types ) 1 2 3 4 5 6 7 8 9 from pydantic import StrictBool , StrictFloat , StrictStr from odmantic import Model class ExampleModel ( Model ): strict_bool : StrictBool strict_float : StrictFloat strict_str : StrictStr Define custom field validators ( pydantic: Validators ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 from typing import ClassVar from pydantic import ValidationError , validator from odmantic import Model class SmallRectangle ( Model ): MAX_SIDE_SIZE : ClassVar [ float ] = 10 length : float width : float @validator ( \"width\" , \"length\" ) def check_small_sides ( cls , v ): if v > cls . MAX_SIDE_SIZE : raise ValueError ( f \"side is greater than { cls . MAX_SIDE_SIZE } \" ) return v @validator ( \"width\" ) def check_width_length ( cls , width , values , ** kwargs ): length = values . get ( \"length\" ) if length is not None and width > length : raise ValueError ( \"width can't be greater than length\" ) return width print ( SmallRectangle ( length = 2 , width = 1 )) #> id=ObjectId('5f81e3c073103f509f97e374'), length=2.0, width=1.0 try : SmallRectangle ( length = 2 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width field required (type=value_error.missing) \"\"\" try : SmallRectangle ( length = 2 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width width can't be greater than length (type=value_error) \"\"\" try : SmallRectangle ( length = 40 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle length side is greater than 10 (type=value_error) \"\"\" Define custom model validators: more details","title":"Validation"},{"location":"fields/#custom-field-types","text":"Exactly in the same way pydantic allows it, it's possible to define custom field types as well with ODMantic ( pydantic: Custom data types ). Sometimes, it might be required to customize as well the field BSON serialization. In order to do this, the field class will have to implement the __bson__ class method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from bson import Binary from odmantic import AIOEngine , Model class ASCIISerializedAsBinary ( str ): @classmethod def __get_validators__ ( cls ): yield cls . validate @classmethod def validate ( cls , v ): if isinstance ( v , bytes ): # Handle data coming from MongoDB return v . decode ( \"ascii\" ) if not isinstance ( v , str ): raise TypeError ( \"string required\" ) if not v . isascii (): raise ValueError ( \"Only ascii characters are allowed\" ) return v @classmethod def __bson__ ( cls , v : str ): # We can encode this string as ascii since it contains # only ascii characters bytes_ = v . encode ( \"ascii\" ) return bytes_ class Example ( Model ): field : ASCIISerializedAsBinary engine = AIOEngine () await engine . save ( Example ( field = \"hello world\" )) fetched = await engine . find_one ( Example ) print ( fetched . field ) #> hello world In this example, we decide to store string data manually encoded in the ASCII encoding. The encoding is handled in the __bson__ class method. On top of this, we handle the decoding by attempting to decode bytes object in the validate method. Resulting documents in the collection example after execution { \"_id\" : Objec t Id( \"5f81fa5e8adaf4bf33f05035\" ) , \"field\" : Bi n Da ta ( 0 , \"aGVsbG8gd29ybGQ=\" ) } Warning When using custom bson serialization, it's important to handle as well the data validation for data retrieved from Mongo. In the previous example it's done by handling bytes objects in the validate method.","title":"Custom field types"},{"location":"modeling/","text":"Modeling \u00b6 Models \u00b6 To create a Model, simply inherit from the Model class and then specify the field types and eventually their descriptors. Collection \u00b6 Each Model will be linked to its own collection. By default, the collection name will be created from the chosen class name and converted to snake_case . For example a model class named CapitalCity will be stored in the collection named capital_city . If the class name ends with Model , ODMantic will remove it to create the collection name. For example, a model class named PersonModel will belong in the person collection. It's possible to customize the collection name of a model by specifying the collection option in the Config class. Custom collection name example from odmantic import Model class CapitalCity ( Model ): name : str population : int class Config : collection = \"city\" Now, when CapitalCity instances will be persisted to the database, they will belong in the city collection instead of capital_city . Warning Models and Embedded models inheritance is not supported yet. Indexes \u00b6 Index definition \u00b6 There are two ways to create indexes on a model in ODMantic. The first one is to use the Field descriptors as explained in Indexed fields or Unique fields . However, this way doesn't allow a great flexibility on index definition. That's why you can also use the Config.indexes generator to specify advanced indexes (compound indexes, custom names). This static function defined in the Config class should yield odmantic.Index . For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import Field , Index , Model class Product ( Model ): name : str = Field ( index = True ) stock : int category : str sku : str = Field ( unique = True ) class Config : @staticmethod def indexes (): yield Index ( Product . name , Product . stock , name = \"name_stock_index\" ) yield Index ( Product . name , Product . category , unique = True ) This snippet creates 4 indexes on the Product model: An index on the name field defined with the field descriptor , improving lookup performance by product name. A unique index on the sku field defined with the field descriptor , enforcing uniqueness of the sku field. A compound index on the name and stock fields, making sure the following query will be efficient (i.e. avoid a full collection scan): engine . find ( Product , Product . name == \"banana\" , Product . stock > 5 ) A unique index on the name and category fields, making sure each category has unique product name. Sort orders with index definition You can also specify the sort order of the fields in the index definition using query.asc and query.desc as presented in the Sorting section. For example defining the following index on the Event model: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from datetime import datetime from odmantic import Index , Model from odmantic.query import asc , desc class Event ( Model ): username : str date : datetime class Config : @staticmethod def indexes (): yield Index ( asc ( Event . username ), desc ( Event . date )) Will greatly improve the performance of the query: engine . find ( Event , sort = ( asc ( Event . name ), desc ( Event . date )) Index creation \u00b6 In order to create and enable the indexes in the database, you need to call the engine.configure_database method (either AIOEngine.configure_database or SyncEngine.configure_database ). Async Sync 1 2 3 4 5 6 # ... Continuation of the previous snippet ... from odmantic import AIOEngine engine = AIOEngine () await engine . configure_database ([ Product ]) 1 2 3 4 5 6 # ... Continuation of the previous snippet ... from odmantic import SyncEngine engine = SyncEngine () engine . configure_database ([ Product ]) This method can also take a update_existing_indexes = True parameter to update existing indexes when the index definition changes. If not enabled, an exception will be thrown when a conflicting index update happens. Advanced indexes \u00b6 In some cases, you might need a greater flexibility on the index definition (Geo2D, Hashed, Text indexes for example), the Config.indexes generator can also yield pymongo.IndexModel objects. For example, defining a text index : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import pymongo from odmantic import Model class Post ( Model ): title : str content : str class Config : @staticmethod def indexes (): yield pymongo . IndexModel ( [( + Post . title , pymongo . TEXT ), ( + Post . content , pymongo . TEXT )] ) Custom model validators \u00b6 Exactly as done with pydantic, it's possible to define custom model validators as described in the pydantic: Root Validators documentation (this apply as well to Embedded Models). In the following example, we will define a rectangle class and add two validators: The first one will check that the height is greater than the width. The second one will ensure that the area of the rectangle is less or equal to 9. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 from typing import ClassVar from pydantic import ValidationError , root_validator from odmantic import Model class SmallRectangle ( Model ): MAX_AREA : ClassVar [ float ] = 9 length : float width : float @root_validator def check_width_length ( cls , values ): length = values . get ( \"length\" , 0 ) width = values . get ( \"width\" , 0 ) if width > length : raise ValueError ( \"width can't be greater than length\" ) return values @root_validator def check_area ( cls , values ): length = values . get ( \"length\" , 0 ) width = values . get ( \"width\" , 0 ) if length * width > cls . MAX_AREA : raise ValueError ( f \"area is greater than { cls . MAX_AREA } \" ) return values print ( SmallRectangle ( length = 2 , width = 1 )) #> id=ObjectId('5f81e3c073103f509f97e374'), length=2.0, width=1.0 try : SmallRectangle ( length = 2 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width field required (type=value_error.missing) \"\"\" try : SmallRectangle ( length = 2 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle __root__ width can't be greater than length (type=value_error) \"\"\" try : SmallRectangle ( length = 4 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle __root__ area is greater than 9 (type=value_error) \"\"\" Tip You can define class variables in the Models using the typing.ClassVar type construct, as done in this example with MAX_AREA . Those class variables will be completely ignored by ODMantic while persisting instances to the database. Advanced Configuration \u00b6 The model configuration is done in the same way as with Pydantic models: using a Config class defined in the model body. Available options : collection : str Customize the collection name associated to the model. See this section for more details about default collection naming. parse_doc_with_default_factories : bool Wether to allow populating field values with default factories while parsing documents from the database. See Advanced parsing behavior for more details. Default: False indexes : Callable [[], Iterable [ Union [ Index , pymongo . IndexModel ]]] Define additional indexes for the model. See Indexes for more details. Default: lambda : [] title : str (inherited from Pydantic) Title inferred in the JSON schema. Default: name of the model class schema_extra : dict (inherited from Pydantic) A dict used to extend/update the generated JSON Schema, or a callable to post-process it. See Pydantic: Schema customization for more details. Default: {} anystr_strip_whitespace : bool (inherited from Pydantic) Whether to strip leading and trailing whitespaces for str & byte types. Default: False json_encoders : dict (inherited from Pydantic) Customize the way types used in the model are encoded to JSON. json_encoders example For example, in order to serialize datetime fields as timestamp values: class Event ( Model ): date : datetime class Config : json_encoders = { datetime : lambda v : v . timestamp () } extra : pydantic . Extra (inherited from Pydantic) Whether to ignore, allow, or forbid extra attributes during model initialization. Accepts the string values of 'ignore', 'allow', or 'forbid', or values of the Extra enum. 'forbid' will cause validation to fail if extra attributes are included, 'ignore' will silently ignore any extra attributes, and 'allow' will assign the attributes to the model, reflecting them in the saved database documents and fetched instances. Default: Extra . ignore json_loads (inherited from Pydantic) Function used to decode JSON data Default: json . loads json_dumps (inherited from Pydantic) Function used to encode JSON data Default: json . dumps For more details and examples about the options inherited from Pydantic, you can have a look to Pydantic: Model Config Warning Only the options described above are supported and other options from Pydantic can't be used with ODMantic. If you feel the need to have an additional option inherited from Pydantic, you can open an issue . Embedded Models \u00b6 Using an embedded model will store it directly in the root model it's integrated in. On the MongoDB side, the collection will contain the root documents and in inside each of them, the embedded models will be directly stored. Embedded models are especially useful while building one-to-one or one-to-many relationships. Note Since Embedded Models are directly embedded in the MongoDB collection of the root model, it will not be possible to query on them directly without specifying a root document. The creation of an Embedded model is done by inheriting the EmbeddedModel class. You can then define fields exactly as for the regular Models. One to One \u00b6 In this example, we will model the relation between a country and its capital city. Since one capital city can belong to one and only one country, we can model this relation as a One-to-One relationship. We will use an Embedded Model in this case. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from odmantic import AIOEngine , EmbeddedModel , Model class CapitalCity ( EmbeddedModel ): name : str population : int class Country ( Model ): name : str currency : str capital_city : CapitalCity countries = [ Country ( name = \"Switzerland\" , currency = \"Swiss franc\" , capital_city = CapitalCity ( name = \"Bern\" , population = 1035000 ), ), Country ( name = \"Sweden\" , currency = \"Swedish krona\" , capital_city = CapitalCity ( name = \"Stockholm\" , population = 975904 ), ), ] engine = AIOEngine () await engine . save_all ( countries ) Defining this relation is done in the same way as defining a new field. Here, the CapitalCity class will be considered as a field type during the model definition. The Field descriptor can be used as well for Embedded Models in order to bring more flexibility (default values, Mongo key name, ...). Content of the country collection after execution { \"_id\" : Objec t Id( \"5f79d7e8b305f24ca43593e2\" ) , \"name\" : \"Sweden\" , \"currency\" : \"Swedish krona\" , \"capital_city\" : { \"name\" : \"Stockholm\" , \"population\" : 975904 } } { \"_id\" : Objec t Id( \"5f79d7e8b305f24ca43593e1\" ) , \"name\" : \"Switzerland\" , \"currency\" : \"Swiss franc\" , \"capital_city\" : { \"name\" : \"Bern\" , \"population\" : 1035000 } } Tip It is possible as well to define query filters based on embedded documents content. await engine . find_one ( Country , Country . capital_city . name == \"Stockholm\" ) #> Country( #> id=ObjectId(\"5f79d7e8b305f24ca43593e2\"), #> name=\"Sweden\", #> currency=\"Swedish krona\", #> capital_city=CapitalCity(name=\"Stockholm\", population=975904), #> ) For more details, see the Querying section. One to Many \u00b6 Here, we will model the relation between a customer of an online shop and his shipping addresses. A single customer can have multiple addresses but these addresses belong only to the customer's account. He should be allowed to modify them without modifying others addresses (for example if two family members use the same address, their addresses should not be linked together). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from typing import List from odmantic import AIOEngine , EmbeddedModel , Model class Address ( EmbeddedModel ): street : str city : str state : str zipcode : str class Customer ( Model ): name : str addresses : List [ Address ] customer = Customer ( name = \"John Doe\" , addresses = [ Address ( street = \"1757 Birch Street\" , city = \"Greenwood\" , state = \"Indiana\" , zipcode = \"46142\" , ), Address ( street = \"262 Barnes Avenue\" , city = \"Cincinnati\" , state = \"Ohio\" , zipcode = \"45216\" , ), ], ) engine = AIOEngine () await engine . save ( customer ) As done previously for the One to One relation, defining a One to Many relationship with Embedded Models is done exactly as defining a field with its type being a sequence of Address objects. Content of the customer collection after execution { \"_id\" : Objec t Id( \"5f79eb116371e09b16e4fae4\" ) , \"name\" : \"John Doe\" , \"addresses\" :[ { \"street\" : \"1757 Birch Street\" , \"city\" : \"Greenwood\" , \"state\" : \"Indiana\" , \"zipcode\" : \"46142\" }, { \"street\" : \"262 Barnes Avenue\" , \"city\" : \"Cincinnati\" , \"state\" : \"Ohio\" , \"zipcode\" : \"45216\" } ] } Tip To add conditions on the number of embedded elements, it's possible to use the min_items and max_items arguments of the Field descriptor. Another possibility is to use the typing.Tuple type. Note Building query filters based on the content of a sequence of embedded documents is not supported yet (but this feature is planned for an upcoming release ). Anyway, it's still possible to perform the filtering operation manually using Mongo Array Operators ( $all , $elemMatch , $size ). See the Raw query usage section for more details. Customization \u00b6 Since the Embedded Models are considered as types by ODMantic, most of the complex type constructs that could be imagined should be supported. Some ideas which could be useful: Combine two different embedded models in a single field using typing.Tuple . Allow multiple Embedded model types using a typing.Union type. Make an Embedded model not required using typing.Optional . Embed the documents in a dictionary (using the typing.Dict type) to provide an additional key-value mapping to the embedded documents. Nest embedded documents Referenced models \u00b6 Embedded models are really simple to use but sometimes it is needed as well to have many-to-one (i.e. multiple entities referring to another single one) or many-to-many relationships. This is not really possible to model those using embedded documents and in this case, references will come handy. Another use case where references are useful is for one-to-one/one-to-many relations but when the referenced model has to exist in its own collection, in order to be accessed on its own without any parent model specified. Many to One (Mapped) \u00b6 In this part, we will model the relation between books and publishers. Let's consider that each book has a single publisher. In this case, multiple books could be published by the same publisher. We can thus model this relation as a many-to-one relationship. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from odmantic import AIOEngine , Model , Reference class Publisher ( Model ): name : str founded : int location : str class Book ( Model ): title : str pages : int publisher : Publisher = Reference () hachette = Publisher ( name = \"Hachette Livre\" , founded = 1826 , location = \"FR\" ) harper = Publisher ( name = \"HarperCollins\" , founded = 1989 , location = \"US\" ) books = [ Book ( title = \"They Didn't See Us Coming\" , pages = 304 , publisher = hachette ), Book ( title = \"This Isn't Happening\" , pages = 256 , publisher = hachette ), Book ( title = \"Prodigal Summer\" , pages = 464 , publisher = harper ), ] engine = AIOEngine () await engine . save_all ( books ) The definition of a reference field requires the presence of the Reference() descriptor. Once the models are defined, linking two instances is done simply by assigning the reference field of referencing instance to the referenced instance. Why is it required to include the Reference descriptor ? The main goal behind enforcing the presence of the descriptor is to have a clear distinction between Embedded Models and References. In the future, a generic Reference[T] type will probably be included to make this distinction since it would make more sense than having to set a descriptor for each reference. Content of the publisher collection after execution { \"_id\" : Objec t Id( \"5f7a0dc48a73b20f16e2a364\" ) , \"founded\" : 1826 , \"location\" : \"FR\" , \"name\" : \"Hachette Livre\" } { \"_id\" : Objec t Id( \"5f7a0dc48a73b20f16e2a365\" ) , \"founded\" : 1989 , \"location\" : \"US\" , \"name\" : \"HarperCollins\" } We can see that the publishers have been persisted to their collection even if no explicit save has been perfomed. When calling the engine.save method, the engine will persist automatically the referenced documents. While fetching instances, the engine will as well resolve every reference. Content of the book collection after execution { \"_id\" : Objec t Id( \"5f7a0dc48a73b20f16e2a366\" ) , \"pages\" : 304 , \"publisher\" : Objec t Id( \"5f7a0dc48a73b20f16e2a364\" ) , \"title\" : \"They Didn't See Us Coming\" } { \"_id\" : Objec t Id( \"5f7a0dc48a73b20f16e2a367\" ) , \"pages\" : 256 , \"publisher\" : Objec t Id( \"5f7a0dc48a73b20f16e2a364\" ) , \"title\" : \"This Isn't Happening\" } { \"_id\" : Objec t Id( \"5f7a0dc48a73b20f16e2a368\" ) , \"pages\" : 464 , \"publisher\" : Objec t Id( \"5f7a0dc48a73b20f16e2a365\" ) , \"title\" : \"Prodigal Summer\" } The resulting books in the collection contain the publisher reference directly as a document attribute (using the reference name as the document's key). Tip It's possible to customize the foreign key storage key using the key_name argument while building the Reference descriptor. Many to Many (Manual) \u00b6 Here, we will model the relation between books and their authors. Since a book can have multiple authors and an author can be authoring multiple books, we will model this relation as a many-to-many relationship. Note Currently, ODMantic does not support mapped multi-references yet. But we will still define the relationship in a manual way. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from typing import List from bson import ObjectId from odmantic import AIOEngine , Model class Author ( Model ): name : str class Book ( Model ): title : str pages : int author_ids : List [ ObjectId ] david = Author ( name = \"David Beazley\" ) brian = Author ( name = \"Brian K. Jones\" ) python_cookbook = Book ( title = \"Python Cookbook\" , pages = 706 , author_ids = [ david . id , brian . id ] ) python_essentials = Book ( title = \"Python Essential Reference\" , pages = 717 , author_ids = [ brian . id ] ) engine = AIOEngine () await engine . save_all (( david , brian )) await engine . save_all (( python_cookbook , python_essentials )) We defined an author_ids field which holds the list of unique ids of the authors (This id field in the Author model is generated implicitly by default). Since this multi-reference is not mapped by the ODM, we have to persist the authors manually. Content of the author collection after execution { \"_id\" : Objec t Id( \"5f7a37dc7311be1362e1da4e\" ) , \"name\" : \"David Beazley\" } { \"_id\" : Objec t Id( \"5f7a37dc7311be1362e1da4f\" ) , \"name\" : \"Brian K. Jones\" } Content of the book collection after execution { \"_id\" : Objec t Id( \"5f7a37dc7311be1362e1da50\" ) , \"title\" : \"Python Cookbook\" \"pages\" : 706 , \"author_ids\" :[ Objec t Id( \"5f7a37dc7311be1362e1da4e\" ) , Objec t Id( \"5f7a37dc7311be1362e1da4f\" ) ], } { \"_id\" : Objec t Id( \"5f7a37dc7311be1362e1da51\" ) , \"title\" : \"Python Essential Reference\" \"pages\" : 717 , \"author_ids\" :[ Objec t Id( \"5f7a37dc7311be1362e1da4f\" ) ], } Retrieving the authors of the Python Cookbook First, it's required to fetch the ids of the authors. Then we can use the in_ filter to select only the authors with the desired ids. 1 2 3 4 5 6 7 book = await engine . find_one ( Book , Book . title == \"Python Cookbook\" ) authors = await engine . find ( Author , Author . id . in_ ( book . author_ids )) print ( authors ) #> [ #> Author(id=ObjectId(\"5f7a37dc7311be1362e1da4e\"), name=\"David Beazley\"), #> Author(id=ObjectId(\"5f7a37dc7311be1362e1da4f\"), name=\"Brian K. Jones\"), #> ]","title":"Modeling"},{"location":"modeling/#modeling","text":"","title":"Modeling"},{"location":"modeling/#models","text":"To create a Model, simply inherit from the Model class and then specify the field types and eventually their descriptors.","title":"Models"},{"location":"modeling/#collection","text":"Each Model will be linked to its own collection. By default, the collection name will be created from the chosen class name and converted to snake_case . For example a model class named CapitalCity will be stored in the collection named capital_city . If the class name ends with Model , ODMantic will remove it to create the collection name. For example, a model class named PersonModel will belong in the person collection. It's possible to customize the collection name of a model by specifying the collection option in the Config class. Custom collection name example from odmantic import Model class CapitalCity ( Model ): name : str population : int class Config : collection = \"city\" Now, when CapitalCity instances will be persisted to the database, they will belong in the city collection instead of capital_city . Warning Models and Embedded models inheritance is not supported yet.","title":"Collection"},{"location":"modeling/#indexes","text":"","title":"Indexes"},{"location":"modeling/#index-definition","text":"There are two ways to create indexes on a model in ODMantic. The first one is to use the Field descriptors as explained in Indexed fields or Unique fields . However, this way doesn't allow a great flexibility on index definition. That's why you can also use the Config.indexes generator to specify advanced indexes (compound indexes, custom names). This static function defined in the Config class should yield odmantic.Index . For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import Field , Index , Model class Product ( Model ): name : str = Field ( index = True ) stock : int category : str sku : str = Field ( unique = True ) class Config : @staticmethod def indexes (): yield Index ( Product . name , Product . stock , name = \"name_stock_index\" ) yield Index ( Product . name , Product . category , unique = True ) This snippet creates 4 indexes on the Product model: An index on the name field defined with the field descriptor , improving lookup performance by product name. A unique index on the sku field defined with the field descriptor , enforcing uniqueness of the sku field. A compound index on the name and stock fields, making sure the following query will be efficient (i.e. avoid a full collection scan): engine . find ( Product , Product . name == \"banana\" , Product . stock > 5 ) A unique index on the name and category fields, making sure each category has unique product name. Sort orders with index definition You can also specify the sort order of the fields in the index definition using query.asc and query.desc as presented in the Sorting section. For example defining the following index on the Event model: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from datetime import datetime from odmantic import Index , Model from odmantic.query import asc , desc class Event ( Model ): username : str date : datetime class Config : @staticmethod def indexes (): yield Index ( asc ( Event . username ), desc ( Event . date )) Will greatly improve the performance of the query: engine . find ( Event , sort = ( asc ( Event . name ), desc ( Event . date ))","title":"Index definition"},{"location":"modeling/#index-creation","text":"In order to create and enable the indexes in the database, you need to call the engine.configure_database method (either AIOEngine.configure_database or SyncEngine.configure_database ). Async Sync 1 2 3 4 5 6 # ... Continuation of the previous snippet ... from odmantic import AIOEngine engine = AIOEngine () await engine . configure_database ([ Product ]) 1 2 3 4 5 6 # ... Continuation of the previous snippet ... from odmantic import SyncEngine engine = SyncEngine () engine . configure_database ([ Product ]) This method can also take a update_existing_indexes = True parameter to update existing indexes when the index definition changes. If not enabled, an exception will be thrown when a conflicting index update happens.","title":"Index creation"},{"location":"modeling/#advanced-indexes","text":"In some cases, you might need a greater flexibility on the index definition (Geo2D, Hashed, Text indexes for example), the Config.indexes generator can also yield pymongo.IndexModel objects. For example, defining a text index : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import pymongo from odmantic import Model class Post ( Model ): title : str content : str class Config : @staticmethod def indexes (): yield pymongo . IndexModel ( [( + Post . title , pymongo . TEXT ), ( + Post . content , pymongo . TEXT )] )","title":"Advanced indexes"},{"location":"modeling/#custom-model-validators","text":"Exactly as done with pydantic, it's possible to define custom model validators as described in the pydantic: Root Validators documentation (this apply as well to Embedded Models). In the following example, we will define a rectangle class and add two validators: The first one will check that the height is greater than the width. The second one will ensure that the area of the rectangle is less or equal to 9. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 from typing import ClassVar from pydantic import ValidationError , root_validator from odmantic import Model class SmallRectangle ( Model ): MAX_AREA : ClassVar [ float ] = 9 length : float width : float @root_validator def check_width_length ( cls , values ): length = values . get ( \"length\" , 0 ) width = values . get ( \"width\" , 0 ) if width > length : raise ValueError ( \"width can't be greater than length\" ) return values @root_validator def check_area ( cls , values ): length = values . get ( \"length\" , 0 ) width = values . get ( \"width\" , 0 ) if length * width > cls . MAX_AREA : raise ValueError ( f \"area is greater than { cls . MAX_AREA } \" ) return values print ( SmallRectangle ( length = 2 , width = 1 )) #> id=ObjectId('5f81e3c073103f509f97e374'), length=2.0, width=1.0 try : SmallRectangle ( length = 2 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle width field required (type=value_error.missing) \"\"\" try : SmallRectangle ( length = 2 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle __root__ width can't be greater than length (type=value_error) \"\"\" try : SmallRectangle ( length = 4 , width = 3 ) except ValidationError as e : print ( e ) \"\"\" 1 validation error for SmallRectangle __root__ area is greater than 9 (type=value_error) \"\"\" Tip You can define class variables in the Models using the typing.ClassVar type construct, as done in this example with MAX_AREA . Those class variables will be completely ignored by ODMantic while persisting instances to the database.","title":"Custom model validators"},{"location":"modeling/#advanced-configuration","text":"The model configuration is done in the same way as with Pydantic models: using a Config class defined in the model body. Available options : collection : str Customize the collection name associated to the model. See this section for more details about default collection naming. parse_doc_with_default_factories : bool Wether to allow populating field values with default factories while parsing documents from the database. See Advanced parsing behavior for more details. Default: False indexes : Callable [[], Iterable [ Union [ Index , pymongo . IndexModel ]]] Define additional indexes for the model. See Indexes for more details. Default: lambda : [] title : str (inherited from Pydantic) Title inferred in the JSON schema. Default: name of the model class schema_extra : dict (inherited from Pydantic) A dict used to extend/update the generated JSON Schema, or a callable to post-process it. See Pydantic: Schema customization for more details. Default: {} anystr_strip_whitespace : bool (inherited from Pydantic) Whether to strip leading and trailing whitespaces for str & byte types. Default: False json_encoders : dict (inherited from Pydantic) Customize the way types used in the model are encoded to JSON. json_encoders example For example, in order to serialize datetime fields as timestamp values: class Event ( Model ): date : datetime class Config : json_encoders = { datetime : lambda v : v . timestamp () } extra : pydantic . Extra (inherited from Pydantic) Whether to ignore, allow, or forbid extra attributes during model initialization. Accepts the string values of 'ignore', 'allow', or 'forbid', or values of the Extra enum. 'forbid' will cause validation to fail if extra attributes are included, 'ignore' will silently ignore any extra attributes, and 'allow' will assign the attributes to the model, reflecting them in the saved database documents and fetched instances. Default: Extra . ignore json_loads (inherited from Pydantic) Function used to decode JSON data Default: json . loads json_dumps (inherited from Pydantic) Function used to encode JSON data Default: json . dumps For more details and examples about the options inherited from Pydantic, you can have a look to Pydantic: Model Config Warning Only the options described above are supported and other options from Pydantic can't be used with ODMantic. If you feel the need to have an additional option inherited from Pydantic, you can open an issue .","title":"Advanced Configuration"},{"location":"modeling/#embedded-models","text":"Using an embedded model will store it directly in the root model it's integrated in. On the MongoDB side, the collection will contain the root documents and in inside each of them, the embedded models will be directly stored. Embedded models are especially useful while building one-to-one or one-to-many relationships. Note Since Embedded Models are directly embedded in the MongoDB collection of the root model, it will not be possible to query on them directly without specifying a root document. The creation of an Embedded model is done by inheriting the EmbeddedModel class. You can then define fields exactly as for the regular Models.","title":"Embedded Models"},{"location":"modeling/#one-to-one","text":"In this example, we will model the relation between a country and its capital city. Since one capital city can belong to one and only one country, we can model this relation as a One-to-One relationship. We will use an Embedded Model in this case. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from odmantic import AIOEngine , EmbeddedModel , Model class CapitalCity ( EmbeddedModel ): name : str population : int class Country ( Model ): name : str currency : str capital_city : CapitalCity countries = [ Country ( name = \"Switzerland\" , currency = \"Swiss franc\" , capital_city = CapitalCity ( name = \"Bern\" , population = 1035000 ), ), Country ( name = \"Sweden\" , currency = \"Swedish krona\" , capital_city = CapitalCity ( name = \"Stockholm\" , population = 975904 ), ), ] engine = AIOEngine () await engine . save_all ( countries ) Defining this relation is done in the same way as defining a new field. Here, the CapitalCity class will be considered as a field type during the model definition. The Field descriptor can be used as well for Embedded Models in order to bring more flexibility (default values, Mongo key name, ...). Content of the country collection after execution { \"_id\" : Objec t Id( \"5f79d7e8b305f24ca43593e2\" ) , \"name\" : \"Sweden\" , \"currency\" : \"Swedish krona\" , \"capital_city\" : { \"name\" : \"Stockholm\" , \"population\" : 975904 } } { \"_id\" : Objec t Id( \"5f79d7e8b305f24ca43593e1\" ) , \"name\" : \"Switzerland\" , \"currency\" : \"Swiss franc\" , \"capital_city\" : { \"name\" : \"Bern\" , \"population\" : 1035000 } } Tip It is possible as well to define query filters based on embedded documents content. await engine . find_one ( Country , Country . capital_city . name == \"Stockholm\" ) #> Country( #> id=ObjectId(\"5f79d7e8b305f24ca43593e2\"), #> name=\"Sweden\", #> currency=\"Swedish krona\", #> capital_city=CapitalCity(name=\"Stockholm\", population=975904), #> ) For more details, see the Querying section.","title":"One to One"},{"location":"modeling/#one-to-many","text":"Here, we will model the relation between a customer of an online shop and his shipping addresses. A single customer can have multiple addresses but these addresses belong only to the customer's account. He should be allowed to modify them without modifying others addresses (for example if two family members use the same address, their addresses should not be linked together). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from typing import List from odmantic import AIOEngine , EmbeddedModel , Model class Address ( EmbeddedModel ): street : str city : str state : str zipcode : str class Customer ( Model ): name : str addresses : List [ Address ] customer = Customer ( name = \"John Doe\" , addresses = [ Address ( street = \"1757 Birch Street\" , city = \"Greenwood\" , state = \"Indiana\" , zipcode = \"46142\" , ), Address ( street = \"262 Barnes Avenue\" , city = \"Cincinnati\" , state = \"Ohio\" , zipcode = \"45216\" , ), ], ) engine = AIOEngine () await engine . save ( customer ) As done previously for the One to One relation, defining a One to Many relationship with Embedded Models is done exactly as defining a field with its type being a sequence of Address objects. Content of the customer collection after execution { \"_id\" : Objec t Id( \"5f79eb116371e09b16e4fae4\" ) , \"name\" : \"John Doe\" , \"addresses\" :[ { \"street\" : \"1757 Birch Street\" , \"city\" : \"Greenwood\" , \"state\" : \"Indiana\" , \"zipcode\" : \"46142\" }, { \"street\" : \"262 Barnes Avenue\" , \"city\" : \"Cincinnati\" , \"state\" : \"Ohio\" , \"zipcode\" : \"45216\" } ] } Tip To add conditions on the number of embedded elements, it's possible to use the min_items and max_items arguments of the Field descriptor. Another possibility is to use the typing.Tuple type. Note Building query filters based on the content of a sequence of embedded documents is not supported yet (but this feature is planned for an upcoming release ). Anyway, it's still possible to perform the filtering operation manually using Mongo Array Operators ( $all , $elemMatch , $size ). See the Raw query usage section for more details.","title":"One to Many"},{"location":"modeling/#customization","text":"Since the Embedded Models are considered as types by ODMantic, most of the complex type constructs that could be imagined should be supported. Some ideas which could be useful: Combine two different embedded models in a single field using typing.Tuple . Allow multiple Embedded model types using a typing.Union type. Make an Embedded model not required using typing.Optional . Embed the documents in a dictionary (using the typing.Dict type) to provide an additional key-value mapping to the embedded documents. Nest embedded documents","title":"Customization"},{"location":"modeling/#referenced-models","text":"Embedded models are really simple to use but sometimes it is needed as well to have many-to-one (i.e. multiple entities referring to another single one) or many-to-many relationships. This is not really possible to model those using embedded documents and in this case, references will come handy. Another use case where references are useful is for one-to-one/one-to-many relations but when the referenced model has to exist in its own collection, in order to be accessed on its own without any parent model specified.","title":"Referenced models"},{"location":"modeling/#many-to-one-mapped","text":"In this part, we will model the relation between books and publishers. Let's consider that each book has a single publisher. In this case, multiple books could be published by the same publisher. We can thus model this relation as a many-to-one relationship. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from odmantic import AIOEngine , Model , Reference class Publisher ( Model ): name : str founded : int location : str class Book ( Model ): title : str pages : int publisher : Publisher = Reference () hachette = Publisher ( name = \"Hachette Livre\" , founded = 1826 , location = \"FR\" ) harper = Publisher ( name = \"HarperCollins\" , founded = 1989 , location = \"US\" ) books = [ Book ( title = \"They Didn't See Us Coming\" , pages = 304 , publisher = hachette ), Book ( title = \"This Isn't Happening\" , pages = 256 , publisher = hachette ), Book ( title = \"Prodigal Summer\" , pages = 464 , publisher = harper ), ] engine = AIOEngine () await engine . save_all ( books ) The definition of a reference field requires the presence of the Reference() descriptor. Once the models are defined, linking two instances is done simply by assigning the reference field of referencing instance to the referenced instance. Why is it required to include the Reference descriptor ? The main goal behind enforcing the presence of the descriptor is to have a clear distinction between Embedded Models and References. In the future, a generic Reference[T] type will probably be included to make this distinction since it would make more sense than having to set a descriptor for each reference. Content of the publisher collection after execution { \"_id\" : Objec t Id( \"5f7a0dc48a73b20f16e2a364\" ) , \"founded\" : 1826 , \"location\" : \"FR\" , \"name\" : \"Hachette Livre\" } { \"_id\" : Objec t Id( \"5f7a0dc48a73b20f16e2a365\" ) , \"founded\" : 1989 , \"location\" : \"US\" , \"name\" : \"HarperCollins\" } We can see that the publishers have been persisted to their collection even if no explicit save has been perfomed. When calling the engine.save method, the engine will persist automatically the referenced documents. While fetching instances, the engine will as well resolve every reference. Content of the book collection after execution { \"_id\" : Objec t Id( \"5f7a0dc48a73b20f16e2a366\" ) , \"pages\" : 304 , \"publisher\" : Objec t Id( \"5f7a0dc48a73b20f16e2a364\" ) , \"title\" : \"They Didn't See Us Coming\" } { \"_id\" : Objec t Id( \"5f7a0dc48a73b20f16e2a367\" ) , \"pages\" : 256 , \"publisher\" : Objec t Id( \"5f7a0dc48a73b20f16e2a364\" ) , \"title\" : \"This Isn't Happening\" } { \"_id\" : Objec t Id( \"5f7a0dc48a73b20f16e2a368\" ) , \"pages\" : 464 , \"publisher\" : Objec t Id( \"5f7a0dc48a73b20f16e2a365\" ) , \"title\" : \"Prodigal Summer\" } The resulting books in the collection contain the publisher reference directly as a document attribute (using the reference name as the document's key). Tip It's possible to customize the foreign key storage key using the key_name argument while building the Reference descriptor.","title":"Many to One (Mapped)"},{"location":"modeling/#many-to-many-manual","text":"Here, we will model the relation between books and their authors. Since a book can have multiple authors and an author can be authoring multiple books, we will model this relation as a many-to-many relationship. Note Currently, ODMantic does not support mapped multi-references yet. But we will still define the relationship in a manual way. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from typing import List from bson import ObjectId from odmantic import AIOEngine , Model class Author ( Model ): name : str class Book ( Model ): title : str pages : int author_ids : List [ ObjectId ] david = Author ( name = \"David Beazley\" ) brian = Author ( name = \"Brian K. Jones\" ) python_cookbook = Book ( title = \"Python Cookbook\" , pages = 706 , author_ids = [ david . id , brian . id ] ) python_essentials = Book ( title = \"Python Essential Reference\" , pages = 717 , author_ids = [ brian . id ] ) engine = AIOEngine () await engine . save_all (( david , brian )) await engine . save_all (( python_cookbook , python_essentials )) We defined an author_ids field which holds the list of unique ids of the authors (This id field in the Author model is generated implicitly by default). Since this multi-reference is not mapped by the ODM, we have to persist the authors manually. Content of the author collection after execution { \"_id\" : Objec t Id( \"5f7a37dc7311be1362e1da4e\" ) , \"name\" : \"David Beazley\" } { \"_id\" : Objec t Id( \"5f7a37dc7311be1362e1da4f\" ) , \"name\" : \"Brian K. Jones\" } Content of the book collection after execution { \"_id\" : Objec t Id( \"5f7a37dc7311be1362e1da50\" ) , \"title\" : \"Python Cookbook\" \"pages\" : 706 , \"author_ids\" :[ Objec t Id( \"5f7a37dc7311be1362e1da4e\" ) , Objec t Id( \"5f7a37dc7311be1362e1da4f\" ) ], } { \"_id\" : Objec t Id( \"5f7a37dc7311be1362e1da51\" ) , \"title\" : \"Python Essential Reference\" \"pages\" : 717 , \"author_ids\" :[ Objec t Id( \"5f7a37dc7311be1362e1da4f\" ) ], } Retrieving the authors of the Python Cookbook First, it's required to fetch the ids of the authors. Then we can use the in_ filter to select only the authors with the desired ids. 1 2 3 4 5 6 7 book = await engine . find_one ( Book , Book . title == \"Python Cookbook\" ) authors = await engine . find ( Author , Author . id . in_ ( book . author_ids )) print ( authors ) #> [ #> Author(id=ObjectId(\"5f7a37dc7311be1362e1da4e\"), name=\"David Beazley\"), #> Author(id=ObjectId(\"5f7a37dc7311be1362e1da4f\"), name=\"Brian K. Jones\"), #> ]","title":"Many to Many (Manual)"},{"location":"querying/","text":"Querying \u00b6 Filtering \u00b6 ODMantic uses QueryExpression objects to handle filter expressions. These expressions can be built from the comparison operators. It's then possible to combine multiple expressions using the logical operators. To support the wide variety of operators provided by MongoDB, it's possible as well to define the filter 'manually'. Comparison operators \u00b6 There are multiple ways of building QueryExpression objects with comparisons operators: Using python comparison operators between the field of the model and the desired value == , != , <= , < , >= , > Using the functions provided by the odmantic.query module query.eq query.ne query.gt query.gte query.lt query.lte query.in_ query.not_in Using methods of the model's field and the desired value field.eq field.ne field.gte field.gt field.lte field.lte field.in_ field.not_in Type checkers Since there is currently not any type checker plugin, the third usage might create some errors with type checkers. Equal \u00b6 Filter the trees named \"Spruce\": 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name == \"Spruce\" #> QueryExpression({'name': {'$eq': 'Spruce'}}) Tree . name . eq ( \"Spruce\" ) #> QueryExpression({'name': {'$eq': 'Spruce'}}) query . eq ( Tree . name , \"Spruce\" ) #> QueryExpression({'name': {'$eq': 'Spruce'}}) Equivalent raw MongoDB filter: { \"name\" : \"Spruce\" } Using equality operators with Enum fields Building filters using Enum fields is possible as well. Example of filter built on an Enum field Filter the 'small' trees: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from enum import Enum from odmantic import Model , query class TreeKind ( str , Enum ): BIG = \"big\" SMALL = \"small\" class Tree ( Model ): name : str average_size : float kind : TreeKind Tree . kind == TreeKind . SMALL #> QueryExpression({'kind': {'$eq': 'small'}}) Tree . kind . eq ( TreeKind . SMALL ) #> QueryExpression({'kind': {'$eq': 'small'}}) query . eq ( Tree . kind , TreeKind . SMALL ) #> QueryExpression({'kind': {'$eq': 'small'}}) Equivalent raw MongoDB filter: { 'ki n d' : 'small' } More details about Enum fields. Not Equal \u00b6 Filter the trees that are not named \"Spruce\": 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name != \"Spruce\" #> QueryExpression({'name': {'$ne': 'Spruce'}}) Tree . name . ne ( \"Spruce\" ) #> QueryExpression({'name': {'$ne': 'Spruce'}}) query . ne ( Tree . name , \"Spruce\" ) #> QueryExpression({'name': {'$ne': 'Spruce'}}) Equivalent raw MongoDB filter: { \"name\" : { \"$ne\" : \"Spruce\" }} Less than (or equal to) \u00b6 Filter the trees that have a size that is less than (or equal to) 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . average_size < 2 #> QueryExpression({'average_size': {'$lt': 2}}) Tree . average_size . lt ( 2 ) #> QueryExpression({'average_size': {'$lt': 2}}) query . lt ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$lt': 2}}) Tree . average_size <= 2 #> QueryExpression({'average_size': {'$lte': 2}}) Tree . average_size . lte ( 2 ) #> QueryExpression({'average_size': {'$lte': 2}}) query . lte ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$lte': 2}}) Equivalent raw MongoDB filter (less than): { \"average_size\" : { \"$lt\" : 2 }} Equivalent raw MongoDB filter (less than or equal to): { \"average_size\" : { \"$lte\" : 2 }} Greater than (or equal to) \u00b6 Filter the trees having a size that is greater than (or equal to) 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . average_size > 2 #> QueryExpression({'average_size': {'$gt': 2}}) Tree . average_size . gt ( 2 ) #> QueryExpression({'average_size': {'$gt': 2}}) query . gt ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$gt': 2}}) Tree . average_size >= 2 #> QueryExpression({'average_size': {'$gte': 2}}) Tree . average_size . gte ( 2 ) #> QueryExpression({'average_size': {'$gte': 2}}) query . gte ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$gte': 2}}) Equivalent raw MongoDB filter (greater than): { \"average_size\" : { \"$gt\" : 2 }} Equivalent raw MongoDB filter (greater than or equal to): { \"average_size\" : { \"$gte\" : 2 }} Included in \u00b6 Filter the trees named either \"Spruce\" or \"Pine\": 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name . in_ ([ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$in': ['Spruce', 'Pine']}}) query . in_ ( Tree . name , [ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$in': ['Spruce', 'Pine']}}) Equivalent raw MongoDB filter: { \"name\" : { \"$in\" : [ \"Spruce\" , \"Pine\" ]}} Not included in \u00b6 Filter the trees neither named \"Spruce\" nor \"Pine\": 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name . not_in ([ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) query . not_in ( Tree . name , [ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) Equivalent raw MongoDB filter: { \"name\" : { \"$nin\" : [ \"Spruce\" , \"Pine\" ]}} Evaluation operators \u00b6 Match (Regex) \u00b6 Filter the trees with a name starting with 'Spruce': 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Model , query class Tree ( Model ): name : str Tree . name . match ( r \"^Spruce\" ) #> QueryExpression({'name': re.compile('^Spruce')}) query . match ( Tree . name , r \"^Spruce\" ) #> QueryExpression({'name': re.compile('^Spruce')}) Equivalent raw MongoDB filter: { \"name\" : { \"$regex\" : \"^Spruce\" }} Logical operators \u00b6 There are two ways of combining QueryExpression objects with logical operators: Using python 'bitwise' operators between the field of the model and the desired value & , | Warning When using those operators make sure to correctly bracket the expressions to avoid python operator precedence issues. Using the functions provided by the odmantic.query module query.and_ query.or_ query.nor_ And \u00b6 Filter the trees named Spruce ( AND ) with a size less than 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import Model , query class Tree ( Model ): name : str size : float ( Tree . name == \"Spruce\" ) & ( Tree . size <= 2 ) #> QueryExpression( #> { #> \"$and\": ( #> QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}), #> QueryExpression({\"size\": {\"$lte\": 2}}), #> ) #> } #> ) query . and_ ( Tree . name == \"Spruce\" , Tree . size <= 2 ) #> ... same output ... Equivalent raw MongoDB filter: { \"name\" : \"Spruce\" , \"size\" : { \"$lte\" : 2 }}} Implicit AND When using find , find_one or count , you can specify multiple queries as positional arguments and those will be implicitly combined with the AND operator. Or \u00b6 Filter the trees named Spruce OR the trees with a size greater than 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import Model , query class Tree ( Model ): name : str size : float ( Tree . name == \"Spruce\" ) | ( Tree . size > 2 ) #> QueryExpression( #> { #> \"$or\": ( #> QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}), #> QueryExpression({\"size\": {\"$gt\": 2}}), #> ) #> } #> ) query . or_ ( Tree . name == \"Spruce\" , Tree . size > 2 ) #> ... same output ... Equivalent raw MongoDB filter: { \"$or\" :[ { \"name\" : \"Spruce\" }, { \"size\" :{ \"$gt\" : 2 }} ] } Nor \u00b6 Filter the trees neither named Spruce NOR bigger than 2 (size): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from odmantic import Model , query class Tree ( Model ): name : str size : float query . nor_ ( Tree . name == \"Spruce\" , Tree . size > 2 ) # > QueryExpression( # > { # > \"$nor\": ( # > QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}), # > QueryExpression({\"size\": {\"$gt\": 2}}), # > ) # > } # > ) Equivalent raw MongoDB filter: { \"$nor\" :[ { \"name\" : \"Spruce\" }, { \"size\" :{ \"$gt\" : 2 }} ] } NOR Equivalence The following logical expressions are equivalent: A NOR B NOR C NOT(A OR B OR C) NOT(A) AND NOT(B) AND NOT(C) query.nor_ operator naming query.and_ and query.or_ require to add an extra underscore to avoid overlapping with the python keywords. While it could've been possible to name the NOR operator query.nor, the extra underscore has been kept for consistency in the naming of the logical operators. Embedded documents filters \u00b6 It's possible to build filter based on the content of embedded documents: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from odmantic import AIOEngine , EmbeddedModel , Model class CapitalCity ( EmbeddedModel ): name : str population : int class Country ( Model ): name : str currency : str capital_city : CapitalCity Country . capital_city . name == \"Paris\" #> QueryExpression({'capital_city.name': {'$eq': 'Paris'}}) Country . capital_city . population > 10 ** 6 #> QueryExpression({'capital_city.population': {'$gt': 1000000}}) Equivalent raw MongoDB filters: { \"capital_city.name\" : { \"$eq\" : \"Paris\" }} { \"capital_city.population\" : { \"$gt\" : 1000000 }} Filtering across References Currently, it is not possible to build filter based on referenced objects. Raw MongoDB filters \u00b6 Any QueryExpression can be replaced with raw MongoDB filters. Thus, it's completely possible to use traditional filters with the find , find_one or count methods. You can find more details about building raw query filters using the Model in the Raw query usage section. Sorting \u00b6 ODMantic uses SortExpression objects to handle sort expressions. There are multiple ways of building SortExpression objects: Using implicit Model fields: Ascending sort To sort Publisher instances by ascending Publisher.founded : await engine . find ( Publisher , sort = Publisher . founded ) This example refers to the code showcased in the Overview . Using the functions provided by the odmantic.query module query.asc query.desc Using methods of the model's field and the desired value field.asc field.desc Type checkers Since there is currently not any type checker plugin, the third usage might create some errors with type checkers. Ascending \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from odmantic import AIOEngine , Model , query engine = AIOEngine () class Tree ( Model ): name : str average_size : float # The following queries are equivalent, # they will sort `Tree` by ascending `average_size` await engine . find ( Tree , sort = Tree . average_size ) await engine . find ( Tree , sort = Tree . average_size . asc ()) await engine . find ( Tree , sort = query . asc ( Tree . average_size )) Descending \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from odmantic import AIOEngine , Model , query engine = AIOEngine () class Tree ( Model ): name : str average_size : float # The following queries are equivalent, # they will sort `Tree` by descending `average_size` await engine . find ( Tree , sort = Tree . average_size . desc ()) await engine . find ( Tree , sort = query . desc ( Tree . average_size )) Sort on multiple fields \u00b6 We can pass a tuple to the sort kwarg, this will enable us to make a more complex sort query: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model , query engine = AIOEngine () class Tree ( Model ): name : str average_size : float # This query will first sort on ascending `average_size`, then # on descending `name` when `average_size` is the same await engine . find ( Tree , sort = ( Tree . average_size , Tree . name . desc ())) Embedded model field as a sort key \u00b6 We can sort instances based on the content of their embedded models. Sorting by an embedded model field We can sort the countries by descending order of the population of their capital city: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from odmantic import AIOEngine , EmbeddedModel , Model from odmantic.query import desc class CapitalCity ( EmbeddedModel ): name : str population : int class Country ( Model ): name : str currency : str capital_city : CapitalCity engine = AIOEngine () await engine . find ( Country , sort = desc ( Country . capital_city . population ))","title":"Querying"},{"location":"querying/#querying","text":"","title":"Querying"},{"location":"querying/#filtering","text":"ODMantic uses QueryExpression objects to handle filter expressions. These expressions can be built from the comparison operators. It's then possible to combine multiple expressions using the logical operators. To support the wide variety of operators provided by MongoDB, it's possible as well to define the filter 'manually'.","title":"Filtering"},{"location":"querying/#comparison-operators","text":"There are multiple ways of building QueryExpression objects with comparisons operators: Using python comparison operators between the field of the model and the desired value == , != , <= , < , >= , > Using the functions provided by the odmantic.query module query.eq query.ne query.gt query.gte query.lt query.lte query.in_ query.not_in Using methods of the model's field and the desired value field.eq field.ne field.gte field.gt field.lte field.lte field.in_ field.not_in Type checkers Since there is currently not any type checker plugin, the third usage might create some errors with type checkers.","title":"Comparison operators"},{"location":"querying/#equal","text":"Filter the trees named \"Spruce\": 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name == \"Spruce\" #> QueryExpression({'name': {'$eq': 'Spruce'}}) Tree . name . eq ( \"Spruce\" ) #> QueryExpression({'name': {'$eq': 'Spruce'}}) query . eq ( Tree . name , \"Spruce\" ) #> QueryExpression({'name': {'$eq': 'Spruce'}}) Equivalent raw MongoDB filter: { \"name\" : \"Spruce\" } Using equality operators with Enum fields Building filters using Enum fields is possible as well. Example of filter built on an Enum field Filter the 'small' trees: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from enum import Enum from odmantic import Model , query class TreeKind ( str , Enum ): BIG = \"big\" SMALL = \"small\" class Tree ( Model ): name : str average_size : float kind : TreeKind Tree . kind == TreeKind . SMALL #> QueryExpression({'kind': {'$eq': 'small'}}) Tree . kind . eq ( TreeKind . SMALL ) #> QueryExpression({'kind': {'$eq': 'small'}}) query . eq ( Tree . kind , TreeKind . SMALL ) #> QueryExpression({'kind': {'$eq': 'small'}}) Equivalent raw MongoDB filter: { 'ki n d' : 'small' } More details about Enum fields.","title":"Equal"},{"location":"querying/#not-equal","text":"Filter the trees that are not named \"Spruce\": 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name != \"Spruce\" #> QueryExpression({'name': {'$ne': 'Spruce'}}) Tree . name . ne ( \"Spruce\" ) #> QueryExpression({'name': {'$ne': 'Spruce'}}) query . ne ( Tree . name , \"Spruce\" ) #> QueryExpression({'name': {'$ne': 'Spruce'}}) Equivalent raw MongoDB filter: { \"name\" : { \"$ne\" : \"Spruce\" }}","title":"Not Equal"},{"location":"querying/#less-than-or-equal-to","text":"Filter the trees that have a size that is less than (or equal to) 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . average_size < 2 #> QueryExpression({'average_size': {'$lt': 2}}) Tree . average_size . lt ( 2 ) #> QueryExpression({'average_size': {'$lt': 2}}) query . lt ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$lt': 2}}) Tree . average_size <= 2 #> QueryExpression({'average_size': {'$lte': 2}}) Tree . average_size . lte ( 2 ) #> QueryExpression({'average_size': {'$lte': 2}}) query . lte ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$lte': 2}}) Equivalent raw MongoDB filter (less than): { \"average_size\" : { \"$lt\" : 2 }} Equivalent raw MongoDB filter (less than or equal to): { \"average_size\" : { \"$lte\" : 2 }}","title":"Less than (or equal to)"},{"location":"querying/#greater-than-or-equal-to","text":"Filter the trees having a size that is greater than (or equal to) 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . average_size > 2 #> QueryExpression({'average_size': {'$gt': 2}}) Tree . average_size . gt ( 2 ) #> QueryExpression({'average_size': {'$gt': 2}}) query . gt ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$gt': 2}}) Tree . average_size >= 2 #> QueryExpression({'average_size': {'$gte': 2}}) Tree . average_size . gte ( 2 ) #> QueryExpression({'average_size': {'$gte': 2}}) query . gte ( Tree . average_size , 2 ) #> QueryExpression({'average_size': {'$gte': 2}}) Equivalent raw MongoDB filter (greater than): { \"average_size\" : { \"$gt\" : 2 }} Equivalent raw MongoDB filter (greater than or equal to): { \"average_size\" : { \"$gte\" : 2 }}","title":"Greater than (or equal to)"},{"location":"querying/#included-in","text":"Filter the trees named either \"Spruce\" or \"Pine\": 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name . in_ ([ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$in': ['Spruce', 'Pine']}}) query . in_ ( Tree . name , [ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$in': ['Spruce', 'Pine']}}) Equivalent raw MongoDB filter: { \"name\" : { \"$in\" : [ \"Spruce\" , \"Pine\" ]}}","title":"Included in"},{"location":"querying/#not-included-in","text":"Filter the trees neither named \"Spruce\" nor \"Pine\": 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Model , query class Tree ( Model ): name : str average_size : float Tree . name . not_in ([ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) query . not_in ( Tree . name , [ \"Spruce\" , \"Pine\" ]) #> QueryExpression({'name': {'$nin': ['Spruce', 'Pine']}}) Equivalent raw MongoDB filter: { \"name\" : { \"$nin\" : [ \"Spruce\" , \"Pine\" ]}}","title":"Not included in"},{"location":"querying/#evaluation-operators","text":"","title":"Evaluation operators"},{"location":"querying/#match-regex","text":"Filter the trees with a name starting with 'Spruce': 1 2 3 4 5 6 7 8 9 10 11 from odmantic import Model , query class Tree ( Model ): name : str Tree . name . match ( r \"^Spruce\" ) #> QueryExpression({'name': re.compile('^Spruce')}) query . match ( Tree . name , r \"^Spruce\" ) #> QueryExpression({'name': re.compile('^Spruce')}) Equivalent raw MongoDB filter: { \"name\" : { \"$regex\" : \"^Spruce\" }}","title":"Match (Regex)"},{"location":"querying/#logical-operators","text":"There are two ways of combining QueryExpression objects with logical operators: Using python 'bitwise' operators between the field of the model and the desired value & , | Warning When using those operators make sure to correctly bracket the expressions to avoid python operator precedence issues. Using the functions provided by the odmantic.query module query.and_ query.or_ query.nor_","title":"Logical operators"},{"location":"querying/#and","text":"Filter the trees named Spruce ( AND ) with a size less than 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import Model , query class Tree ( Model ): name : str size : float ( Tree . name == \"Spruce\" ) & ( Tree . size <= 2 ) #> QueryExpression( #> { #> \"$and\": ( #> QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}), #> QueryExpression({\"size\": {\"$lte\": 2}}), #> ) #> } #> ) query . and_ ( Tree . name == \"Spruce\" , Tree . size <= 2 ) #> ... same output ... Equivalent raw MongoDB filter: { \"name\" : \"Spruce\" , \"size\" : { \"$lte\" : 2 }}} Implicit AND When using find , find_one or count , you can specify multiple queries as positional arguments and those will be implicitly combined with the AND operator.","title":"And"},{"location":"querying/#or","text":"Filter the trees named Spruce OR the trees with a size greater than 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from odmantic import Model , query class Tree ( Model ): name : str size : float ( Tree . name == \"Spruce\" ) | ( Tree . size > 2 ) #> QueryExpression( #> { #> \"$or\": ( #> QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}), #> QueryExpression({\"size\": {\"$gt\": 2}}), #> ) #> } #> ) query . or_ ( Tree . name == \"Spruce\" , Tree . size > 2 ) #> ... same output ... Equivalent raw MongoDB filter: { \"$or\" :[ { \"name\" : \"Spruce\" }, { \"size\" :{ \"$gt\" : 2 }} ] }","title":"Or"},{"location":"querying/#nor","text":"Filter the trees neither named Spruce NOR bigger than 2 (size): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from odmantic import Model , query class Tree ( Model ): name : str size : float query . nor_ ( Tree . name == \"Spruce\" , Tree . size > 2 ) # > QueryExpression( # > { # > \"$nor\": ( # > QueryExpression({\"name\": {\"$eq\": \"Spruce\"}}), # > QueryExpression({\"size\": {\"$gt\": 2}}), # > ) # > } # > ) Equivalent raw MongoDB filter: { \"$nor\" :[ { \"name\" : \"Spruce\" }, { \"size\" :{ \"$gt\" : 2 }} ] } NOR Equivalence The following logical expressions are equivalent: A NOR B NOR C NOT(A OR B OR C) NOT(A) AND NOT(B) AND NOT(C) query.nor_ operator naming query.and_ and query.or_ require to add an extra underscore to avoid overlapping with the python keywords. While it could've been possible to name the NOR operator query.nor, the extra underscore has been kept for consistency in the naming of the logical operators.","title":"Nor"},{"location":"querying/#embedded-documents-filters","text":"It's possible to build filter based on the content of embedded documents: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from odmantic import AIOEngine , EmbeddedModel , Model class CapitalCity ( EmbeddedModel ): name : str population : int class Country ( Model ): name : str currency : str capital_city : CapitalCity Country . capital_city . name == \"Paris\" #> QueryExpression({'capital_city.name': {'$eq': 'Paris'}}) Country . capital_city . population > 10 ** 6 #> QueryExpression({'capital_city.population': {'$gt': 1000000}}) Equivalent raw MongoDB filters: { \"capital_city.name\" : { \"$eq\" : \"Paris\" }} { \"capital_city.population\" : { \"$gt\" : 1000000 }} Filtering across References Currently, it is not possible to build filter based on referenced objects.","title":"Embedded documents filters"},{"location":"querying/#raw-mongodb-filters","text":"Any QueryExpression can be replaced with raw MongoDB filters. Thus, it's completely possible to use traditional filters with the find , find_one or count methods. You can find more details about building raw query filters using the Model in the Raw query usage section.","title":"Raw MongoDB filters"},{"location":"querying/#sorting","text":"ODMantic uses SortExpression objects to handle sort expressions. There are multiple ways of building SortExpression objects: Using implicit Model fields: Ascending sort To sort Publisher instances by ascending Publisher.founded : await engine . find ( Publisher , sort = Publisher . founded ) This example refers to the code showcased in the Overview . Using the functions provided by the odmantic.query module query.asc query.desc Using methods of the model's field and the desired value field.asc field.desc Type checkers Since there is currently not any type checker plugin, the third usage might create some errors with type checkers.","title":"Sorting"},{"location":"querying/#ascending","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from odmantic import AIOEngine , Model , query engine = AIOEngine () class Tree ( Model ): name : str average_size : float # The following queries are equivalent, # they will sort `Tree` by ascending `average_size` await engine . find ( Tree , sort = Tree . average_size ) await engine . find ( Tree , sort = Tree . average_size . asc ()) await engine . find ( Tree , sort = query . asc ( Tree . average_size ))","title":"Ascending"},{"location":"querying/#descending","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from odmantic import AIOEngine , Model , query engine = AIOEngine () class Tree ( Model ): name : str average_size : float # The following queries are equivalent, # they will sort `Tree` by descending `average_size` await engine . find ( Tree , sort = Tree . average_size . desc ()) await engine . find ( Tree , sort = query . desc ( Tree . average_size ))","title":"Descending"},{"location":"querying/#sort-on-multiple-fields","text":"We can pass a tuple to the sort kwarg, this will enable us to make a more complex sort query: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from odmantic import AIOEngine , Model , query engine = AIOEngine () class Tree ( Model ): name : str average_size : float # This query will first sort on ascending `average_size`, then # on descending `name` when `average_size` is the same await engine . find ( Tree , sort = ( Tree . average_size , Tree . name . desc ()))","title":"Sort on multiple fields"},{"location":"querying/#embedded-model-field-as-a-sort-key","text":"We can sort instances based on the content of their embedded models. Sorting by an embedded model field We can sort the countries by descending order of the population of their capital city: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from odmantic import AIOEngine , EmbeddedModel , Model from odmantic.query import desc class CapitalCity ( EmbeddedModel ): name : str population : int class Country ( Model ): name : str currency : str capital_city : CapitalCity engine = AIOEngine () await engine . find ( Country , sort = desc ( Country . capital_city . population ))","title":"Embedded model field as a sort key"},{"location":"raw_query_usage/","text":"Raw query usage \u00b6 As ODMantic doesn't completely wrap the MongoDB API, some helpers are provided to be enhance the usability while building raw queries and interacting with raw documents. Raw query helpers \u00b6 Collection name \u00b6 You can get the collection name associated to a model by using the unary + operator on the model class. 1 2 3 4 5 6 7 8 9 10 from odmantic import Model class User ( Model ): name : str collection_name = + User print ( collection_name ) #> user Motor collection \u00b6 The AIOEngine object can provide you directly the motor collection ( AsyncIOMotorCollection ) linked to the motor client used by the engine. To achieve this, you can use the AIOEngine.get_collection method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from odmantic import AIOEngine , Model class User ( Model ): name : str engine = AIOEngine () motor_collection = engine . get_collection ( User ) print ( motor_collection ) #> AsyncIOMotorCollection( #> Collection( #> Database( #> MongoClient( #> host=[\"localhost:27017\"], #> document_class=dict, #> tz_aware=False, #> connect=False, #> driver=DriverInfo(name=\"Motor\", version=\"2.2.0\", platform=\"asyncio\"), #> ), #> \"test\", #> ), #> \"user\", #> ) #> ) PyMongo collection \u00b6 The SyncEngine object can provide you directly the PyMongo collection ( pymongo.collection.Collection ) linked to the PyMongo client used by the engine. To achieve this, you can use the SyncEngine.get_collection method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from odmantic import SyncEngine , Model class User ( Model ): name : str engine = SyncEngine () collection = engine . get_collection ( User ) print ( collection ) #> Collection( #> Database( #> MongoClient( #> host=[\"localhost:27017\"], #> document_class=dict, #> tz_aware=False, #> connect=True, #> ), #> \"test\", #> ), #> \"user\", #> ) Key name of a field \u00b6 Since some field might have some customized key names , you can get the key name associated to a field by using the unary + operator on the model class. As well, to ease the use of aggregation pipelines where you might need to reference your field ( $field ), you can double the operator (i.e use ++ ) to get the field reference name. 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) print ( + User . name ) #> username print ( ++ User . name ) #> $username Using raw MongoDB filters \u00b6 Any QueryExpression can be replaced by its raw filter equivalent. For example, with a Tree model: 1 2 3 4 5 6 7 8 9 from odmantic import AIOEngine , Model class Tree ( Model ): name : str average_size : float engine = AIOEngine () All the following find queries would give exactly the same results: engine . find ( Tree , Tree . average_size > 2 ) engine . find ( Tree , { + Tree . average_size : { \"$gt\" : 2 }}) engine . find ( Tree , { \"average_size\" : { \"$gt\" : 2 }}) Raw MongoDB documents \u00b6 Parsing documents \u00b6 You can parse MongoDB document to instances using the parse_doc method. Tip If the provided documents contain extra fields, ODMantic will ignore them. This can be especially useful in aggregation pipelines. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from bson import ObjectId from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) document = { \"username\" : \"John\" , \"_id\" : ObjectId ( \"5f8352a87a733b8b18b0cb27\" )} user = User . parse_doc ( document ) print ( repr ( user )) #> User(id=ObjectId('5f8352a87a733b8b18b0cb27'), name='John') Dumping documents \u00b6 You can generate a document from instances using the doc method. 1 2 3 4 5 6 7 8 9 10 from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) user = User ( name = \"John\" ) print ( user . doc ()) #> {'username': 'John', '_id': ObjectId('5f8352a87a733b8b18b0cb27')} Advanced parsing behavior \u00b6 Default values \u00b6 While parsing documents, ODMantic will use the default values provided in the Models to populate the missing fields from the documents: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from bson import ObjectId from odmantic import Model class Player ( Model ): name : str level : int = 1 document = { \"name\" : \"Leeroy\" , \"_id\" : ObjectId ( \"5f8352a87a733b8b18b0cb27\" )} user = Player . parse_doc ( document ) print ( repr ( user )) #> Player( #> id=ObjectId(\"5f8352a87a733b8b18b0cb27\"), #> name=\"Leeroy\", #> level=1, #> ) Default factories \u00b6 For the field with default factories provided through the Field descriptor though, by default they wont be populated. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from datetime import datetime from bson import ObjectId from odmantic import Model from odmantic.exceptions import DocumentParsingError from odmantic.field import Field class User ( Model ): name : str created_at : datetime = Field ( default_factory = datetime . utcnow ) document = { \"name\" : \"Leeroy\" , \"_id\" : ObjectId ( \"5f8352a87a733b8b18b0cb27\" )} try : User . parse_doc ( document ) except DocumentParsingError as e : print ( e ) #> 1 validation error for User #> created_at #> key not found in document (type=value_error.keynotfoundindocument; key_name='created_at') #> (User instance details: id=ObjectId('5f8352a87a733b8b18b0cb27')) In the previous example, using the default factories could create data inconsistencies and in this case, it would probably be more suitable to perform a manual migration to provide the correct values. Still, the parse_doc_with_default_factories Config option can be used to allow the use of the default factories while parsing documents: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from datetime import datetime from bson import ObjectId from odmantic import Model from odmantic.exceptions import DocumentParsingError from odmantic.field import Field class User ( Model ): name : str updated_at : datetime = Field ( default_factory = datetime . utcnow ) class Config : parse_doc_with_default_factories = True document = { \"name\" : \"Leeroy\" , \"_id\" : ObjectId ( \"5f8352a87a733b8b18b0cb27\" )} user = User . parse_doc ( document ) print ( repr ( user )) #> User( #> id=ObjectId(\"5f8352a87a733b8b18b0cb27\"), #> name=\"Leeroy\", #> updated_at=datetime.datetime(2020, 11, 8, 23, 28, 19, 980000), #> ) Aggregation example \u00b6 In the following example, we will demonstrate the use of the previous helpers to build an aggregation pipeline. We will first consider a Rectangle model with two float fields ( height and length ). We will then fetch the rectangles with an area that is less than 10. To finish, we will reconstruct Rectangle instances from this query. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 from odmantic import AIOEngine , Model class Rectangle ( Model ): length : float width : float rectangles = [ Rectangle ( length = 0.1 , width = 1 ), Rectangle ( length = 3.5 , width = 1 ), Rectangle ( length = 2.87 , width = 5.19 ), Rectangle ( length = 1 , width = 10 ), Rectangle ( length = 0.1 , width = 100 ), ] engine = AIOEngine () await engine . save_all ( rectangles ) collection = engine . get_collection ( Rectangle ) pipeline = [] # Add an area field pipeline . append ( { \"$addFields\" : { \"area\" : { \"$multiply\" : [ ++ Rectangle . length , ++ Rectangle . width ] } # Compute the area remotely } } ) # Filter only rectanges with an area lower than 10 pipeline . append ({ \"$match\" : { \"area\" : { \"$lt\" : 10 }}}) # Project to keep only the defined fields (this step is optional) pipeline . append ( { \"$project\" : { + Rectangle . length : True , + Rectangle . width : True , } # Specifying \"area\": False is unnecessary here } ) documents = await collection . aggregate ( pipeline ) . to_list ( length = None ) small_rectangles = [ Rectangle . parse_doc ( doc ) for doc in documents ] print ( small_rectangles ) #> [ #> Rectangle(id=ObjectId(\"...\"), length=0.1, width=1.0), #> Rectangle(id=ObjectId(\"...\"), length=3.5, width=1.0), #> ]","title":"Raw query usage"},{"location":"raw_query_usage/#raw-query-usage","text":"As ODMantic doesn't completely wrap the MongoDB API, some helpers are provided to be enhance the usability while building raw queries and interacting with raw documents.","title":"Raw query usage"},{"location":"raw_query_usage/#raw-query-helpers","text":"","title":"Raw query helpers"},{"location":"raw_query_usage/#collection-name","text":"You can get the collection name associated to a model by using the unary + operator on the model class. 1 2 3 4 5 6 7 8 9 10 from odmantic import Model class User ( Model ): name : str collection_name = + User print ( collection_name ) #> user","title":"Collection name"},{"location":"raw_query_usage/#motor-collection","text":"The AIOEngine object can provide you directly the motor collection ( AsyncIOMotorCollection ) linked to the motor client used by the engine. To achieve this, you can use the AIOEngine.get_collection method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from odmantic import AIOEngine , Model class User ( Model ): name : str engine = AIOEngine () motor_collection = engine . get_collection ( User ) print ( motor_collection ) #> AsyncIOMotorCollection( #> Collection( #> Database( #> MongoClient( #> host=[\"localhost:27017\"], #> document_class=dict, #> tz_aware=False, #> connect=False, #> driver=DriverInfo(name=\"Motor\", version=\"2.2.0\", platform=\"asyncio\"), #> ), #> \"test\", #> ), #> \"user\", #> ) #> )","title":"Motor collection"},{"location":"raw_query_usage/#pymongo-collection","text":"The SyncEngine object can provide you directly the PyMongo collection ( pymongo.collection.Collection ) linked to the PyMongo client used by the engine. To achieve this, you can use the SyncEngine.get_collection method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from odmantic import SyncEngine , Model class User ( Model ): name : str engine = SyncEngine () collection = engine . get_collection ( User ) print ( collection ) #> Collection( #> Database( #> MongoClient( #> host=[\"localhost:27017\"], #> document_class=dict, #> tz_aware=False, #> connect=True, #> ), #> \"test\", #> ), #> \"user\", #> )","title":"PyMongo collection"},{"location":"raw_query_usage/#key-name-of-a-field","text":"Since some field might have some customized key names , you can get the key name associated to a field by using the unary + operator on the model class. As well, to ease the use of aggregation pipelines where you might need to reference your field ( $field ), you can double the operator (i.e use ++ ) to get the field reference name. 1 2 3 4 5 6 7 8 9 10 11 12 from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) print ( + User . name ) #> username print ( ++ User . name ) #> $username","title":"Key name of a field"},{"location":"raw_query_usage/#using-raw-mongodb-filters","text":"Any QueryExpression can be replaced by its raw filter equivalent. For example, with a Tree model: 1 2 3 4 5 6 7 8 9 from odmantic import AIOEngine , Model class Tree ( Model ): name : str average_size : float engine = AIOEngine () All the following find queries would give exactly the same results: engine . find ( Tree , Tree . average_size > 2 ) engine . find ( Tree , { + Tree . average_size : { \"$gt\" : 2 }}) engine . find ( Tree , { \"average_size\" : { \"$gt\" : 2 }})","title":"Using raw MongoDB filters"},{"location":"raw_query_usage/#raw-mongodb-documents","text":"","title":"Raw MongoDB documents"},{"location":"raw_query_usage/#parsing-documents","text":"You can parse MongoDB document to instances using the parse_doc method. Tip If the provided documents contain extra fields, ODMantic will ignore them. This can be especially useful in aggregation pipelines. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from bson import ObjectId from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) document = { \"username\" : \"John\" , \"_id\" : ObjectId ( \"5f8352a87a733b8b18b0cb27\" )} user = User . parse_doc ( document ) print ( repr ( user )) #> User(id=ObjectId('5f8352a87a733b8b18b0cb27'), name='John')","title":"Parsing documents"},{"location":"raw_query_usage/#dumping-documents","text":"You can generate a document from instances using the doc method. 1 2 3 4 5 6 7 8 9 10 from odmantic import Field , Model class User ( Model ): name : str = Field ( key_name = \"username\" ) user = User ( name = \"John\" ) print ( user . doc ()) #> {'username': 'John', '_id': ObjectId('5f8352a87a733b8b18b0cb27')}","title":"Dumping documents"},{"location":"raw_query_usage/#advanced-parsing-behavior","text":"","title":"Advanced parsing behavior"},{"location":"raw_query_usage/#default-values","text":"While parsing documents, ODMantic will use the default values provided in the Models to populate the missing fields from the documents: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from bson import ObjectId from odmantic import Model class Player ( Model ): name : str level : int = 1 document = { \"name\" : \"Leeroy\" , \"_id\" : ObjectId ( \"5f8352a87a733b8b18b0cb27\" )} user = Player . parse_doc ( document ) print ( repr ( user )) #> Player( #> id=ObjectId(\"5f8352a87a733b8b18b0cb27\"), #> name=\"Leeroy\", #> level=1, #> )","title":"Default values"},{"location":"raw_query_usage/#default-factories","text":"For the field with default factories provided through the Field descriptor though, by default they wont be populated. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from datetime import datetime from bson import ObjectId from odmantic import Model from odmantic.exceptions import DocumentParsingError from odmantic.field import Field class User ( Model ): name : str created_at : datetime = Field ( default_factory = datetime . utcnow ) document = { \"name\" : \"Leeroy\" , \"_id\" : ObjectId ( \"5f8352a87a733b8b18b0cb27\" )} try : User . parse_doc ( document ) except DocumentParsingError as e : print ( e ) #> 1 validation error for User #> created_at #> key not found in document (type=value_error.keynotfoundindocument; key_name='created_at') #> (User instance details: id=ObjectId('5f8352a87a733b8b18b0cb27')) In the previous example, using the default factories could create data inconsistencies and in this case, it would probably be more suitable to perform a manual migration to provide the correct values. Still, the parse_doc_with_default_factories Config option can be used to allow the use of the default factories while parsing documents: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from datetime import datetime from bson import ObjectId from odmantic import Model from odmantic.exceptions import DocumentParsingError from odmantic.field import Field class User ( Model ): name : str updated_at : datetime = Field ( default_factory = datetime . utcnow ) class Config : parse_doc_with_default_factories = True document = { \"name\" : \"Leeroy\" , \"_id\" : ObjectId ( \"5f8352a87a733b8b18b0cb27\" )} user = User . parse_doc ( document ) print ( repr ( user )) #> User( #> id=ObjectId(\"5f8352a87a733b8b18b0cb27\"), #> name=\"Leeroy\", #> updated_at=datetime.datetime(2020, 11, 8, 23, 28, 19, 980000), #> )","title":"Default factories"},{"location":"raw_query_usage/#aggregation-example","text":"In the following example, we will demonstrate the use of the previous helpers to build an aggregation pipeline. We will first consider a Rectangle model with two float fields ( height and length ). We will then fetch the rectangles with an area that is less than 10. To finish, we will reconstruct Rectangle instances from this query. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 from odmantic import AIOEngine , Model class Rectangle ( Model ): length : float width : float rectangles = [ Rectangle ( length = 0.1 , width = 1 ), Rectangle ( length = 3.5 , width = 1 ), Rectangle ( length = 2.87 , width = 5.19 ), Rectangle ( length = 1 , width = 10 ), Rectangle ( length = 0.1 , width = 100 ), ] engine = AIOEngine () await engine . save_all ( rectangles ) collection = engine . get_collection ( Rectangle ) pipeline = [] # Add an area field pipeline . append ( { \"$addFields\" : { \"area\" : { \"$multiply\" : [ ++ Rectangle . length , ++ Rectangle . width ] } # Compute the area remotely } } ) # Filter only rectanges with an area lower than 10 pipeline . append ({ \"$match\" : { \"area\" : { \"$lt\" : 10 }}}) # Project to keep only the defined fields (this step is optional) pipeline . append ( { \"$project\" : { + Rectangle . length : True , + Rectangle . width : True , } # Specifying \"area\": False is unnecessary here } ) documents = await collection . aggregate ( pipeline ) . to_list ( length = None ) small_rectangles = [ Rectangle . parse_doc ( doc ) for doc in documents ] print ( small_rectangles ) #> [ #> Rectangle(id=ObjectId(\"...\"), length=0.1, width=1.0), #> Rectangle(id=ObjectId(\"...\"), length=3.5, width=1.0), #> ]","title":"Aggregation example"},{"location":"usage_fastapi/","text":"Usage with FastAPI \u00b6 Example \u00b6 In this example, we create a minimalist REST API describing trees by their name, average size and discovery year. Requirements To run the following example, you'll need to install FastAPI and Uvicorn. pip install fastapi uvicorn 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from typing import List from fastapi import FastAPI , HTTPException from odmantic import AIOEngine , Model , ObjectId class Tree ( Model ): name : str average_size : float discovery_year : int app = FastAPI () engine = AIOEngine () @app . put ( \"/trees/\" , response_model = Tree ) async def create_tree ( tree : Tree ): await engine . save ( tree ) return tree @app . get ( \"/trees/\" , response_model = List [ Tree ]) async def get_trees (): trees = await engine . find ( Tree ) return trees @app . get ( \"/trees/count\" , response_model = int ) async def count_trees (): count = await engine . count ( Tree ) return count @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree You can then start the application. For example if you saved the file above in a file named tree_api.py : uvicorn tree_api : app Uvicorn should start serving the API locally: INFO: Started server process [21429] INFO: Waiting for application startup. INFO: Application startup complete. INFO: Uvicorn running on http://localhost:8080 (Press CTRL+C to quit) To try it out, you can simply access the interactive documentation generated by FastAPI at http://localhost:8080/docs . We'll now dive in the details of this example. Defining the model \u00b6 First, we create our Tree model. class Tree ( Model ): name : str average_size : float discovery_year : int This describes our Tree instances structure both for JSON serialization and for the storage in the MongoDB collection. Building the engine \u00b6 After having defined the model, we create the AIOEngine object. This object will be responsible for performing database operations. engine = AIOEngine () It's possible as well to build the engine with custom parameters (mongo URI, database name). See this section for more details. Running the python file directly If you need to execute the python file directly with the interpreter (to use a debugger for example), some extra steps will be required. Run uvicorn using the default event loop (if the file is called directly): if __name__ == \"__main__\" : import asyncio import uvicorn loop = asyncio . get_event_loop () config = uvicorn . Config ( app = app , port = 8080 , loop = loop ) server = uvicorn . Server ( config ) loop . run_until_complete ( server . serve ()) uvicorn.run behavior with event loops (Advanced) The usual entrypoint uvicorn.run(app) for ASGI apps doesn't work because when called uvicorn will create and run a brand new event loop. Thus, the engine object will be bound to a different event loop that will not be running. In this case, you'll witness <Future pending> attached to a different loop errors because the app itself will be running in a different event loop than the engine's driver. Anyway, when running directly the app through the uvicorn CLI, the default event loop will be the one that will be running later, so no modifications are required. AIOEngineDependency deprecation (from v0.2.0) The AIOEngineDependency that was used to inject the engine in the API routes is now deprecated (it will be kept for few versions though). Using a global engine object should be preferred as it will dramatically reduce the required verbosity to use the engine in an endpoint. If you need to run your app directly from a python file, see the above Running the python file directly section. Creating a tree \u00b6 The next step is to define a route enabling us to create a new tree. To that end, we create a PUT route with the path /trees/ . This endpoint will receive a tree, persist it to the database and return the created object. @app . put ( \"/trees/\" , response_model = Tree ) async def create_tree ( tree : Tree ): await engine . save ( tree ) return tree First, the request body will be parsed to a Tree object (this is done by specifying the argument tree: Tree ). This mean that the model validation will be performed. Once the model is parsed to a Tree instance, we persist it to the database and we return it. Command line tool for interacting with JSON based HTTP APIs To interact with the API from the command line, we recommend to use the HTTPie CLI. The next examples are still provided with the curl syntax since the Swagger documentation generated by FastAPI will give you curl examples directly. Creating a Tree from the command line HTTPie curl Send the request: http PUT localhost:8080/trees/ name = \"Spruce\" discovery_year = 1995 average_size = 2 Output: HTTP/1.1 200 OK content-length: 90 content-type: application/json date: Sun, 18 Oct 2020 18:40:30 GMT server: uvicorn { \"average_size\": 2.0, \"discovery_year\": 1995, \"id\": \"5f8c8c1ff1d33aa1012f3086\", \"name\": \"Spruce\" } Send the request: curl -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Spruce\", \"discovery_year\":1995, \"average_size\":2}' Output: {\"name\":\"Spruce\",\"average_size\":2.0,\"discovery_year\":1995,\"id\":\"5f8c8c1ff1d33aa1012f3086\"} You can notice that the id field has been added automatically by ODMantic. This id field is actually not required since it's defined automatically by ODMantic with a default factory method ( more details ). You can still specify this field in the request body to predefine the id of the created instance or to overwrite an existing instance. Why PUT instead of POST ? Since the engine.save behave as an upsert operation ( more details ), you can overwrite instances stored in the database by creating a new instance with the same id and calling the engine.save method. Modifying the Tree from the command line To overwrite the tree with id=5f8c8c1ff1d33aa1012f3086 : HTTPie curl Send the request: http PUT localhost:8080/trees/ \\ name = \"Norway Spruce\" discovery_year = 1795 \\ average_size = 200 id = \"5f8c8c1ff1d33aa1012f3086\" Output: HTTP/1.1 200 OK content-length: 90 content-type: application/json date: Sun, 18 Oct 2020 18:40:30 GMT server: uvicorn { \"average_size\": 200.0, \"discovery_year\": 1795, \"id\": \"5f8c8c1ff1d33aa1012f3086\", \"name\": \"Norway Spruce\" } Send the request: curl -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Norway Spruce\", \"discovery_year\":1795, \"average_size\":200, \"id\":\"5f8c8c1ff1d33aa1012f3086\"}' Output: {\"name\":\"Norway Spruce\",\"average_size\":200.0,\"discovery_year\":1795,\"id\":\"5f8c8c1ff1d33aa1012f3086\"} Since we can modify an existing instance, it makes more sense to define the operation as a PUT instead of a POST that should create a new resource on each call. If the request body doesn't match our model schema, a 422 Unprocessable Entity error will be returned by the API, containing the details about the error. Invalid data while creating the Tree from the command line You can try by omitting the average_size field: HTTPie curl Send the request: http PUT localhost:8080/trees/ name = \"Spruce\" discovery_year = 1995 Output: HTTP/1.1 422 Unprocessable Entity content-length: 96 content-type: application/json date: Sun, 18 Oct 2020 16:42:18 GMT server: uvicorn { \"detail\": [ { \"loc\": [ \"body\", \"average_size\" ], \"msg\": \"field required\", \"type\": \"value_error.missing\" } ] } Send the request: curl -v -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Spruce\", \"discovery_year\":1995}' Output: * Trying 127.0.0.1... * TCP_NODELAY set * Connected to localhost (127.0.0.1) port 8080 (#0) > PUT /trees/ HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.58.0 > Accept: */* > Content-Type: application/json > Content-Length: 40 > * upload completely sent off: 40 out of 40 bytes < HTTP/1.1 422 Unprocessable Entity < date: Sun, 18 Oct 2020 18:51:33 GMT < server: uvicorn < content-length: 96 < content-type: application/json < * Connection #0 to host localhost left intact {\"detail\":[{\"loc\":[\"body\",\"average_size\"],\"msg\":\"field required\",\"type\":\"value_error.missing\"}]}% The validation error structure is the one that is defined by the Pydantic: ValidationError exception. Finally, specifying the response_model in the app.put decorator is not mandatory but it is strongly advised as it helps FastAPI to generate the documentation. Getting all the trees \u00b6 To get the trees stored in the database, we use the AIOEngine.find method in its awaitable form ( more details ), this gives us directly the list of Tree instances that we can return directly: @app . get ( \"/trees/\" , response_model = List [ Tree ]) async def get_trees (): trees = await engine . find ( Tree ) return trees Creating and getting the trees from the command line HTTPie curl Create some trees: http PUT localhost:8080/trees/ name = \"Spruce\" discovery_year = 1995 average_size = 10 .2 http PUT localhost:8080/trees/ name = \"Pine\" discovery_year = 1850 average_size = 5 Get the trees: http localhost:8080/trees/ Output: HTTP/1.1 200 OK content-length: 270 content-type: application/json date: Sun, 18 Oct 2020 17:59:10 GMT server: uvicorn [ { \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\", \"name\": \"Spruce\" }, { \"average_size\": 5.0, \"discovery_year\": 1850, \"id\": \"5f8c8266f1d33aa1012f3083\", \"name\": \"Pine\" } ] Create some trees: curl -v -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Spruce\", \"discovery_year\":1995, \"average_size\":10.2}' curl -v -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Pine\", \"discovery_year\":1850, \"average_size\":5}' Get the trees: curl http://localhost:8080/trees/ | python -mjson.tool Output: [ { \"name\": \"Spruce\", \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\" }, { \"name\": \"Pine\", \"average_size\": 5.0, \"discovery_year\": 1850, \"id\": \"5f8c8266f1d33aa1012f3083\" } ] Pagination You can add pagination to this GET request by using the skip and limit arguments while calling the AIOEngine.find method. Counting the trees \u00b6 To get the number of trees stored in the database, we use the AIOEngine.count method without specifying any query parameters (to directly get the total count of instances). @app . get ( \"/trees/count\" , response_model = int ) async def count_trees (): count = await engine . count ( Tree ) return count Getting the tree count from the command line HTTPie curl Get the count: http localhost:8080/trees/count Output: HTTP/1.1 200 OK content-length: 1 content-type: application/json date: Sun, 18 Oct 2020 20:16:50 GMT server: uvicorn 2 Get the count: curl http://localhost:8080/trees/count Output: 2 Getting a tree by id \u00b6 @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId , ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree To return a tree from its id we add a path parameter id: ObjectId . Once this endpoint is called, FastAPI will try to validate this query parameter, thus inferring an ObjectId object. Using BSON objects as parameters While you can define ODMantic models directly using bson fields ( more details ), it's not possible to use those types directly with FastAPI, you'll need to get the equivalent objects from the odmantic.bson module. Those equivalent types implement the additional validation logic enabling FastAPI to work with them. from odmantic.bson import ObjectId For convenience reasons, the ObjectId type including the validation logic is as well available directly from the odmantic module. from odmantic import ObjectId With this ObjectId , we build a query that will filter only the instances having this exactly same id : Tree . id == id Then, we pass this query to the AIOEngine.find_one method that will try to return an instance, otherwise None will be returned: tree = await engine . find_one ( Tree , Tree . id == id ) Now, if our tree object is None (i.e the instance has not been found), we need to return a 404 Not Found error: if tree is None : raise HTTPException ( 404 ) Otherwise, we found the requested instance. We can return it ! return tree Getting a tree from the command line HTTPie curl Get the tree 5f8c8266f1d33aa1012f3082 : http localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: HTTP/1.1 200 OK content-length: 91 content-type: application/json date: Sun, 18 Oct 2020 21:08:07 GMT server: uvicorn { \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\", \"name\": \"Spruce\" } Get the tree 5f8c8266f1d33aa1012f3082 : curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: {\"name\":\"Spruce\",\"average_size\":10.2,\"discovery_year\":1995,\"id\":\"5f8c8266f1d33aa1012f3082\"} Trying to get a tree not in the database from the command line HTTPie curl Try to get the tree f0f0f0f0f0f0f0f0f0f0f0f0 (it has not been created): http localhost:8080/trees/f0f0f0f0f0f0f0f0f0f0f0f0 Output: HTTP/1.1 404 Not Found content-length: 22 content-type: application/json date: Sun, 18 Oct 2020 21:11:48 GMT server: uvicorn { \"detail\": \"Not Found\" } Try to get the tree f0f0f0f0f0f0f0f0f0f0f0f0 (it has not been created): curl http://localhost:8080/trees/f0f0f0f0f0f0f0f0f0f0f0f0 Output: {\"detail\":\"Not Found\"} This id path parameter should be a 16 characters hexadecimal string (see MongoDB: ObjectId for more details). If the id specified in the path does not match this criteria, a 422 Unprocessable Entity error will be returned: Trying to get a tree with an invalid id from the command line HTTPie curl Get the tree identified by invalid_object_id : http localhost:8080/trees/invalid_object_id Output: HTTP/1.1 422 Unprocessable Entity content-length: 89 content-type: application/json date: Sun, 18 Oct 2020 20:50:25 GMT server: uvicorn { \"detail\": [ { \"loc\": [ \"path\", \"id\" ], \"msg\": \"invalid ObjectId specified\", \"type\": \"type_error\" } ] } Get the tree identified by invalid_object_id : curl http://localhost:8080/trees/invalid_object_id Output: {\"detail\":[{\"loc\":[\"path\",\"id\"],\"msg\":\"invalid ObjectId specified\",\"type\":\"type_error\"}]} Extending the example \u00b6 Deleting a tree \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import uvicorn from fastapi import FastAPI , HTTPException from odmantic import AIOEngine , Model , ObjectId class Tree ( Model ): name : str average_size : float discovery_year : int app = FastAPI () engine = AIOEngine () @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree @app . delete ( \"/trees/ {id} \" , response_model = Tree ) async def delete_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) await engine . delete ( tree ) return tree This new DELETE route is strongly inspired from the one used to get a tree from its id . Currently, ODMantic can only delete an instance and it's not possible to perform a delete operation from a query filter. Thus, we first need to get the associated instance. Once we have the instance, we call the AIOEngine.delete method to perform the deletion. Deleting a tree from the command line HTTPie curl Delete the tree identified by 5f8c8266f1d33aa1012f3082 : http DELETE localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: HTTP/1.1 200 OK content-length: 91 content-type: application/json date: Sun, 18 Oct 2020 21:35:22 GMT server: uvicorn { \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\", \"name\": \"Spruce\" } Check that the tree is not stored anymore: http localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: HTTP/1.1 404 Not Found content-length: 22 content-type: application/json date: Sun, 18 Oct 2020 21:36:45 GMT server: uvicorn { \"detail\": \"Not Found\" } Delete the tree identified by 5f8c8266f1d33aa1012f3082 : curl -X DELETE http://localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: {\"name\":\"Spruce\",\"average_size\":10.2,\"discovery_year\":1995,\"id\":\"5f8c8266f1d33aa1012f3082\"} Check that the tree is not stored anymore: curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: {\"detail\":\"Not Found\"} The tree has been removed successfully ! Updating a tree \u00b6 We already defined a PUT route that enables us to modify (replace) a tree instance. However, with this previous implementation, it's not possible to specify only the fields that we want to change as the whole Tree instance is rebuilt from the request's body. In this example, we will define a PATCH method that will allow us to modify only some specific fields of a Tree instance: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from fastapi import FastAPI , HTTPException from pydantic import BaseModel from odmantic import AIOEngine , Model , ObjectId class Tree ( Model ): name : str average_size : float discovery_year : int app = FastAPI () engine = AIOEngine () @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree class TreePatchSchema ( BaseModel ): name : str = None average_size : float = None discovery_year : float = None @app . patch ( \"/trees/ {id} \" , response_model = Tree ) async def update_tree_by_id ( id : ObjectId , patch : TreePatchSchema ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) tree . update ( patch ) await engine . save ( tree ) return tree First, we define the TreePatchSchema this Pydantic model will contain the modifications that we need to apply on the instance. Since we want to be able to update each field independently, we give each of them the None default value. Then, we configure a new PATCH endpoint by setting the id of the model to update as a path parameter and the TreePatchSchema as the request body parameter. After all the parameters have been validated properly and the appropriate instance have been gathered, we can apply the modifications to the local instance using the Model.update method. By default, the update method will replace each field values in the instance with the ones explicitely set in the patch object. Thus, the fields containing the None default values are not gonna be changed in the instance. We can then finish by saving and returning the updated tree. Optional, defaults, non-required and required pydantic fields (advanced) from pydantic import BaseModel class M ( BaseModel ): a : Optional [ int ] b : Optional [ int ] = None c : int = None d : int In this example, fields have a different behavior: a : Optional [ int ] this field is not required , None is its default value, it can be given None or any int values b : Optional [ int ] = None same behavior as a since None is set automatically as the default value for typing.Optional fields c : int = None this field is not required , if not explicitely provided it will take the None value, only an int can be given as an explicit value d : int this field is required and an int value must be provided (More details: pydantic #1223 , pydantic: Required fields ) By default Model.update , will not apply values from unset (not explicitely populated) fields. Since we don't want to allow explicitely set None values in the example, we used fields defined as c : int = None . Updating a tree from the command line HTTPie curl Update the tree identified by 5f8c8266f1d33aa1012f3083 : http PATCH localhost:8080/trees/5f8c8266f1d33aa1012f3083 \\ discovery_year = 1825 name = \"Stone Pine\" Output: HTTP/1.1 200 OK content-length: 94 content-type: application/json date: Sun, 18 Oct 2020 22:02:44 GMT server: uvicorn { \"average_size\": 5.0, \"discovery_year\": 1825, \"id\": \"5f8c8266f1d33aa1012f3083\", \"name\": \"Stone Pine\" } Check that the tree has been updated properly: http localhost:8080/trees/5f8c8266f1d33aa1012f3083 Output: HTTP/1.1 200 OK content-length: 94 content-type: application/json date: Sun, 18 Oct 2020 22:06:52 GMT server: uvicorn { \"average_size\": 5.0, \"discovery_year\": 1825, \"id\": \"5f8c8266f1d33aa1012f3083\", \"name\": \"Stone Pine\" } Update the tree identified by 5f8c8266f1d33aa1012f3083 : curl -X PATCH \"http://localhost:8080/trees/5f8c8266f1d33aa1012f3083\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Stone Pine\", \"discovery_year\":1825}' Output: {\"name\":\"Stone Pine\",\"average_size\":5.0,\"discovery_year\":1825,\"id\":\"5f8c8266f1d33aa1012f3083\"} Check that the tree has been updated properly: curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3083 Output: {\"name\":\"Stone Pine\",\"average_size\":5.0,\"discovery_year\":1825,\"id\":\"5f8c8266f1d33aa1012f3083\"} The tree has been updated successfully ! Upcoming features \u00b6 A lot of feature could still improve the ODMantic + FastAPI experience. Some ideas that should arrive soon: Add a not_found_exception argument to the AIOEngine.find_one method. Thus, if the document is not found an exception will be raised directly. Implement the equivalent of MongoDB insert method to be able to create document without overwriting existing ones. Implement a Model.update method to update the model fields from a dictionnary or from a Pydantic schema. Automatically generate CRUD endpoints directly from an ODMantic Model.","title":"Usage with FastAPI"},{"location":"usage_fastapi/#usage-with-fastapi","text":"","title":"Usage with FastAPI"},{"location":"usage_fastapi/#example","text":"In this example, we create a minimalist REST API describing trees by their name, average size and discovery year. Requirements To run the following example, you'll need to install FastAPI and Uvicorn. pip install fastapi uvicorn 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from typing import List from fastapi import FastAPI , HTTPException from odmantic import AIOEngine , Model , ObjectId class Tree ( Model ): name : str average_size : float discovery_year : int app = FastAPI () engine = AIOEngine () @app . put ( \"/trees/\" , response_model = Tree ) async def create_tree ( tree : Tree ): await engine . save ( tree ) return tree @app . get ( \"/trees/\" , response_model = List [ Tree ]) async def get_trees (): trees = await engine . find ( Tree ) return trees @app . get ( \"/trees/count\" , response_model = int ) async def count_trees (): count = await engine . count ( Tree ) return count @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree You can then start the application. For example if you saved the file above in a file named tree_api.py : uvicorn tree_api : app Uvicorn should start serving the API locally: INFO: Started server process [21429] INFO: Waiting for application startup. INFO: Application startup complete. INFO: Uvicorn running on http://localhost:8080 (Press CTRL+C to quit) To try it out, you can simply access the interactive documentation generated by FastAPI at http://localhost:8080/docs . We'll now dive in the details of this example.","title":"Example"},{"location":"usage_fastapi/#defining-the-model","text":"First, we create our Tree model. class Tree ( Model ): name : str average_size : float discovery_year : int This describes our Tree instances structure both for JSON serialization and for the storage in the MongoDB collection.","title":"Defining the model"},{"location":"usage_fastapi/#building-the-engine","text":"After having defined the model, we create the AIOEngine object. This object will be responsible for performing database operations. engine = AIOEngine () It's possible as well to build the engine with custom parameters (mongo URI, database name). See this section for more details. Running the python file directly If you need to execute the python file directly with the interpreter (to use a debugger for example), some extra steps will be required. Run uvicorn using the default event loop (if the file is called directly): if __name__ == \"__main__\" : import asyncio import uvicorn loop = asyncio . get_event_loop () config = uvicorn . Config ( app = app , port = 8080 , loop = loop ) server = uvicorn . Server ( config ) loop . run_until_complete ( server . serve ()) uvicorn.run behavior with event loops (Advanced) The usual entrypoint uvicorn.run(app) for ASGI apps doesn't work because when called uvicorn will create and run a brand new event loop. Thus, the engine object will be bound to a different event loop that will not be running. In this case, you'll witness <Future pending> attached to a different loop errors because the app itself will be running in a different event loop than the engine's driver. Anyway, when running directly the app through the uvicorn CLI, the default event loop will be the one that will be running later, so no modifications are required. AIOEngineDependency deprecation (from v0.2.0) The AIOEngineDependency that was used to inject the engine in the API routes is now deprecated (it will be kept for few versions though). Using a global engine object should be preferred as it will dramatically reduce the required verbosity to use the engine in an endpoint. If you need to run your app directly from a python file, see the above Running the python file directly section.","title":"Building the engine"},{"location":"usage_fastapi/#creating-a-tree","text":"The next step is to define a route enabling us to create a new tree. To that end, we create a PUT route with the path /trees/ . This endpoint will receive a tree, persist it to the database and return the created object. @app . put ( \"/trees/\" , response_model = Tree ) async def create_tree ( tree : Tree ): await engine . save ( tree ) return tree First, the request body will be parsed to a Tree object (this is done by specifying the argument tree: Tree ). This mean that the model validation will be performed. Once the model is parsed to a Tree instance, we persist it to the database and we return it. Command line tool for interacting with JSON based HTTP APIs To interact with the API from the command line, we recommend to use the HTTPie CLI. The next examples are still provided with the curl syntax since the Swagger documentation generated by FastAPI will give you curl examples directly. Creating a Tree from the command line HTTPie curl Send the request: http PUT localhost:8080/trees/ name = \"Spruce\" discovery_year = 1995 average_size = 2 Output: HTTP/1.1 200 OK content-length: 90 content-type: application/json date: Sun, 18 Oct 2020 18:40:30 GMT server: uvicorn { \"average_size\": 2.0, \"discovery_year\": 1995, \"id\": \"5f8c8c1ff1d33aa1012f3086\", \"name\": \"Spruce\" } Send the request: curl -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Spruce\", \"discovery_year\":1995, \"average_size\":2}' Output: {\"name\":\"Spruce\",\"average_size\":2.0,\"discovery_year\":1995,\"id\":\"5f8c8c1ff1d33aa1012f3086\"} You can notice that the id field has been added automatically by ODMantic. This id field is actually not required since it's defined automatically by ODMantic with a default factory method ( more details ). You can still specify this field in the request body to predefine the id of the created instance or to overwrite an existing instance. Why PUT instead of POST ? Since the engine.save behave as an upsert operation ( more details ), you can overwrite instances stored in the database by creating a new instance with the same id and calling the engine.save method. Modifying the Tree from the command line To overwrite the tree with id=5f8c8c1ff1d33aa1012f3086 : HTTPie curl Send the request: http PUT localhost:8080/trees/ \\ name = \"Norway Spruce\" discovery_year = 1795 \\ average_size = 200 id = \"5f8c8c1ff1d33aa1012f3086\" Output: HTTP/1.1 200 OK content-length: 90 content-type: application/json date: Sun, 18 Oct 2020 18:40:30 GMT server: uvicorn { \"average_size\": 200.0, \"discovery_year\": 1795, \"id\": \"5f8c8c1ff1d33aa1012f3086\", \"name\": \"Norway Spruce\" } Send the request: curl -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Norway Spruce\", \"discovery_year\":1795, \"average_size\":200, \"id\":\"5f8c8c1ff1d33aa1012f3086\"}' Output: {\"name\":\"Norway Spruce\",\"average_size\":200.0,\"discovery_year\":1795,\"id\":\"5f8c8c1ff1d33aa1012f3086\"} Since we can modify an existing instance, it makes more sense to define the operation as a PUT instead of a POST that should create a new resource on each call. If the request body doesn't match our model schema, a 422 Unprocessable Entity error will be returned by the API, containing the details about the error. Invalid data while creating the Tree from the command line You can try by omitting the average_size field: HTTPie curl Send the request: http PUT localhost:8080/trees/ name = \"Spruce\" discovery_year = 1995 Output: HTTP/1.1 422 Unprocessable Entity content-length: 96 content-type: application/json date: Sun, 18 Oct 2020 16:42:18 GMT server: uvicorn { \"detail\": [ { \"loc\": [ \"body\", \"average_size\" ], \"msg\": \"field required\", \"type\": \"value_error.missing\" } ] } Send the request: curl -v -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Spruce\", \"discovery_year\":1995}' Output: * Trying 127.0.0.1... * TCP_NODELAY set * Connected to localhost (127.0.0.1) port 8080 (#0) > PUT /trees/ HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.58.0 > Accept: */* > Content-Type: application/json > Content-Length: 40 > * upload completely sent off: 40 out of 40 bytes < HTTP/1.1 422 Unprocessable Entity < date: Sun, 18 Oct 2020 18:51:33 GMT < server: uvicorn < content-length: 96 < content-type: application/json < * Connection #0 to host localhost left intact {\"detail\":[{\"loc\":[\"body\",\"average_size\"],\"msg\":\"field required\",\"type\":\"value_error.missing\"}]}% The validation error structure is the one that is defined by the Pydantic: ValidationError exception. Finally, specifying the response_model in the app.put decorator is not mandatory but it is strongly advised as it helps FastAPI to generate the documentation.","title":"Creating a tree"},{"location":"usage_fastapi/#getting-all-the-trees","text":"To get the trees stored in the database, we use the AIOEngine.find method in its awaitable form ( more details ), this gives us directly the list of Tree instances that we can return directly: @app . get ( \"/trees/\" , response_model = List [ Tree ]) async def get_trees (): trees = await engine . find ( Tree ) return trees Creating and getting the trees from the command line HTTPie curl Create some trees: http PUT localhost:8080/trees/ name = \"Spruce\" discovery_year = 1995 average_size = 10 .2 http PUT localhost:8080/trees/ name = \"Pine\" discovery_year = 1850 average_size = 5 Get the trees: http localhost:8080/trees/ Output: HTTP/1.1 200 OK content-length: 270 content-type: application/json date: Sun, 18 Oct 2020 17:59:10 GMT server: uvicorn [ { \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\", \"name\": \"Spruce\" }, { \"average_size\": 5.0, \"discovery_year\": 1850, \"id\": \"5f8c8266f1d33aa1012f3083\", \"name\": \"Pine\" } ] Create some trees: curl -v -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Spruce\", \"discovery_year\":1995, \"average_size\":10.2}' curl -v -X PUT \"http://localhost:8080/trees/\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Pine\", \"discovery_year\":1850, \"average_size\":5}' Get the trees: curl http://localhost:8080/trees/ | python -mjson.tool Output: [ { \"name\": \"Spruce\", \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\" }, { \"name\": \"Pine\", \"average_size\": 5.0, \"discovery_year\": 1850, \"id\": \"5f8c8266f1d33aa1012f3083\" } ] Pagination You can add pagination to this GET request by using the skip and limit arguments while calling the AIOEngine.find method.","title":"Getting all the trees"},{"location":"usage_fastapi/#counting-the-trees","text":"To get the number of trees stored in the database, we use the AIOEngine.count method without specifying any query parameters (to directly get the total count of instances). @app . get ( \"/trees/count\" , response_model = int ) async def count_trees (): count = await engine . count ( Tree ) return count Getting the tree count from the command line HTTPie curl Get the count: http localhost:8080/trees/count Output: HTTP/1.1 200 OK content-length: 1 content-type: application/json date: Sun, 18 Oct 2020 20:16:50 GMT server: uvicorn 2 Get the count: curl http://localhost:8080/trees/count Output: 2","title":"Counting the trees"},{"location":"usage_fastapi/#getting-a-tree-by-id","text":"@app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId , ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree To return a tree from its id we add a path parameter id: ObjectId . Once this endpoint is called, FastAPI will try to validate this query parameter, thus inferring an ObjectId object. Using BSON objects as parameters While you can define ODMantic models directly using bson fields ( more details ), it's not possible to use those types directly with FastAPI, you'll need to get the equivalent objects from the odmantic.bson module. Those equivalent types implement the additional validation logic enabling FastAPI to work with them. from odmantic.bson import ObjectId For convenience reasons, the ObjectId type including the validation logic is as well available directly from the odmantic module. from odmantic import ObjectId With this ObjectId , we build a query that will filter only the instances having this exactly same id : Tree . id == id Then, we pass this query to the AIOEngine.find_one method that will try to return an instance, otherwise None will be returned: tree = await engine . find_one ( Tree , Tree . id == id ) Now, if our tree object is None (i.e the instance has not been found), we need to return a 404 Not Found error: if tree is None : raise HTTPException ( 404 ) Otherwise, we found the requested instance. We can return it ! return tree Getting a tree from the command line HTTPie curl Get the tree 5f8c8266f1d33aa1012f3082 : http localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: HTTP/1.1 200 OK content-length: 91 content-type: application/json date: Sun, 18 Oct 2020 21:08:07 GMT server: uvicorn { \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\", \"name\": \"Spruce\" } Get the tree 5f8c8266f1d33aa1012f3082 : curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: {\"name\":\"Spruce\",\"average_size\":10.2,\"discovery_year\":1995,\"id\":\"5f8c8266f1d33aa1012f3082\"} Trying to get a tree not in the database from the command line HTTPie curl Try to get the tree f0f0f0f0f0f0f0f0f0f0f0f0 (it has not been created): http localhost:8080/trees/f0f0f0f0f0f0f0f0f0f0f0f0 Output: HTTP/1.1 404 Not Found content-length: 22 content-type: application/json date: Sun, 18 Oct 2020 21:11:48 GMT server: uvicorn { \"detail\": \"Not Found\" } Try to get the tree f0f0f0f0f0f0f0f0f0f0f0f0 (it has not been created): curl http://localhost:8080/trees/f0f0f0f0f0f0f0f0f0f0f0f0 Output: {\"detail\":\"Not Found\"} This id path parameter should be a 16 characters hexadecimal string (see MongoDB: ObjectId for more details). If the id specified in the path does not match this criteria, a 422 Unprocessable Entity error will be returned: Trying to get a tree with an invalid id from the command line HTTPie curl Get the tree identified by invalid_object_id : http localhost:8080/trees/invalid_object_id Output: HTTP/1.1 422 Unprocessable Entity content-length: 89 content-type: application/json date: Sun, 18 Oct 2020 20:50:25 GMT server: uvicorn { \"detail\": [ { \"loc\": [ \"path\", \"id\" ], \"msg\": \"invalid ObjectId specified\", \"type\": \"type_error\" } ] } Get the tree identified by invalid_object_id : curl http://localhost:8080/trees/invalid_object_id Output: {\"detail\":[{\"loc\":[\"path\",\"id\"],\"msg\":\"invalid ObjectId specified\",\"type\":\"type_error\"}]}","title":"Getting a tree by id"},{"location":"usage_fastapi/#extending-the-example","text":"","title":"Extending the example"},{"location":"usage_fastapi/#deleting-a-tree","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import uvicorn from fastapi import FastAPI , HTTPException from odmantic import AIOEngine , Model , ObjectId class Tree ( Model ): name : str average_size : float discovery_year : int app = FastAPI () engine = AIOEngine () @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree @app . delete ( \"/trees/ {id} \" , response_model = Tree ) async def delete_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) await engine . delete ( tree ) return tree This new DELETE route is strongly inspired from the one used to get a tree from its id . Currently, ODMantic can only delete an instance and it's not possible to perform a delete operation from a query filter. Thus, we first need to get the associated instance. Once we have the instance, we call the AIOEngine.delete method to perform the deletion. Deleting a tree from the command line HTTPie curl Delete the tree identified by 5f8c8266f1d33aa1012f3082 : http DELETE localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: HTTP/1.1 200 OK content-length: 91 content-type: application/json date: Sun, 18 Oct 2020 21:35:22 GMT server: uvicorn { \"average_size\": 10.2, \"discovery_year\": 1995, \"id\": \"5f8c8266f1d33aa1012f3082\", \"name\": \"Spruce\" } Check that the tree is not stored anymore: http localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: HTTP/1.1 404 Not Found content-length: 22 content-type: application/json date: Sun, 18 Oct 2020 21:36:45 GMT server: uvicorn { \"detail\": \"Not Found\" } Delete the tree identified by 5f8c8266f1d33aa1012f3082 : curl -X DELETE http://localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: {\"name\":\"Spruce\",\"average_size\":10.2,\"discovery_year\":1995,\"id\":\"5f8c8266f1d33aa1012f3082\"} Check that the tree is not stored anymore: curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3082 Output: {\"detail\":\"Not Found\"} The tree has been removed successfully !","title":"Deleting a tree"},{"location":"usage_fastapi/#updating-a-tree","text":"We already defined a PUT route that enables us to modify (replace) a tree instance. However, with this previous implementation, it's not possible to specify only the fields that we want to change as the whole Tree instance is rebuilt from the request's body. In this example, we will define a PATCH method that will allow us to modify only some specific fields of a Tree instance: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from fastapi import FastAPI , HTTPException from pydantic import BaseModel from odmantic import AIOEngine , Model , ObjectId class Tree ( Model ): name : str average_size : float discovery_year : int app = FastAPI () engine = AIOEngine () @app . get ( \"/trees/ {id} \" , response_model = Tree ) async def get_tree_by_id ( id : ObjectId ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) return tree class TreePatchSchema ( BaseModel ): name : str = None average_size : float = None discovery_year : float = None @app . patch ( \"/trees/ {id} \" , response_model = Tree ) async def update_tree_by_id ( id : ObjectId , patch : TreePatchSchema ): tree = await engine . find_one ( Tree , Tree . id == id ) if tree is None : raise HTTPException ( 404 ) tree . update ( patch ) await engine . save ( tree ) return tree First, we define the TreePatchSchema this Pydantic model will contain the modifications that we need to apply on the instance. Since we want to be able to update each field independently, we give each of them the None default value. Then, we configure a new PATCH endpoint by setting the id of the model to update as a path parameter and the TreePatchSchema as the request body parameter. After all the parameters have been validated properly and the appropriate instance have been gathered, we can apply the modifications to the local instance using the Model.update method. By default, the update method will replace each field values in the instance with the ones explicitely set in the patch object. Thus, the fields containing the None default values are not gonna be changed in the instance. We can then finish by saving and returning the updated tree. Optional, defaults, non-required and required pydantic fields (advanced) from pydantic import BaseModel class M ( BaseModel ): a : Optional [ int ] b : Optional [ int ] = None c : int = None d : int In this example, fields have a different behavior: a : Optional [ int ] this field is not required , None is its default value, it can be given None or any int values b : Optional [ int ] = None same behavior as a since None is set automatically as the default value for typing.Optional fields c : int = None this field is not required , if not explicitely provided it will take the None value, only an int can be given as an explicit value d : int this field is required and an int value must be provided (More details: pydantic #1223 , pydantic: Required fields ) By default Model.update , will not apply values from unset (not explicitely populated) fields. Since we don't want to allow explicitely set None values in the example, we used fields defined as c : int = None . Updating a tree from the command line HTTPie curl Update the tree identified by 5f8c8266f1d33aa1012f3083 : http PATCH localhost:8080/trees/5f8c8266f1d33aa1012f3083 \\ discovery_year = 1825 name = \"Stone Pine\" Output: HTTP/1.1 200 OK content-length: 94 content-type: application/json date: Sun, 18 Oct 2020 22:02:44 GMT server: uvicorn { \"average_size\": 5.0, \"discovery_year\": 1825, \"id\": \"5f8c8266f1d33aa1012f3083\", \"name\": \"Stone Pine\" } Check that the tree has been updated properly: http localhost:8080/trees/5f8c8266f1d33aa1012f3083 Output: HTTP/1.1 200 OK content-length: 94 content-type: application/json date: Sun, 18 Oct 2020 22:06:52 GMT server: uvicorn { \"average_size\": 5.0, \"discovery_year\": 1825, \"id\": \"5f8c8266f1d33aa1012f3083\", \"name\": \"Stone Pine\" } Update the tree identified by 5f8c8266f1d33aa1012f3083 : curl -X PATCH \"http://localhost:8080/trees/5f8c8266f1d33aa1012f3083\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Stone Pine\", \"discovery_year\":1825}' Output: {\"name\":\"Stone Pine\",\"average_size\":5.0,\"discovery_year\":1825,\"id\":\"5f8c8266f1d33aa1012f3083\"} Check that the tree has been updated properly: curl http://localhost:8080/trees/5f8c8266f1d33aa1012f3083 Output: {\"name\":\"Stone Pine\",\"average_size\":5.0,\"discovery_year\":1825,\"id\":\"5f8c8266f1d33aa1012f3083\"} The tree has been updated successfully !","title":"Updating a tree"},{"location":"usage_fastapi/#upcoming-features","text":"A lot of feature could still improve the ODMantic + FastAPI experience. Some ideas that should arrive soon: Add a not_found_exception argument to the AIOEngine.find_one method. Thus, if the document is not found an exception will be raised directly. Implement the equivalent of MongoDB insert method to be able to create document without overwriting existing ones. Implement a Model.update method to update the model fields from a dictionnary or from a Pydantic schema. Automatically generate CRUD endpoints directly from an ODMantic Model.","title":"Upcoming features"},{"location":"usage_pydantic/","text":"Usage with Pydantic \u00b6 Defining models with BSON Fields \u00b6 You might need to define pure Pydantic models which include BSON fields. To that end, you can use the BaseBSONModel as the base class of your Pydantic models. This class adds the JSON encoders required to handle the BSON fields. Also, you will have to use the bson equivalent types defined in the odmantic.bson module. Those types, add a validation logic to the native types from the bson module. Custom json_encoders with BaseBSONModel If you want to specify additional json encoders, with a Pydantic model containing BSON fields, you will need to pass as well the ODMantic encoders ( BSON_TYPES_ENCODERS ). Custom encoders example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from datetime import datetime from odmantic.bson import BSON_TYPES_ENCODERS , BaseBSONModel , ObjectId class M ( BaseBSONModel ): id : ObjectId date : datetime class Config : json_encoders = { ** BSON_TYPES_ENCODERS , datetime : lambda dt : dt . year , } print ( M ( id = ObjectId (), date = datetime . utcnow ()) . json ()) #> {\"id\": \"5fa3378c8fde3766574d874d\", \"date\": 2020} An issue that would simplify this behavior has been opened: pydantic#2024 Accessing the underlying pydantic model \u00b6 Each ODMantic Model contain a pure version of the pydantic model used to build the ODMantic Model. This Pydantic model can be accessed in the __pydantic_model__ class attribute of the ODMantic Model/EmbeddedModel.","title":"Usage with Pydantic"},{"location":"usage_pydantic/#usage-with-pydantic","text":"","title":"Usage with Pydantic"},{"location":"usage_pydantic/#defining-models-with-bson-fields","text":"You might need to define pure Pydantic models which include BSON fields. To that end, you can use the BaseBSONModel as the base class of your Pydantic models. This class adds the JSON encoders required to handle the BSON fields. Also, you will have to use the bson equivalent types defined in the odmantic.bson module. Those types, add a validation logic to the native types from the bson module. Custom json_encoders with BaseBSONModel If you want to specify additional json encoders, with a Pydantic model containing BSON fields, you will need to pass as well the ODMantic encoders ( BSON_TYPES_ENCODERS ). Custom encoders example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from datetime import datetime from odmantic.bson import BSON_TYPES_ENCODERS , BaseBSONModel , ObjectId class M ( BaseBSONModel ): id : ObjectId date : datetime class Config : json_encoders = { ** BSON_TYPES_ENCODERS , datetime : lambda dt : dt . year , } print ( M ( id = ObjectId (), date = datetime . utcnow ()) . json ()) #> {\"id\": \"5fa3378c8fde3766574d874d\", \"date\": 2020} An issue that would simplify this behavior has been opened: pydantic#2024","title":"Defining models with BSON Fields"},{"location":"usage_pydantic/#accessing-the-underlying-pydantic-model","text":"Each ODMantic Model contain a pure version of the pydantic model used to build the ODMantic Model. This Pydantic model can be accessed in the __pydantic_model__ class attribute of the ODMantic Model/EmbeddedModel.","title":"Accessing the underlying pydantic model"},{"location":"api_reference/","text":"odmantic.index.Index \u00b6 Source code in odmantic/index.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class Index : def __init__ ( self , * fields : Union [ FieldProxyAny , SortExpression ], unique : bool = False , name : Optional [ str ] = None ) -> None : \"\"\"Declare an ODM index in the Model.Config.indexes generator. Example usage: ```python from odmantic import Model, Index from odmantic.query import desc class Player(Model): name: str score: int class Config: @staticmethod def indexes(): yield Index(Player.name, desc(Player.score)) ``` Args: *fields (Any | SortExpression | str): fields to build the index with unique: build a unique index name: specify an optional custom index name \"\"\" self . fields = cast ( Tuple [ Union [ SortExpression , FieldProxy ], ... ], fields ) self . unique = unique self . name = name def to_odm_index ( self ) -> \"ODMBaseIndex\" : if len ( self . fields ) == 1 : field = self . fields [ 0 ] if isinstance ( field , SortExpression ): key_name = list ( field . keys ())[ 0 ] else : key_name = object . __getattribute__ ( field , \"_get_key_name\" )() return ODMSingleFieldIndex ( key_name , unique = self . unique , index_name = self . name ) else : fields = tuple ( ( f if isinstance ( f , SortExpression ) else asc ( f ) for f in self . fields ) ) return ODMCompoundIndex ( fields , unique = self . unique , index_name = self . name ) __init__ ( * fields , unique = False , name = None ) \u00b6 Declare an ODM index in the Model.Config.indexes generator. Example usage: from odmantic import Model , Index from odmantic.query import desc class Player ( Model ): name : str score : int class Config : @staticmethod def indexes (): yield Index ( Player . name , desc ( Player . score )) Parameters: Name Type Description Default *fields Any | SortExpression | str fields to build the index with () unique bool build a unique index False name Optional [ str ] specify an optional custom index name None Source code in odmantic/index.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def __init__ ( self , * fields : Union [ FieldProxyAny , SortExpression ], unique : bool = False , name : Optional [ str ] = None ) -> None : \"\"\"Declare an ODM index in the Model.Config.indexes generator. Example usage: ```python from odmantic import Model, Index from odmantic.query import desc class Player(Model): name: str score: int class Config: @staticmethod def indexes(): yield Index(Player.name, desc(Player.score)) ``` Args: *fields (Any | SortExpression | str): fields to build the index with unique: build a unique index name: specify an optional custom index name \"\"\" self . fields = cast ( Tuple [ Union [ SortExpression , FieldProxy ], ... ], fields ) self . unique = unique self . name = name","title":"odmantic.index"},{"location":"api_reference/#odmantic.index.Index","text":"Source code in odmantic/index.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class Index : def __init__ ( self , * fields : Union [ FieldProxyAny , SortExpression ], unique : bool = False , name : Optional [ str ] = None ) -> None : \"\"\"Declare an ODM index in the Model.Config.indexes generator. Example usage: ```python from odmantic import Model, Index from odmantic.query import desc class Player(Model): name: str score: int class Config: @staticmethod def indexes(): yield Index(Player.name, desc(Player.score)) ``` Args: *fields (Any | SortExpression | str): fields to build the index with unique: build a unique index name: specify an optional custom index name \"\"\" self . fields = cast ( Tuple [ Union [ SortExpression , FieldProxy ], ... ], fields ) self . unique = unique self . name = name def to_odm_index ( self ) -> \"ODMBaseIndex\" : if len ( self . fields ) == 1 : field = self . fields [ 0 ] if isinstance ( field , SortExpression ): key_name = list ( field . keys ())[ 0 ] else : key_name = object . __getattribute__ ( field , \"_get_key_name\" )() return ODMSingleFieldIndex ( key_name , unique = self . unique , index_name = self . name ) else : fields = tuple ( ( f if isinstance ( f , SortExpression ) else asc ( f ) for f in self . fields ) ) return ODMCompoundIndex ( fields , unique = self . unique , index_name = self . name )","title":"Index"},{"location":"api_reference/#odmantic.index.Index.__init__","text":"Declare an ODM index in the Model.Config.indexes generator. Example usage: from odmantic import Model , Index from odmantic.query import desc class Player ( Model ): name : str score : int class Config : @staticmethod def indexes (): yield Index ( Player . name , desc ( Player . score )) Parameters: Name Type Description Default *fields Any | SortExpression | str fields to build the index with () unique bool build a unique index False name Optional [ str ] specify an optional custom index name None Source code in odmantic/index.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def __init__ ( self , * fields : Union [ FieldProxyAny , SortExpression ], unique : bool = False , name : Optional [ str ] = None ) -> None : \"\"\"Declare an ODM index in the Model.Config.indexes generator. Example usage: ```python from odmantic import Model, Index from odmantic.query import desc class Player(Model): name: str score: int class Config: @staticmethod def indexes(): yield Index(Player.name, desc(Player.score)) ``` Args: *fields (Any | SortExpression | str): fields to build the index with unique: build a unique index name: specify an optional custom index name \"\"\" self . fields = cast ( Tuple [ Union [ SortExpression , FieldProxy ], ... ], fields ) self . unique = unique self . name = name","title":"__init__()"},{"location":"api_reference/bson/","text":"This module provides helpers to build Pydantic Models containing BSON objects. Pydantic model helpers \u00b6 odmantic.bson.BaseBSONModel \u00b6 Bases: BaseModel Equivalent of pydantic.BaseModel supporting BSON types encoding. If you want to apply other custom JSON encoders, you'll need to use BSON_TYPES_ENCODERS directly. Source code in odmantic/bson.py 189 190 191 192 193 194 195 196 197 class BaseBSONModel ( BaseModel ): \"\"\"Equivalent of `pydantic.BaseModel` supporting BSON types encoding. If you want to apply other custom JSON encoders, you'll need to use [BSON_TYPES_ENCODERS][odmantic.bson.BSON_TYPES_ENCODERS] directly. \"\"\" class Config : json_encoders = BSON_TYPES_ENCODERS odmantic . bson . BSON_TYPES_ENCODERS = { bson . ObjectId : str , bson . decimal128 . Decimal128 : lambda x : x . to_decimal (), bson . regex . Regex : lambda x : x . pattern } module-attribute \u00b6 Encoders required to encode BSON fields (can be used in the Pydantic Model's Config.json_encoders parameter). See pydantic: JSON Encoders for more details. Pydantic type helpers \u00b6 Those helpers inherit directly from their respective bson types. They add the field validation logic required by Pydantic to work with them. On top of this, the appropriate JSON schemas are generated for them. odmantic.bson.ObjectId \u00b6 Bases: bson . ObjectId Source code in odmantic/bson.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class ObjectId ( bson . ObjectId ): @classmethod def __get_validators__ ( cls ): # type: ignore yield cls . validate @classmethod def __modify_schema__ ( cls , field_schema : Dict ) -> None : field_schema . update ( examples = [ \"5f85f36d6dfecacc68428a46\" , \"ffffffffffffffffffffffff\" ], example = \"5f85f36d6dfecacc68428a46\" , type = \"string\" , ) @classmethod def validate ( cls , v : Any ) -> bson . ObjectId : if isinstance ( v , ( bson . ObjectId , cls )): return v if isinstance ( v , str ) and bson . ObjectId . is_valid ( v ): return bson . ObjectId ( v ) raise TypeError ( \"invalid ObjectId specified\" ) odmantic.bson.Int64 \u00b6 Bases: bson . int64 . Int64 Source code in odmantic/bson.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class Int64 ( bson . int64 . Int64 ): @classmethod def __get_validators__ ( cls ): # type: ignore yield cls . validate @classmethod def __modify_schema__ ( cls , field_schema : Dict ) -> None : field_schema . update ( examples = [ 2147483649 ], type = \"number\" ) @classmethod def validate ( cls , v : Any ) -> bson . int64 . Int64 : if isinstance ( v , bson . int64 . Int64 ): return v a = int_validator ( v ) return bson . int64 . Int64 ( a ) odmantic.bson.Decimal128 \u00b6 Bases: bson . decimal128 . Decimal128 Source code in odmantic/bson.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class Decimal128 ( bson . decimal128 . Decimal128 ): @classmethod def __get_validators__ ( cls ): # type: ignore yield cls . validate @classmethod def __modify_schema__ ( cls , field_schema : Dict ) -> None : field_schema . update ( examples = [ 214.7483649 ], example = 214.7483649 , type = \"number\" ) @classmethod def validate ( cls , v : Any ) -> bson . decimal128 . Decimal128 : if isinstance ( v , bson . decimal128 . Decimal128 ): return v a = decimal_validator ( v ) return bson . decimal128 . Decimal128 ( a ) odmantic.bson.Binary \u00b6 Bases: bson . binary . Binary Source code in odmantic/bson.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 class Binary ( bson . binary . Binary ): @classmethod def __get_validators__ ( cls ): # type: ignore yield cls . validate @classmethod def __modify_schema__ ( cls , field_schema : Dict ) -> None : field_schema . update ( type = \"string\" , format = \"binary\" ) @classmethod def validate ( cls , v : Any ) -> bson . binary . Binary : if isinstance ( v , bson . binary . Binary ): return v a = bytes_validator ( v ) return bson . binary . Binary ( a ) odmantic.bson.Regex \u00b6 Bases: bson . regex . Regex Source code in odmantic/bson.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 class Regex ( bson . regex . Regex ): @classmethod def __get_validators__ ( cls ): # type: ignore yield cls . validate @classmethod def __modify_schema__ ( cls , field_schema : Dict ) -> None : field_schema . update ( examples = [ r \"^Foo\" ], example = r \"^Foo\" , type = \"string\" , format = \"binary\" ) @classmethod def validate ( cls , v : Any ) -> bson . regex . Regex : if isinstance ( v , bson . regex . Regex ): return v a = pattern_validator ( v ) return bson . regex . Regex ( a . pattern )","title":"odmantic.bson"},{"location":"api_reference/bson/#pydantic-model-helpers","text":"","title":"Pydantic model helpers"},{"location":"api_reference/bson/#odmantic.bson.BaseBSONModel","text":"Bases: BaseModel Equivalent of pydantic.BaseModel supporting BSON types encoding. If you want to apply other custom JSON encoders, you'll need to use BSON_TYPES_ENCODERS directly. Source code in odmantic/bson.py 189 190 191 192 193 194 195 196 197 class BaseBSONModel ( BaseModel ): \"\"\"Equivalent of `pydantic.BaseModel` supporting BSON types encoding. If you want to apply other custom JSON encoders, you'll need to use [BSON_TYPES_ENCODERS][odmantic.bson.BSON_TYPES_ENCODERS] directly. \"\"\" class Config : json_encoders = BSON_TYPES_ENCODERS","title":"BaseBSONModel"},{"location":"api_reference/bson/#odmantic.bson.BSON_TYPES_ENCODERS","text":"Encoders required to encode BSON fields (can be used in the Pydantic Model's Config.json_encoders parameter). See pydantic: JSON Encoders for more details.","title":"BSON_TYPES_ENCODERS"},{"location":"api_reference/bson/#pydantic-type-helpers","text":"Those helpers inherit directly from their respective bson types. They add the field validation logic required by Pydantic to work with them. On top of this, the appropriate JSON schemas are generated for them.","title":"Pydantic type helpers"},{"location":"api_reference/bson/#odmantic.bson.ObjectId","text":"Bases: bson . ObjectId Source code in odmantic/bson.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class ObjectId ( bson . ObjectId ): @classmethod def __get_validators__ ( cls ): # type: ignore yield cls . validate @classmethod def __modify_schema__ ( cls , field_schema : Dict ) -> None : field_schema . update ( examples = [ \"5f85f36d6dfecacc68428a46\" , \"ffffffffffffffffffffffff\" ], example = \"5f85f36d6dfecacc68428a46\" , type = \"string\" , ) @classmethod def validate ( cls , v : Any ) -> bson . ObjectId : if isinstance ( v , ( bson . ObjectId , cls )): return v if isinstance ( v , str ) and bson . ObjectId . is_valid ( v ): return bson . ObjectId ( v ) raise TypeError ( \"invalid ObjectId specified\" )","title":"ObjectId"},{"location":"api_reference/bson/#odmantic.bson.Int64","text":"Bases: bson . int64 . Int64 Source code in odmantic/bson.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class Int64 ( bson . int64 . Int64 ): @classmethod def __get_validators__ ( cls ): # type: ignore yield cls . validate @classmethod def __modify_schema__ ( cls , field_schema : Dict ) -> None : field_schema . update ( examples = [ 2147483649 ], type = \"number\" ) @classmethod def validate ( cls , v : Any ) -> bson . int64 . Int64 : if isinstance ( v , bson . int64 . Int64 ): return v a = int_validator ( v ) return bson . int64 . Int64 ( a )","title":"Int64"},{"location":"api_reference/bson/#odmantic.bson.Decimal128","text":"Bases: bson . decimal128 . Decimal128 Source code in odmantic/bson.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class Decimal128 ( bson . decimal128 . Decimal128 ): @classmethod def __get_validators__ ( cls ): # type: ignore yield cls . validate @classmethod def __modify_schema__ ( cls , field_schema : Dict ) -> None : field_schema . update ( examples = [ 214.7483649 ], example = 214.7483649 , type = \"number\" ) @classmethod def validate ( cls , v : Any ) -> bson . decimal128 . Decimal128 : if isinstance ( v , bson . decimal128 . Decimal128 ): return v a = decimal_validator ( v ) return bson . decimal128 . Decimal128 ( a )","title":"Decimal128"},{"location":"api_reference/bson/#odmantic.bson.Binary","text":"Bases: bson . binary . Binary Source code in odmantic/bson.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 class Binary ( bson . binary . Binary ): @classmethod def __get_validators__ ( cls ): # type: ignore yield cls . validate @classmethod def __modify_schema__ ( cls , field_schema : Dict ) -> None : field_schema . update ( type = \"string\" , format = \"binary\" ) @classmethod def validate ( cls , v : Any ) -> bson . binary . Binary : if isinstance ( v , bson . binary . Binary ): return v a = bytes_validator ( v ) return bson . binary . Binary ( a )","title":"Binary"},{"location":"api_reference/bson/#odmantic.bson.Regex","text":"Bases: bson . regex . Regex Source code in odmantic/bson.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 class Regex ( bson . regex . Regex ): @classmethod def __get_validators__ ( cls ): # type: ignore yield cls . validate @classmethod def __modify_schema__ ( cls , field_schema : Dict ) -> None : field_schema . update ( examples = [ r \"^Foo\" ], example = r \"^Foo\" , type = \"string\" , format = \"binary\" ) @classmethod def validate ( cls , v : Any ) -> bson . regex . Regex : if isinstance ( v , bson . regex . Regex ): return v a = pattern_validator ( v ) return bson . regex . Regex ( a . pattern )","title":"Regex"},{"location":"api_reference/engine/","text":"odmantic.engine.AIOEngine \u00b6 Bases: BaseEngine The AIOEngine object is responsible for handling database operations with MongoDB in an asynchronous way using motor. Source code in odmantic/engine.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 class AIOEngine ( BaseEngine ): \"\"\"The AIOEngine object is responsible for handling database operations with MongoDB in an asynchronous way using motor. \"\"\" client : \"AsyncIOMotorClient\" database : \"AsyncIOMotorDatabase\" def __init__ ( self , client : Union [ \"AsyncIOMotorClient\" , None ] = None , database : str = \"test\" , ): \"\"\"Engine constructor. Args: client: instance of an AsyncIO motor client. If None, a default one will be created database: name of the database to use <!--- #noqa: DAR401 RuntimeError --> \"\"\" if not motor : raise RuntimeError ( \"motor is required to use AIOEngine, install it with: \\n\\n \" + 'pip install \"odmantic[motor]\"' ) if client is None : client = AsyncIOMotorClient () super () . __init__ ( client = client , database = database ) def get_collection ( self , model : Type [ ModelType ]) -> \"AsyncIOMotorCollection\" : \"\"\"Get the motor collection associated to a Model. Args: model: model class Returns: the AsyncIO motor collection object \"\"\" return self . database [ model . __collection__ ] @staticmethod def _get_session ( session : Union [ AIOSessionType , AIOSessionBase ] ) -> Optional [ AsyncIOMotorClientSession ]: if isinstance ( session , ( AIOSession , AIOTransaction )): return session . get_driver_session () assert not isinstance ( session , AIOSessionBase ) # Abstract class return session async def configure_database ( self , models : Sequence [ Type [ ModelType ]], * , update_existing_indexes : bool = False , session : SyncSessionType = None , ) -> None : \"\"\"Apply model constraints to the database. Args: models: list of models to initialize the database with update_existing_indexes: conflicting indexes will be dropped before creation session: an optional session to use for the operation <!--- #noqa: DAR401 pymongo.errors.OperationFailure --> \"\"\" driver_session = self . _get_session ( session ) for model in models : collection = self . get_collection ( model ) for index in model . __indexes__ (): pymongo_index = ( index . get_pymongo_index () if isinstance ( index , ODMBaseIndex ) else index ) try : await collection . create_indexes ( [ pymongo_index ], session = driver_session ) except pymongo . errors . OperationFailure as exc : if update_existing_indexes and getattr ( exc , \"code\" , None ) in ( 85 , # aka IndexOptionsConflict 86 , # aka IndexKeySpecsConflict for MongoDB > 5 ): await collection . drop_index ( pymongo_index . document [ \"name\" ], session = driver_session ) await collection . create_indexes ( [ pymongo_index ], session = driver_session ) else : raise def session ( self ) -> AIOSession : \"\"\"Get a new session for the engine to allow ordering sequential operations. Returns: a new session object Example usage: ```python engine = AIOEngine(...) async with engine.session() as session: john = await session.find(User, User.name == \"John\") john.name = \"Doe\" await session.save(john) ``` \"\"\" return AIOSession ( self ) def transaction ( self ) -> AIOTransaction : \"\"\"Get a new transaction for the engine to aggregate sequential operations. Returns: a new transaction object Example usage: ```python engine = AIOEngine(...) async with engine.transaction() as transaction: john = transaction.find(User, User.name == \"John\") john.name = \"Doe\" await transaction.save(john) await transaction.commit() ``` Warning: MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled. \"\"\" return AIOTransaction ( self ) def find ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , session : AIOSessionType = None , ) -> AIOCursor [ ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched session: an optional session to use for the operation Raises: DocumentParsingError: unable to parse one of the resulting documents Returns: [odmantic.engine.AIOCursor][] of the query <!--- #noqa: DAR401 ValueError #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" pipeline = self . _prepare_find_pipeline ( model , * queries , sort = sort , skip = skip , limit = limit , ) collection = self . get_collection ( model ) motor_cursor = collection . aggregate ( pipeline , session = self . _get_session ( session ) ) return AIOCursor ( model , motor_cursor ) async def find_one ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin sort : Optional [ Any ] = None , session : AIOSessionType = None , ) -> Optional [ ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression session: an optional session to use for the operation Raises: DocumentParsingError: unable to parse the resulting document Returns: the fetched instance if found otherwise None <!--- #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) results = await self . find ( model , * queries , sort = sort , limit = 1 , session = session ) if len ( results ) == 0 : return None return results [ 0 ] async def _save ( self , instance : ModelType , session : \"AsyncIOMotorClientSession\" ) -> ModelType : \"\"\"Perform an atomic save operation in the specified session\"\"\" for ref_field_name in instance . __references__ : sub_instance = cast ( Model , getattr ( instance , ref_field_name )) await self . _save ( sub_instance , session ) fields_to_update = instance . __fields_modified__ | instance . __mutable_fields__ if len ( fields_to_update ) > 0 : doc = instance . doc ( include = fields_to_update ) collection = self . get_collection ( type ( instance )) try : await collection . update_one ( instance . doc ( include = { instance . __primary_field__ }), { \"$set\" : doc }, upsert = True , session = session , ) except pymongo . errors . DuplicateKeyError as e : raise DuplicateKeyError ( instance , e ) object . __setattr__ ( instance , \"__fields_modified__\" , set ()) return instance async def save ( self , instance : ModelType , * , session : AIOSessionType = None , ) -> ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist session: An optional session to use for the operation. If not provided, an internal session will be used to persist the instance and sub-instances. Returns: the saved instance Raises: DuplicateKeyError: the instance is duplicated according to a unique index. NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. <!--- #noqa: DAR401 TypeError #noqa: DAR402 DuplicateKeyError --> \"\"\" if not isinstance ( instance , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) if session : await self . _save ( instance , self . _get_session ( session )) else : async with await self . client . start_session () as local_session : await self . _save ( instance , local_session ) return instance async def save_all ( self , instances : Sequence [ ModelType ], * , session : AIOSessionType = None , ) -> List [ ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist session: An optional session to use for the operation. If not provided, an internal session will be used to persist the instances. Returns: the saved instances Raises: DuplicateKeyError: an instance is duplicated according to a unique index. NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. <!--- #noqa: DAR402 DuplicateKeyError --> \"\"\" if session : added_instances = [ await self . _save ( instance , self . _get_session ( session )) for instance in instances ] else : async with await self . client . start_session () as local_session : added_instances = [ await self . _save ( instance , local_session ) for instance in instances ] return added_instances async def delete ( self , instance : ModelType , * , session : AIOSessionType = None , ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete session: an optional session to use for the operation Raises: DocumentNotFoundError: the instance has not been persisted to the database \"\"\" # TODO handle cascade deletion collection = self . database [ instance . __collection__ ] pk_name = instance . __primary_field__ result = await collection . delete_many ( { \"_id\" : getattr ( instance , pk_name )}, session = self . _get_session ( session ) ) count = int ( result . deleted_count ) if count == 0 : raise DocumentNotFoundError ( instance ) async def remove ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], just_one : bool = False , session : AIOSessionType = None , ) -> int : \"\"\"Delete Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply just_one: limit the deletion to just one document session: an optional session to use for the operation Returns: the number of instances deleted from the database. \"\"\" query = AIOEngine . _build_query ( * queries ) collection = self . get_collection ( model ) if just_one : result = await collection . delete_one ( query , session = self . _get_session ( session ) ) else : result = await collection . delete_many ( query , session = self . _get_session ( session ) ) return cast ( int , result . deleted_count ) async def count ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], session : AIOSessionType = None , ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on *queries: query filters to apply session: an optional session to use for the operation Returns: number of document matching the query <!--- #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call count with a Model class\" ) query = BaseEngine . _build_query ( * queries ) collection = self . database [ model . __collection__ ] count = await collection . count_documents ( query , session = self . _get_session ( session ) ) return int ( count ) __init__ ( client = None , database = 'test' ) \u00b6 Engine constructor. Parameters: Name Type Description Default client Union [ AsyncIOMotorClient , None] instance of an AsyncIO motor client. If None, a default one will be created None database str name of the database to use 'test' Source code in odmantic/engine.py 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 def __init__ ( self , client : Union [ \"AsyncIOMotorClient\" , None ] = None , database : str = \"test\" , ): \"\"\"Engine constructor. Args: client: instance of an AsyncIO motor client. If None, a default one will be created database: name of the database to use <!--- #noqa: DAR401 RuntimeError --> \"\"\" if not motor : raise RuntimeError ( \"motor is required to use AIOEngine, install it with: \\n\\n \" + 'pip install \"odmantic[motor]\"' ) if client is None : client = AsyncIOMotorClient () super () . __init__ ( client = client , database = database ) configure_database ( models , * , update_existing_indexes = False , session = None ) async \u00b6 Apply model constraints to the database. Parameters: Name Type Description Default models Sequence [ Type [ ModelType ]] list of models to initialize the database with required update_existing_indexes bool conflicting indexes will be dropped before creation False session SyncSessionType an optional session to use for the operation None Source code in odmantic/engine.py 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 async def configure_database ( self , models : Sequence [ Type [ ModelType ]], * , update_existing_indexes : bool = False , session : SyncSessionType = None , ) -> None : \"\"\"Apply model constraints to the database. Args: models: list of models to initialize the database with update_existing_indexes: conflicting indexes will be dropped before creation session: an optional session to use for the operation <!--- #noqa: DAR401 pymongo.errors.OperationFailure --> \"\"\" driver_session = self . _get_session ( session ) for model in models : collection = self . get_collection ( model ) for index in model . __indexes__ (): pymongo_index = ( index . get_pymongo_index () if isinstance ( index , ODMBaseIndex ) else index ) try : await collection . create_indexes ( [ pymongo_index ], session = driver_session ) except pymongo . errors . OperationFailure as exc : if update_existing_indexes and getattr ( exc , \"code\" , None ) in ( 85 , # aka IndexOptionsConflict 86 , # aka IndexKeySpecsConflict for MongoDB > 5 ): await collection . drop_index ( pymongo_index . document [ \"name\" ], session = driver_session ) await collection . create_indexes ( [ pymongo_index ], session = driver_session ) else : raise count ( model , * queries , session = None ) async \u00b6 Get the count of documents matching a query Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filters to apply () session AIOSessionType an optional session to use for the operation None Returns: Type Description int number of document matching the query Source code in odmantic/engine.py 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 async def count ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], session : AIOSessionType = None , ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on *queries: query filters to apply session: an optional session to use for the operation Returns: number of document matching the query <!--- #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call count with a Model class\" ) query = BaseEngine . _build_query ( * queries ) collection = self . database [ model . __collection__ ] count = await collection . count_documents ( query , session = self . _get_session ( session ) ) return int ( count ) delete ( instance , * , session = None ) async \u00b6 Delete an instance from the database Parameters: Name Type Description Default instance ModelType the instance to delete required session AIOSessionType an optional session to use for the operation None Raises: Type Description DocumentNotFoundError the instance has not been persisted to the database Source code in odmantic/engine.py 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 async def delete ( self , instance : ModelType , * , session : AIOSessionType = None , ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete session: an optional session to use for the operation Raises: DocumentNotFoundError: the instance has not been persisted to the database \"\"\" # TODO handle cascade deletion collection = self . database [ instance . __collection__ ] pk_name = instance . __primary_field__ result = await collection . delete_many ( { \"_id\" : getattr ( instance , pk_name )}, session = self . _get_session ( session ) ) count = int ( result . deleted_count ) if count == 0 : raise DocumentNotFoundError ( instance ) find ( model , * queries , sort = None , skip = 0 , limit = None , session = None ) \u00b6 Search for Model instances matching the query filter provided Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () sort Optional [ Any ] sort expression None skip int number of document to skip 0 limit Optional [ int ] maximum number of instance fetched None session AIOSessionType an optional session to use for the operation None Raises: Type Description DocumentParsingError unable to parse one of the resulting documents Returns: Type Description AIOCursor [ ModelType ] odmantic.engine.AIOCursor of the query Source code in odmantic/engine.py 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 def find ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , session : AIOSessionType = None , ) -> AIOCursor [ ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched session: an optional session to use for the operation Raises: DocumentParsingError: unable to parse one of the resulting documents Returns: [odmantic.engine.AIOCursor][] of the query <!--- #noqa: DAR401 ValueError #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" pipeline = self . _prepare_find_pipeline ( model , * queries , sort = sort , skip = skip , limit = limit , ) collection = self . get_collection ( model ) motor_cursor = collection . aggregate ( pipeline , session = self . _get_session ( session ) ) return AIOCursor ( model , motor_cursor ) find_one ( model , * queries , sort = None , session = None ) async \u00b6 Search for a Model instance matching the query filter provided Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () sort Optional [ Any ] sort expression None session AIOSessionType an optional session to use for the operation None Raises: Type Description DocumentParsingError unable to parse the resulting document Returns: Type Description Optional [ ModelType ] the fetched instance if found otherwise None Source code in odmantic/engine.py 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 async def find_one ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin sort : Optional [ Any ] = None , session : AIOSessionType = None , ) -> Optional [ ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression session: an optional session to use for the operation Raises: DocumentParsingError: unable to parse the resulting document Returns: the fetched instance if found otherwise None <!--- #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) results = await self . find ( model , * queries , sort = sort , limit = 1 , session = session ) if len ( results ) == 0 : return None return results [ 0 ] get_collection ( model ) \u00b6 Get the motor collection associated to a Model. Parameters: Name Type Description Default model Type [ ModelType ] model class required Returns: Type Description AsyncIOMotorCollection the AsyncIO motor collection object Source code in odmantic/engine.py 328 329 330 331 332 333 334 335 336 337 def get_collection ( self , model : Type [ ModelType ]) -> \"AsyncIOMotorCollection\" : \"\"\"Get the motor collection associated to a Model. Args: model: model class Returns: the AsyncIO motor collection object \"\"\" return self . database [ model . __collection__ ] remove ( model , * queries , just_one = False , session = None ) async \u00b6 Delete Model instances matching the query filter provided Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () just_one bool limit the deletion to just one document False session AIOSessionType an optional session to use for the operation None Returns: Type Description int the number of instances deleted from the database. Source code in odmantic/engine.py 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 async def remove ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], just_one : bool = False , session : AIOSessionType = None , ) -> int : \"\"\"Delete Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply just_one: limit the deletion to just one document session: an optional session to use for the operation Returns: the number of instances deleted from the database. \"\"\" query = AIOEngine . _build_query ( * queries ) collection = self . get_collection ( model ) if just_one : result = await collection . delete_one ( query , session = self . _get_session ( session ) ) else : result = await collection . delete_many ( query , session = self . _get_session ( session ) ) return cast ( int , result . deleted_count ) save ( instance , * , session = None ) async \u00b6 Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Parameters: Name Type Description Default instance ModelType instance to persist required session AIOSessionType An optional session to use for the operation. If not provided, an internal session will be used to persist the instance and sub-instances. None Returns: Type Description ModelType the saved instance Raises: Type Description DuplicateKeyError the instance is duplicated according to a unique index. NOTE The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. Source code in odmantic/engine.py 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 async def save ( self , instance : ModelType , * , session : AIOSessionType = None , ) -> ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist session: An optional session to use for the operation. If not provided, an internal session will be used to persist the instance and sub-instances. Returns: the saved instance Raises: DuplicateKeyError: the instance is duplicated according to a unique index. NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. <!--- #noqa: DAR401 TypeError #noqa: DAR402 DuplicateKeyError --> \"\"\" if not isinstance ( instance , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) if session : await self . _save ( instance , self . _get_session ( session )) else : async with await self . client . start_session () as local_session : await self . _save ( instance , local_session ) return instance save_all ( instances , * , session = None ) async \u00b6 Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Parameters: Name Type Description Default instances Sequence [ ModelType ] instances to persist required session AIOSessionType An optional session to use for the operation. If not provided, an internal session will be used to persist the instances. None Returns: Type Description List [ ModelType ] the saved instances Raises: Type Description DuplicateKeyError an instance is duplicated according to a unique index. NOTE The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. Source code in odmantic/engine.py 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 async def save_all ( self , instances : Sequence [ ModelType ], * , session : AIOSessionType = None , ) -> List [ ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist session: An optional session to use for the operation. If not provided, an internal session will be used to persist the instances. Returns: the saved instances Raises: DuplicateKeyError: an instance is duplicated according to a unique index. NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. <!--- #noqa: DAR402 DuplicateKeyError --> \"\"\" if session : added_instances = [ await self . _save ( instance , self . _get_session ( session )) for instance in instances ] else : async with await self . client . start_session () as local_session : added_instances = [ await self . _save ( instance , local_session ) for instance in instances ] return added_instances session () \u00b6 Get a new session for the engine to allow ordering sequential operations. Returns: Type Description AIOSession a new session object Example usage: engine = AIOEngine ( ... ) async with engine . session () as session : john = await session . find ( User , User . name == \"John\" ) john . name = \"Doe\" await session . save ( john ) Source code in odmantic/engine.py 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 def session ( self ) -> AIOSession : \"\"\"Get a new session for the engine to allow ordering sequential operations. Returns: a new session object Example usage: ```python engine = AIOEngine(...) async with engine.session() as session: john = await session.find(User, User.name == \"John\") john.name = \"Doe\" await session.save(john) ``` \"\"\" return AIOSession ( self ) transaction () \u00b6 Get a new transaction for the engine to aggregate sequential operations. Returns: Type Description AIOTransaction a new transaction object Example usage: engine = AIOEngine ( ... ) async with engine . transaction () as transaction : john = transaction . find ( User , User . name == \"John\" ) john . name = \"Doe\" await transaction . save ( john ) await transaction . commit () Warning MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled. Source code in odmantic/engine.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 def transaction ( self ) -> AIOTransaction : \"\"\"Get a new transaction for the engine to aggregate sequential operations. Returns: a new transaction object Example usage: ```python engine = AIOEngine(...) async with engine.transaction() as transaction: john = transaction.find(User, User.name == \"John\") john.name = \"Doe\" await transaction.save(john) await transaction.commit() ``` Warning: MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled. \"\"\" return AIOTransaction ( self ) odmantic.engine.AIOCursor \u00b6 Bases: BaseCursor [ ModelType ] , AsyncIterable [ ModelType ] , Awaitable [ List [ ModelType ]] This object has to be built from the odmantic.engine.AIOEngine.find method. An AIOCursor object support multiple async operations async for : asynchronously iterate over the query results await : when awaited it will return a list of the fetched models Source code in odmantic/engine.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 class AIOCursor ( BaseCursor [ ModelType ], AsyncIterable [ ModelType ], Awaitable [ List [ ModelType ]] ): \"\"\"This object has to be built from the [odmantic.engine.AIOEngine.find][] method. An AIOCursor object support multiple async operations: - **async for**: asynchronously iterate over the query results - **await** : when awaited it will return a list of the fetched models \"\"\" _cursor : \"AsyncIOMotorCursor\" def __init__ ( self , model : Type [ ModelType ], cursor : \"AsyncIOMotorCursor\" ): super () . __init__ ( model = model , cursor = cursor ) def __await__ ( self ) -> Generator [ None , None , List [ ModelType ]]: if self . _results is not None : return self . _results raw_docs = yield from self . _cursor . to_list ( length = None ) . __await__ () instances = [] for raw_doc in raw_docs : instances . append ( self . _parse_document ( raw_doc )) yield self . _results = instances return instances async def __aiter__ ( self ) -> AsyncGenerator [ ModelType , None ]: if self . _results is not None : for res in self . _results : yield res return results = [] async for raw_doc in self . _cursor : instance = self . _parse_document ( raw_doc ) results . append ( instance ) yield instance self . _results = results odmantic.engine.SyncEngine \u00b6 Bases: BaseEngine The SyncEngine object is responsible for handling database operations with MongoDB in an synchronous way using pymongo. Source code in odmantic/engine.py 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 class SyncEngine ( BaseEngine ): \"\"\"The SyncEngine object is responsible for handling database operations with MongoDB in an synchronous way using pymongo. \"\"\" client : \"MongoClient\" database : \"Database\" def __init__ ( self , client : \"Union[MongoClient, None]\" = None , database : str = \"test\" , ): \"\"\"Engine constructor. Args: client: instance of a PyMongo client. If None, a default one will be created database: name of the database to use \"\"\" if client is None : client = MongoClient () super () . __init__ ( client = client , database = database ) def get_collection ( self , model : Type [ ModelType ]) -> \"Collection\" : \"\"\"Get the pymongo collection associated to a Model. Args: model: model class Returns: the pymongo collection object \"\"\" collection = self . database [ model . __collection__ ] return collection @staticmethod def _get_session ( session : Union [ SyncSessionType , SyncSessionBase ] ) -> Optional [ ClientSession ]: if isinstance ( session , ( SyncSession , SyncTransaction )): return session . get_driver_session () assert not isinstance ( session , SyncSessionBase ) # Abstract class return session def configure_database ( self , models : Sequence [ Type [ ModelType ]], * , update_existing_indexes : bool = False , session : SyncSessionType = None , ) -> None : \"\"\"Apply model constraints to the database. Args: models: list of models to initialize the database with update_existing_indexes: conflicting indexes will be dropped before creation session: an optional session to use for the operation <!--- #noqa: DAR401 pymongo.errors.OperationFailure --> \"\"\" driver_session = self . _get_session ( session ) for model in models : collection = self . get_collection ( model ) for index in model . __indexes__ (): pymongo_index = ( index . get_pymongo_index () if isinstance ( index , ODMBaseIndex ) else index ) try : collection . create_indexes ([ pymongo_index ], session = driver_session ) except pymongo . errors . OperationFailure as exc : if update_existing_indexes and getattr ( exc , \"code\" , None ) in ( 85 , # aka IndexOptionsConflict 86 , # aka IndexKeySpecsConflict for MongoDB > 5 ): collection . drop_index ( pymongo_index . document [ \"name\" ], session = driver_session ) collection . create_indexes ( [ pymongo_index ], session = driver_session ) else : raise def session ( self ) -> SyncSession : \"\"\"Get a new session for the engine to allow ordering sequential operations. Returns: a new session object Example usage: ```python engine = SyncEngine(...) with engine.session() as session: john = session.find(User, User.name == \"John\") john.name = \"Doe\" session.save(john) ``` \"\"\" return SyncSession ( self ) def transaction ( self ) -> SyncTransaction : \"\"\"Get a new transaction for the engine to aggregate sequential operations. Returns: a new transaction object Example usage: ```python engine = SyncEngine(...) with engine.transaction() as transaction: john = transaction.find(User, User.name == \"John\") john.name = \"Doe\" transaction.save(john) transaction.commit() ``` Warning: MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled. \"\"\" return SyncTransaction ( self ) def find ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , session : SyncSessionType = None , ) -> SyncCursor [ ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched session: an optional session to use for the operation Raises: DocumentParsingError: unable to parse one of the resulting documents Returns: [odmantic.engine.SyncCursor][] of the query <!--- #noqa: DAR401 ValueError #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" pipeline = self . _prepare_find_pipeline ( model , * queries , sort = sort , skip = skip , limit = limit , ) collection = self . get_collection ( model ) cursor = collection . aggregate ( pipeline , session = self . _get_session ( session )) return SyncCursor ( model , cursor ) def find_one ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin sort : Optional [ Any ] = None , session : SyncSessionType = None , ) -> Optional [ ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression session: an optional session to use for the operation Raises: DocumentParsingError: unable to parse the resulting document Returns: the fetched instance if found otherwise None <!--- #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) results = list ( self . find ( model , * queries , sort = sort , limit = 1 , session = session )) if len ( results ) == 0 : return None return results [ 0 ] def _save ( self , instance : ModelType , session : \"ClientSession\" ) -> ModelType : \"\"\"Perform an atomic save operation in the specified session\"\"\" for ref_field_name in instance . __references__ : sub_instance = cast ( Model , getattr ( instance , ref_field_name )) self . _save ( sub_instance , session ) fields_to_update = instance . __fields_modified__ | instance . __mutable_fields__ if len ( fields_to_update ) > 0 : doc = instance . doc ( include = fields_to_update ) collection = self . get_collection ( type ( instance )) try : collection . update_one ( instance . doc ( include = { instance . __primary_field__ }), { \"$set\" : doc }, upsert = True , session = session , ) except pymongo . errors . DuplicateKeyError as e : raise DuplicateKeyError ( instance , e ) object . __setattr__ ( instance , \"__fields_modified__\" , set ()) return instance def save ( self , instance : ModelType , * , session : SyncSessionType = None , ) -> ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist session: An optional session to use for the operation. If not provided, an internal session will be used to persist the instance and sub-instances. Returns: the saved instance Raises: DuplicateKeyError: the instance is duplicated according to a unique index. NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. <!--- #noqa: DAR401 TypeError #noqa: DAR402 DuplicateKeyError --> \"\"\" if not isinstance ( instance , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) if session : self . _save ( instance , self . _get_session ( session )) # type: ignore else : with self . client . start_session () as local_session : self . _save ( instance , local_session ) return instance def save_all ( self , instances : Sequence [ ModelType ], * , session : SyncSessionType = None , ) -> List [ ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist session: An optional session to use for the operation. If not provided an internal session will be used to persist the instances. Returns: the saved instances Raises: DuplicateKeyError: an instance is duplicated according to a unique index. NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. <!--- #noqa: DAR402 DuplicateKeyError --> \"\"\" if session : added_instances = [ self . _save ( instance , self . _get_session ( session )) # type: ignore for instance in instances ] else : with self . client . start_session () as local_session : added_instances = [ self . _save ( instance , local_session ) for instance in instances ] return added_instances def delete ( self , instance : ModelType , session : SyncSessionType = None , ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete session: an optional session to use for the operation Raises: DocumentNotFoundError: the instance has not been persisted to the database \"\"\" # TODO handle cascade deletion collection = self . database [ instance . __collection__ ] pk_name = instance . __primary_field__ result = collection . delete_many ( { \"_id\" : getattr ( instance , pk_name )}, session = self . _get_session ( session ) ) count = result . deleted_count if count == 0 : raise DocumentNotFoundError ( instance ) def remove ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], just_one : bool = False , session : SyncSessionType = None , ) -> int : \"\"\"Delete Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply just_one: limit the deletion to just one document session: an optional session to use for the operation Returns: the number of instances deleted from the database. \"\"\" query = SyncEngine . _build_query ( * queries ) collection = self . get_collection ( model ) if just_one : result = collection . delete_one ( query , session = self . _get_session ( session )) else : result = collection . delete_many ( query , session = self . _get_session ( session )) return result . deleted_count def count ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], session : SyncSessionType = None , ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on *queries: query filters to apply session: an optional session to use for the operation Returns: number of document matching the query <!--- #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call count with a Model class\" ) query = BaseEngine . _build_query ( * queries ) collection = self . database [ model . __collection__ ] count = collection . count_documents ( query , session = self . _get_session ( session )) return int ( count ) __init__ ( client = None , database = 'test' ) \u00b6 Engine constructor. Parameters: Name Type Description Default client Union[MongoClient, None] instance of a PyMongo client. If None, a default one will be created None database str name of the database to use 'test' Source code in odmantic/engine.py 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 def __init__ ( self , client : \"Union[MongoClient, None]\" = None , database : str = \"test\" , ): \"\"\"Engine constructor. Args: client: instance of a PyMongo client. If None, a default one will be created database: name of the database to use \"\"\" if client is None : client = MongoClient () super () . __init__ ( client = client , database = database ) configure_database ( models , * , update_existing_indexes = False , session = None ) \u00b6 Apply model constraints to the database. Parameters: Name Type Description Default models Sequence [ Type [ ModelType ]] list of models to initialize the database with required update_existing_indexes bool conflicting indexes will be dropped before creation False session SyncSessionType an optional session to use for the operation None Source code in odmantic/engine.py 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 def configure_database ( self , models : Sequence [ Type [ ModelType ]], * , update_existing_indexes : bool = False , session : SyncSessionType = None , ) -> None : \"\"\"Apply model constraints to the database. Args: models: list of models to initialize the database with update_existing_indexes: conflicting indexes will be dropped before creation session: an optional session to use for the operation <!--- #noqa: DAR401 pymongo.errors.OperationFailure --> \"\"\" driver_session = self . _get_session ( session ) for model in models : collection = self . get_collection ( model ) for index in model . __indexes__ (): pymongo_index = ( index . get_pymongo_index () if isinstance ( index , ODMBaseIndex ) else index ) try : collection . create_indexes ([ pymongo_index ], session = driver_session ) except pymongo . errors . OperationFailure as exc : if update_existing_indexes and getattr ( exc , \"code\" , None ) in ( 85 , # aka IndexOptionsConflict 86 , # aka IndexKeySpecsConflict for MongoDB > 5 ): collection . drop_index ( pymongo_index . document [ \"name\" ], session = driver_session ) collection . create_indexes ( [ pymongo_index ], session = driver_session ) else : raise count ( model , * queries , session = None ) \u00b6 Get the count of documents matching a query Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filters to apply () session SyncSessionType an optional session to use for the operation None Returns: Type Description int number of document matching the query Source code in odmantic/engine.py 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 def count ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], session : SyncSessionType = None , ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on *queries: query filters to apply session: an optional session to use for the operation Returns: number of document matching the query <!--- #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call count with a Model class\" ) query = BaseEngine . _build_query ( * queries ) collection = self . database [ model . __collection__ ] count = collection . count_documents ( query , session = self . _get_session ( session )) return int ( count ) delete ( instance , session = None ) \u00b6 Delete an instance from the database Parameters: Name Type Description Default instance ModelType the instance to delete required session SyncSessionType an optional session to use for the operation None Raises: Type Description DocumentNotFoundError the instance has not been persisted to the database Source code in odmantic/engine.py 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 def delete ( self , instance : ModelType , session : SyncSessionType = None , ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete session: an optional session to use for the operation Raises: DocumentNotFoundError: the instance has not been persisted to the database \"\"\" # TODO handle cascade deletion collection = self . database [ instance . __collection__ ] pk_name = instance . __primary_field__ result = collection . delete_many ( { \"_id\" : getattr ( instance , pk_name )}, session = self . _get_session ( session ) ) count = result . deleted_count if count == 0 : raise DocumentNotFoundError ( instance ) find ( model , * queries , sort = None , skip = 0 , limit = None , session = None ) \u00b6 Search for Model instances matching the query filter provided Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () sort Optional [ Any ] sort expression None skip int number of document to skip 0 limit Optional [ int ] maximum number of instance fetched None session SyncSessionType an optional session to use for the operation None Raises: Type Description DocumentParsingError unable to parse one of the resulting documents Returns: Type Description SyncCursor [ ModelType ] odmantic.engine.SyncCursor of the query Source code in odmantic/engine.py 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 def find ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , session : SyncSessionType = None , ) -> SyncCursor [ ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched session: an optional session to use for the operation Raises: DocumentParsingError: unable to parse one of the resulting documents Returns: [odmantic.engine.SyncCursor][] of the query <!--- #noqa: DAR401 ValueError #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" pipeline = self . _prepare_find_pipeline ( model , * queries , sort = sort , skip = skip , limit = limit , ) collection = self . get_collection ( model ) cursor = collection . aggregate ( pipeline , session = self . _get_session ( session )) return SyncCursor ( model , cursor ) find_one ( model , * queries , sort = None , session = None ) \u00b6 Search for a Model instance matching the query filter provided Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () sort Optional [ Any ] sort expression None session SyncSessionType an optional session to use for the operation None Raises: Type Description DocumentParsingError unable to parse the resulting document Returns: Type Description Optional [ ModelType ] the fetched instance if found otherwise None Source code in odmantic/engine.py 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 def find_one ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin sort : Optional [ Any ] = None , session : SyncSessionType = None , ) -> Optional [ ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression session: an optional session to use for the operation Raises: DocumentParsingError: unable to parse the resulting document Returns: the fetched instance if found otherwise None <!--- #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) results = list ( self . find ( model , * queries , sort = sort , limit = 1 , session = session )) if len ( results ) == 0 : return None return results [ 0 ] get_collection ( model ) \u00b6 Get the pymongo collection associated to a Model. Parameters: Name Type Description Default model Type [ ModelType ] model class required Returns: Type Description Collection the pymongo collection object Source code in odmantic/engine.py 739 740 741 742 743 744 745 746 747 748 749 def get_collection ( self , model : Type [ ModelType ]) -> \"Collection\" : \"\"\"Get the pymongo collection associated to a Model. Args: model: model class Returns: the pymongo collection object \"\"\" collection = self . database [ model . __collection__ ] return collection remove ( model , * queries , just_one = False , session = None ) \u00b6 Delete Model instances matching the query filter provided Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () just_one bool limit the deletion to just one document False session SyncSessionType an optional session to use for the operation None Returns: Type Description int the number of instances deleted from the database. Source code in odmantic/engine.py 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 def remove ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], just_one : bool = False , session : SyncSessionType = None , ) -> int : \"\"\"Delete Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply just_one: limit the deletion to just one document session: an optional session to use for the operation Returns: the number of instances deleted from the database. \"\"\" query = SyncEngine . _build_query ( * queries ) collection = self . get_collection ( model ) if just_one : result = collection . delete_one ( query , session = self . _get_session ( session )) else : result = collection . delete_many ( query , session = self . _get_session ( session )) return result . deleted_count save ( instance , * , session = None ) \u00b6 Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Parameters: Name Type Description Default instance ModelType instance to persist required session SyncSessionType An optional session to use for the operation. If not provided, an internal session will be used to persist the instance and sub-instances. None Returns: Type Description ModelType the saved instance Raises: Type Description DuplicateKeyError the instance is duplicated according to a unique index. NOTE The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. Source code in odmantic/engine.py 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 def save ( self , instance : ModelType , * , session : SyncSessionType = None , ) -> ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist session: An optional session to use for the operation. If not provided, an internal session will be used to persist the instance and sub-instances. Returns: the saved instance Raises: DuplicateKeyError: the instance is duplicated according to a unique index. NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. <!--- #noqa: DAR401 TypeError #noqa: DAR402 DuplicateKeyError --> \"\"\" if not isinstance ( instance , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) if session : self . _save ( instance , self . _get_session ( session )) # type: ignore else : with self . client . start_session () as local_session : self . _save ( instance , local_session ) return instance save_all ( instances , * , session = None ) \u00b6 Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Parameters: Name Type Description Default instances Sequence [ ModelType ] instances to persist required session SyncSessionType An optional session to use for the operation. If not provided an internal session will be used to persist the instances. None Returns: Type Description List [ ModelType ] the saved instances Raises: Type Description DuplicateKeyError an instance is duplicated according to a unique index. NOTE The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. Source code in odmantic/engine.py 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 def save_all ( self , instances : Sequence [ ModelType ], * , session : SyncSessionType = None , ) -> List [ ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist session: An optional session to use for the operation. If not provided an internal session will be used to persist the instances. Returns: the saved instances Raises: DuplicateKeyError: an instance is duplicated according to a unique index. NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. <!--- #noqa: DAR402 DuplicateKeyError --> \"\"\" if session : added_instances = [ self . _save ( instance , self . _get_session ( session )) # type: ignore for instance in instances ] else : with self . client . start_session () as local_session : added_instances = [ self . _save ( instance , local_session ) for instance in instances ] return added_instances session () \u00b6 Get a new session for the engine to allow ordering sequential operations. Returns: Type Description SyncSession a new session object Example usage: engine = SyncEngine ( ... ) with engine . session () as session : john = session . find ( User , User . name == \"John\" ) john . name = \"Doe\" session . save ( john ) Source code in odmantic/engine.py 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 def session ( self ) -> SyncSession : \"\"\"Get a new session for the engine to allow ordering sequential operations. Returns: a new session object Example usage: ```python engine = SyncEngine(...) with engine.session() as session: john = session.find(User, User.name == \"John\") john.name = \"Doe\" session.save(john) ``` \"\"\" return SyncSession ( self ) transaction () \u00b6 Get a new transaction for the engine to aggregate sequential operations. Returns: Type Description SyncTransaction a new transaction object Example usage: engine = SyncEngine ( ... ) with engine . transaction () as transaction : john = transaction . find ( User , User . name == \"John\" ) john . name = \"Doe\" transaction . save ( john ) transaction . commit () Warning MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled. Source code in odmantic/engine.py 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 def transaction ( self ) -> SyncTransaction : \"\"\"Get a new transaction for the engine to aggregate sequential operations. Returns: a new transaction object Example usage: ```python engine = SyncEngine(...) with engine.transaction() as transaction: john = transaction.find(User, User.name == \"John\") john.name = \"Doe\" transaction.save(john) transaction.commit() ``` Warning: MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled. \"\"\" return SyncTransaction ( self ) odmantic.engine.SyncCursor \u00b6 Bases: BaseCursor [ ModelType ] , Iterable [ ModelType ] This object has to be built from the odmantic.engine.SyncEngine.find method. A SyncCursor object supports iterating over the query results using for . To get a list of all the results you can wrap it with list , as in list(cursor) . Source code in odmantic/engine.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 class SyncCursor ( BaseCursor [ ModelType ], Iterable [ ModelType ]): \"\"\"This object has to be built from the [odmantic.engine.SyncEngine.find][] method. A SyncCursor object supports iterating over the query results using **`for`**. To get a list of all the results you can wrap it with `list`, as in `list(cursor)`. \"\"\" _cursor : \"CommandCursor\" def __init__ ( self , model : Type [ ModelType ], cursor : \"CommandCursor\" ): super () . __init__ ( model = model , cursor = cursor ) def __iter__ ( self ) -> Iterator [ ModelType ]: if self . _results is not None : for res in self . _results : yield res return results = [] for raw_doc in self . _cursor : instance = self . _parse_document ( raw_doc ) results . append ( instance ) yield instance self . _results = results","title":"odmantic.engine"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine","text":"Bases: BaseEngine The AIOEngine object is responsible for handling database operations with MongoDB in an asynchronous way using motor. Source code in odmantic/engine.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 class AIOEngine ( BaseEngine ): \"\"\"The AIOEngine object is responsible for handling database operations with MongoDB in an asynchronous way using motor. \"\"\" client : \"AsyncIOMotorClient\" database : \"AsyncIOMotorDatabase\" def __init__ ( self , client : Union [ \"AsyncIOMotorClient\" , None ] = None , database : str = \"test\" , ): \"\"\"Engine constructor. Args: client: instance of an AsyncIO motor client. If None, a default one will be created database: name of the database to use <!--- #noqa: DAR401 RuntimeError --> \"\"\" if not motor : raise RuntimeError ( \"motor is required to use AIOEngine, install it with: \\n\\n \" + 'pip install \"odmantic[motor]\"' ) if client is None : client = AsyncIOMotorClient () super () . __init__ ( client = client , database = database ) def get_collection ( self , model : Type [ ModelType ]) -> \"AsyncIOMotorCollection\" : \"\"\"Get the motor collection associated to a Model. Args: model: model class Returns: the AsyncIO motor collection object \"\"\" return self . database [ model . __collection__ ] @staticmethod def _get_session ( session : Union [ AIOSessionType , AIOSessionBase ] ) -> Optional [ AsyncIOMotorClientSession ]: if isinstance ( session , ( AIOSession , AIOTransaction )): return session . get_driver_session () assert not isinstance ( session , AIOSessionBase ) # Abstract class return session async def configure_database ( self , models : Sequence [ Type [ ModelType ]], * , update_existing_indexes : bool = False , session : SyncSessionType = None , ) -> None : \"\"\"Apply model constraints to the database. Args: models: list of models to initialize the database with update_existing_indexes: conflicting indexes will be dropped before creation session: an optional session to use for the operation <!--- #noqa: DAR401 pymongo.errors.OperationFailure --> \"\"\" driver_session = self . _get_session ( session ) for model in models : collection = self . get_collection ( model ) for index in model . __indexes__ (): pymongo_index = ( index . get_pymongo_index () if isinstance ( index , ODMBaseIndex ) else index ) try : await collection . create_indexes ( [ pymongo_index ], session = driver_session ) except pymongo . errors . OperationFailure as exc : if update_existing_indexes and getattr ( exc , \"code\" , None ) in ( 85 , # aka IndexOptionsConflict 86 , # aka IndexKeySpecsConflict for MongoDB > 5 ): await collection . drop_index ( pymongo_index . document [ \"name\" ], session = driver_session ) await collection . create_indexes ( [ pymongo_index ], session = driver_session ) else : raise def session ( self ) -> AIOSession : \"\"\"Get a new session for the engine to allow ordering sequential operations. Returns: a new session object Example usage: ```python engine = AIOEngine(...) async with engine.session() as session: john = await session.find(User, User.name == \"John\") john.name = \"Doe\" await session.save(john) ``` \"\"\" return AIOSession ( self ) def transaction ( self ) -> AIOTransaction : \"\"\"Get a new transaction for the engine to aggregate sequential operations. Returns: a new transaction object Example usage: ```python engine = AIOEngine(...) async with engine.transaction() as transaction: john = transaction.find(User, User.name == \"John\") john.name = \"Doe\" await transaction.save(john) await transaction.commit() ``` Warning: MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled. \"\"\" return AIOTransaction ( self ) def find ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , session : AIOSessionType = None , ) -> AIOCursor [ ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched session: an optional session to use for the operation Raises: DocumentParsingError: unable to parse one of the resulting documents Returns: [odmantic.engine.AIOCursor][] of the query <!--- #noqa: DAR401 ValueError #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" pipeline = self . _prepare_find_pipeline ( model , * queries , sort = sort , skip = skip , limit = limit , ) collection = self . get_collection ( model ) motor_cursor = collection . aggregate ( pipeline , session = self . _get_session ( session ) ) return AIOCursor ( model , motor_cursor ) async def find_one ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin sort : Optional [ Any ] = None , session : AIOSessionType = None , ) -> Optional [ ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression session: an optional session to use for the operation Raises: DocumentParsingError: unable to parse the resulting document Returns: the fetched instance if found otherwise None <!--- #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) results = await self . find ( model , * queries , sort = sort , limit = 1 , session = session ) if len ( results ) == 0 : return None return results [ 0 ] async def _save ( self , instance : ModelType , session : \"AsyncIOMotorClientSession\" ) -> ModelType : \"\"\"Perform an atomic save operation in the specified session\"\"\" for ref_field_name in instance . __references__ : sub_instance = cast ( Model , getattr ( instance , ref_field_name )) await self . _save ( sub_instance , session ) fields_to_update = instance . __fields_modified__ | instance . __mutable_fields__ if len ( fields_to_update ) > 0 : doc = instance . doc ( include = fields_to_update ) collection = self . get_collection ( type ( instance )) try : await collection . update_one ( instance . doc ( include = { instance . __primary_field__ }), { \"$set\" : doc }, upsert = True , session = session , ) except pymongo . errors . DuplicateKeyError as e : raise DuplicateKeyError ( instance , e ) object . __setattr__ ( instance , \"__fields_modified__\" , set ()) return instance async def save ( self , instance : ModelType , * , session : AIOSessionType = None , ) -> ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist session: An optional session to use for the operation. If not provided, an internal session will be used to persist the instance and sub-instances. Returns: the saved instance Raises: DuplicateKeyError: the instance is duplicated according to a unique index. NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. <!--- #noqa: DAR401 TypeError #noqa: DAR402 DuplicateKeyError --> \"\"\" if not isinstance ( instance , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) if session : await self . _save ( instance , self . _get_session ( session )) else : async with await self . client . start_session () as local_session : await self . _save ( instance , local_session ) return instance async def save_all ( self , instances : Sequence [ ModelType ], * , session : AIOSessionType = None , ) -> List [ ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist session: An optional session to use for the operation. If not provided, an internal session will be used to persist the instances. Returns: the saved instances Raises: DuplicateKeyError: an instance is duplicated according to a unique index. NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. <!--- #noqa: DAR402 DuplicateKeyError --> \"\"\" if session : added_instances = [ await self . _save ( instance , self . _get_session ( session )) for instance in instances ] else : async with await self . client . start_session () as local_session : added_instances = [ await self . _save ( instance , local_session ) for instance in instances ] return added_instances async def delete ( self , instance : ModelType , * , session : AIOSessionType = None , ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete session: an optional session to use for the operation Raises: DocumentNotFoundError: the instance has not been persisted to the database \"\"\" # TODO handle cascade deletion collection = self . database [ instance . __collection__ ] pk_name = instance . __primary_field__ result = await collection . delete_many ( { \"_id\" : getattr ( instance , pk_name )}, session = self . _get_session ( session ) ) count = int ( result . deleted_count ) if count == 0 : raise DocumentNotFoundError ( instance ) async def remove ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], just_one : bool = False , session : AIOSessionType = None , ) -> int : \"\"\"Delete Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply just_one: limit the deletion to just one document session: an optional session to use for the operation Returns: the number of instances deleted from the database. \"\"\" query = AIOEngine . _build_query ( * queries ) collection = self . get_collection ( model ) if just_one : result = await collection . delete_one ( query , session = self . _get_session ( session ) ) else : result = await collection . delete_many ( query , session = self . _get_session ( session ) ) return cast ( int , result . deleted_count ) async def count ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], session : AIOSessionType = None , ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on *queries: query filters to apply session: an optional session to use for the operation Returns: number of document matching the query <!--- #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call count with a Model class\" ) query = BaseEngine . _build_query ( * queries ) collection = self . database [ model . __collection__ ] count = await collection . count_documents ( query , session = self . _get_session ( session ) ) return int ( count )","title":"AIOEngine"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.__init__","text":"Engine constructor. Parameters: Name Type Description Default client Union [ AsyncIOMotorClient , None] instance of an AsyncIO motor client. If None, a default one will be created None database str name of the database to use 'test' Source code in odmantic/engine.py 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 def __init__ ( self , client : Union [ \"AsyncIOMotorClient\" , None ] = None , database : str = \"test\" , ): \"\"\"Engine constructor. Args: client: instance of an AsyncIO motor client. If None, a default one will be created database: name of the database to use <!--- #noqa: DAR401 RuntimeError --> \"\"\" if not motor : raise RuntimeError ( \"motor is required to use AIOEngine, install it with: \\n\\n \" + 'pip install \"odmantic[motor]\"' ) if client is None : client = AsyncIOMotorClient () super () . __init__ ( client = client , database = database )","title":"__init__()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.configure_database","text":"Apply model constraints to the database. Parameters: Name Type Description Default models Sequence [ Type [ ModelType ]] list of models to initialize the database with required update_existing_indexes bool conflicting indexes will be dropped before creation False session SyncSessionType an optional session to use for the operation None Source code in odmantic/engine.py 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 async def configure_database ( self , models : Sequence [ Type [ ModelType ]], * , update_existing_indexes : bool = False , session : SyncSessionType = None , ) -> None : \"\"\"Apply model constraints to the database. Args: models: list of models to initialize the database with update_existing_indexes: conflicting indexes will be dropped before creation session: an optional session to use for the operation <!--- #noqa: DAR401 pymongo.errors.OperationFailure --> \"\"\" driver_session = self . _get_session ( session ) for model in models : collection = self . get_collection ( model ) for index in model . __indexes__ (): pymongo_index = ( index . get_pymongo_index () if isinstance ( index , ODMBaseIndex ) else index ) try : await collection . create_indexes ( [ pymongo_index ], session = driver_session ) except pymongo . errors . OperationFailure as exc : if update_existing_indexes and getattr ( exc , \"code\" , None ) in ( 85 , # aka IndexOptionsConflict 86 , # aka IndexKeySpecsConflict for MongoDB > 5 ): await collection . drop_index ( pymongo_index . document [ \"name\" ], session = driver_session ) await collection . create_indexes ( [ pymongo_index ], session = driver_session ) else : raise","title":"configure_database()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.count","text":"Get the count of documents matching a query Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filters to apply () session AIOSessionType an optional session to use for the operation None Returns: Type Description int number of document matching the query Source code in odmantic/engine.py 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 async def count ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], session : AIOSessionType = None , ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on *queries: query filters to apply session: an optional session to use for the operation Returns: number of document matching the query <!--- #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call count with a Model class\" ) query = BaseEngine . _build_query ( * queries ) collection = self . database [ model . __collection__ ] count = await collection . count_documents ( query , session = self . _get_session ( session ) ) return int ( count )","title":"count()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.delete","text":"Delete an instance from the database Parameters: Name Type Description Default instance ModelType the instance to delete required session AIOSessionType an optional session to use for the operation None Raises: Type Description DocumentNotFoundError the instance has not been persisted to the database Source code in odmantic/engine.py 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 async def delete ( self , instance : ModelType , * , session : AIOSessionType = None , ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete session: an optional session to use for the operation Raises: DocumentNotFoundError: the instance has not been persisted to the database \"\"\" # TODO handle cascade deletion collection = self . database [ instance . __collection__ ] pk_name = instance . __primary_field__ result = await collection . delete_many ( { \"_id\" : getattr ( instance , pk_name )}, session = self . _get_session ( session ) ) count = int ( result . deleted_count ) if count == 0 : raise DocumentNotFoundError ( instance )","title":"delete()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.find","text":"Search for Model instances matching the query filter provided Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () sort Optional [ Any ] sort expression None skip int number of document to skip 0 limit Optional [ int ] maximum number of instance fetched None session AIOSessionType an optional session to use for the operation None Raises: Type Description DocumentParsingError unable to parse one of the resulting documents Returns: Type Description AIOCursor [ ModelType ] odmantic.engine.AIOCursor of the query Source code in odmantic/engine.py 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 def find ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , session : AIOSessionType = None , ) -> AIOCursor [ ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched session: an optional session to use for the operation Raises: DocumentParsingError: unable to parse one of the resulting documents Returns: [odmantic.engine.AIOCursor][] of the query <!--- #noqa: DAR401 ValueError #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" pipeline = self . _prepare_find_pipeline ( model , * queries , sort = sort , skip = skip , limit = limit , ) collection = self . get_collection ( model ) motor_cursor = collection . aggregate ( pipeline , session = self . _get_session ( session ) ) return AIOCursor ( model , motor_cursor )","title":"find()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.find_one","text":"Search for a Model instance matching the query filter provided Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () sort Optional [ Any ] sort expression None session AIOSessionType an optional session to use for the operation None Raises: Type Description DocumentParsingError unable to parse the resulting document Returns: Type Description Optional [ ModelType ] the fetched instance if found otherwise None Source code in odmantic/engine.py 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 async def find_one ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin sort : Optional [ Any ] = None , session : AIOSessionType = None , ) -> Optional [ ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression session: an optional session to use for the operation Raises: DocumentParsingError: unable to parse the resulting document Returns: the fetched instance if found otherwise None <!--- #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) results = await self . find ( model , * queries , sort = sort , limit = 1 , session = session ) if len ( results ) == 0 : return None return results [ 0 ]","title":"find_one()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.get_collection","text":"Get the motor collection associated to a Model. Parameters: Name Type Description Default model Type [ ModelType ] model class required Returns: Type Description AsyncIOMotorCollection the AsyncIO motor collection object Source code in odmantic/engine.py 328 329 330 331 332 333 334 335 336 337 def get_collection ( self , model : Type [ ModelType ]) -> \"AsyncIOMotorCollection\" : \"\"\"Get the motor collection associated to a Model. Args: model: model class Returns: the AsyncIO motor collection object \"\"\" return self . database [ model . __collection__ ]","title":"get_collection()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.remove","text":"Delete Model instances matching the query filter provided Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () just_one bool limit the deletion to just one document False session AIOSessionType an optional session to use for the operation None Returns: Type Description int the number of instances deleted from the database. Source code in odmantic/engine.py 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 async def remove ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], just_one : bool = False , session : AIOSessionType = None , ) -> int : \"\"\"Delete Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply just_one: limit the deletion to just one document session: an optional session to use for the operation Returns: the number of instances deleted from the database. \"\"\" query = AIOEngine . _build_query ( * queries ) collection = self . get_collection ( model ) if just_one : result = await collection . delete_one ( query , session = self . _get_session ( session ) ) else : result = await collection . delete_many ( query , session = self . _get_session ( session ) ) return cast ( int , result . deleted_count )","title":"remove()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.save","text":"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Parameters: Name Type Description Default instance ModelType instance to persist required session AIOSessionType An optional session to use for the operation. If not provided, an internal session will be used to persist the instance and sub-instances. None Returns: Type Description ModelType the saved instance Raises: Type Description DuplicateKeyError the instance is duplicated according to a unique index. NOTE The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. Source code in odmantic/engine.py 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 async def save ( self , instance : ModelType , * , session : AIOSessionType = None , ) -> ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist session: An optional session to use for the operation. If not provided, an internal session will be used to persist the instance and sub-instances. Returns: the saved instance Raises: DuplicateKeyError: the instance is duplicated according to a unique index. NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. <!--- #noqa: DAR401 TypeError #noqa: DAR402 DuplicateKeyError --> \"\"\" if not isinstance ( instance , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) if session : await self . _save ( instance , self . _get_session ( session )) else : async with await self . client . start_session () as local_session : await self . _save ( instance , local_session ) return instance","title":"save()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.save_all","text":"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Parameters: Name Type Description Default instances Sequence [ ModelType ] instances to persist required session AIOSessionType An optional session to use for the operation. If not provided, an internal session will be used to persist the instances. None Returns: Type Description List [ ModelType ] the saved instances Raises: Type Description DuplicateKeyError an instance is duplicated according to a unique index. NOTE The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. Source code in odmantic/engine.py 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 async def save_all ( self , instances : Sequence [ ModelType ], * , session : AIOSessionType = None , ) -> List [ ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist session: An optional session to use for the operation. If not provided, an internal session will be used to persist the instances. Returns: the saved instances Raises: DuplicateKeyError: an instance is duplicated according to a unique index. NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. <!--- #noqa: DAR402 DuplicateKeyError --> \"\"\" if session : added_instances = [ await self . _save ( instance , self . _get_session ( session )) for instance in instances ] else : async with await self . client . start_session () as local_session : added_instances = [ await self . _save ( instance , local_session ) for instance in instances ] return added_instances","title":"save_all()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.session","text":"Get a new session for the engine to allow ordering sequential operations. Returns: Type Description AIOSession a new session object Example usage: engine = AIOEngine ( ... ) async with engine . session () as session : john = await session . find ( User , User . name == \"John\" ) john . name = \"Doe\" await session . save ( john ) Source code in odmantic/engine.py 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 def session ( self ) -> AIOSession : \"\"\"Get a new session for the engine to allow ordering sequential operations. Returns: a new session object Example usage: ```python engine = AIOEngine(...) async with engine.session() as session: john = await session.find(User, User.name == \"John\") john.name = \"Doe\" await session.save(john) ``` \"\"\" return AIOSession ( self )","title":"session()"},{"location":"api_reference/engine/#odmantic.engine.AIOEngine.transaction","text":"Get a new transaction for the engine to aggregate sequential operations. Returns: Type Description AIOTransaction a new transaction object Example usage: engine = AIOEngine ( ... ) async with engine . transaction () as transaction : john = transaction . find ( User , User . name == \"John\" ) john . name = \"Doe\" await transaction . save ( john ) await transaction . commit () Warning MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled. Source code in odmantic/engine.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 def transaction ( self ) -> AIOTransaction : \"\"\"Get a new transaction for the engine to aggregate sequential operations. Returns: a new transaction object Example usage: ```python engine = AIOEngine(...) async with engine.transaction() as transaction: john = transaction.find(User, User.name == \"John\") john.name = \"Doe\" await transaction.save(john) await transaction.commit() ``` Warning: MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled. \"\"\" return AIOTransaction ( self )","title":"transaction()"},{"location":"api_reference/engine/#odmantic.engine.AIOCursor","text":"Bases: BaseCursor [ ModelType ] , AsyncIterable [ ModelType ] , Awaitable [ List [ ModelType ]] This object has to be built from the odmantic.engine.AIOEngine.find method. An AIOCursor object support multiple async operations async for : asynchronously iterate over the query results await : when awaited it will return a list of the fetched models Source code in odmantic/engine.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 class AIOCursor ( BaseCursor [ ModelType ], AsyncIterable [ ModelType ], Awaitable [ List [ ModelType ]] ): \"\"\"This object has to be built from the [odmantic.engine.AIOEngine.find][] method. An AIOCursor object support multiple async operations: - **async for**: asynchronously iterate over the query results - **await** : when awaited it will return a list of the fetched models \"\"\" _cursor : \"AsyncIOMotorCursor\" def __init__ ( self , model : Type [ ModelType ], cursor : \"AsyncIOMotorCursor\" ): super () . __init__ ( model = model , cursor = cursor ) def __await__ ( self ) -> Generator [ None , None , List [ ModelType ]]: if self . _results is not None : return self . _results raw_docs = yield from self . _cursor . to_list ( length = None ) . __await__ () instances = [] for raw_doc in raw_docs : instances . append ( self . _parse_document ( raw_doc )) yield self . _results = instances return instances async def __aiter__ ( self ) -> AsyncGenerator [ ModelType , None ]: if self . _results is not None : for res in self . _results : yield res return results = [] async for raw_doc in self . _cursor : instance = self . _parse_document ( raw_doc ) results . append ( instance ) yield instance self . _results = results","title":"AIOCursor"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine","text":"Bases: BaseEngine The SyncEngine object is responsible for handling database operations with MongoDB in an synchronous way using pymongo. Source code in odmantic/engine.py 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 class SyncEngine ( BaseEngine ): \"\"\"The SyncEngine object is responsible for handling database operations with MongoDB in an synchronous way using pymongo. \"\"\" client : \"MongoClient\" database : \"Database\" def __init__ ( self , client : \"Union[MongoClient, None]\" = None , database : str = \"test\" , ): \"\"\"Engine constructor. Args: client: instance of a PyMongo client. If None, a default one will be created database: name of the database to use \"\"\" if client is None : client = MongoClient () super () . __init__ ( client = client , database = database ) def get_collection ( self , model : Type [ ModelType ]) -> \"Collection\" : \"\"\"Get the pymongo collection associated to a Model. Args: model: model class Returns: the pymongo collection object \"\"\" collection = self . database [ model . __collection__ ] return collection @staticmethod def _get_session ( session : Union [ SyncSessionType , SyncSessionBase ] ) -> Optional [ ClientSession ]: if isinstance ( session , ( SyncSession , SyncTransaction )): return session . get_driver_session () assert not isinstance ( session , SyncSessionBase ) # Abstract class return session def configure_database ( self , models : Sequence [ Type [ ModelType ]], * , update_existing_indexes : bool = False , session : SyncSessionType = None , ) -> None : \"\"\"Apply model constraints to the database. Args: models: list of models to initialize the database with update_existing_indexes: conflicting indexes will be dropped before creation session: an optional session to use for the operation <!--- #noqa: DAR401 pymongo.errors.OperationFailure --> \"\"\" driver_session = self . _get_session ( session ) for model in models : collection = self . get_collection ( model ) for index in model . __indexes__ (): pymongo_index = ( index . get_pymongo_index () if isinstance ( index , ODMBaseIndex ) else index ) try : collection . create_indexes ([ pymongo_index ], session = driver_session ) except pymongo . errors . OperationFailure as exc : if update_existing_indexes and getattr ( exc , \"code\" , None ) in ( 85 , # aka IndexOptionsConflict 86 , # aka IndexKeySpecsConflict for MongoDB > 5 ): collection . drop_index ( pymongo_index . document [ \"name\" ], session = driver_session ) collection . create_indexes ( [ pymongo_index ], session = driver_session ) else : raise def session ( self ) -> SyncSession : \"\"\"Get a new session for the engine to allow ordering sequential operations. Returns: a new session object Example usage: ```python engine = SyncEngine(...) with engine.session() as session: john = session.find(User, User.name == \"John\") john.name = \"Doe\" session.save(john) ``` \"\"\" return SyncSession ( self ) def transaction ( self ) -> SyncTransaction : \"\"\"Get a new transaction for the engine to aggregate sequential operations. Returns: a new transaction object Example usage: ```python engine = SyncEngine(...) with engine.transaction() as transaction: john = transaction.find(User, User.name == \"John\") john.name = \"Doe\" transaction.save(john) transaction.commit() ``` Warning: MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled. \"\"\" return SyncTransaction ( self ) def find ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , session : SyncSessionType = None , ) -> SyncCursor [ ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched session: an optional session to use for the operation Raises: DocumentParsingError: unable to parse one of the resulting documents Returns: [odmantic.engine.SyncCursor][] of the query <!--- #noqa: DAR401 ValueError #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" pipeline = self . _prepare_find_pipeline ( model , * queries , sort = sort , skip = skip , limit = limit , ) collection = self . get_collection ( model ) cursor = collection . aggregate ( pipeline , session = self . _get_session ( session )) return SyncCursor ( model , cursor ) def find_one ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin sort : Optional [ Any ] = None , session : SyncSessionType = None , ) -> Optional [ ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression session: an optional session to use for the operation Raises: DocumentParsingError: unable to parse the resulting document Returns: the fetched instance if found otherwise None <!--- #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) results = list ( self . find ( model , * queries , sort = sort , limit = 1 , session = session )) if len ( results ) == 0 : return None return results [ 0 ] def _save ( self , instance : ModelType , session : \"ClientSession\" ) -> ModelType : \"\"\"Perform an atomic save operation in the specified session\"\"\" for ref_field_name in instance . __references__ : sub_instance = cast ( Model , getattr ( instance , ref_field_name )) self . _save ( sub_instance , session ) fields_to_update = instance . __fields_modified__ | instance . __mutable_fields__ if len ( fields_to_update ) > 0 : doc = instance . doc ( include = fields_to_update ) collection = self . get_collection ( type ( instance )) try : collection . update_one ( instance . doc ( include = { instance . __primary_field__ }), { \"$set\" : doc }, upsert = True , session = session , ) except pymongo . errors . DuplicateKeyError as e : raise DuplicateKeyError ( instance , e ) object . __setattr__ ( instance , \"__fields_modified__\" , set ()) return instance def save ( self , instance : ModelType , * , session : SyncSessionType = None , ) -> ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist session: An optional session to use for the operation. If not provided, an internal session will be used to persist the instance and sub-instances. Returns: the saved instance Raises: DuplicateKeyError: the instance is duplicated according to a unique index. NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. <!--- #noqa: DAR401 TypeError #noqa: DAR402 DuplicateKeyError --> \"\"\" if not isinstance ( instance , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) if session : self . _save ( instance , self . _get_session ( session )) # type: ignore else : with self . client . start_session () as local_session : self . _save ( instance , local_session ) return instance def save_all ( self , instances : Sequence [ ModelType ], * , session : SyncSessionType = None , ) -> List [ ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist session: An optional session to use for the operation. If not provided an internal session will be used to persist the instances. Returns: the saved instances Raises: DuplicateKeyError: an instance is duplicated according to a unique index. NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. <!--- #noqa: DAR402 DuplicateKeyError --> \"\"\" if session : added_instances = [ self . _save ( instance , self . _get_session ( session )) # type: ignore for instance in instances ] else : with self . client . start_session () as local_session : added_instances = [ self . _save ( instance , local_session ) for instance in instances ] return added_instances def delete ( self , instance : ModelType , session : SyncSessionType = None , ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete session: an optional session to use for the operation Raises: DocumentNotFoundError: the instance has not been persisted to the database \"\"\" # TODO handle cascade deletion collection = self . database [ instance . __collection__ ] pk_name = instance . __primary_field__ result = collection . delete_many ( { \"_id\" : getattr ( instance , pk_name )}, session = self . _get_session ( session ) ) count = result . deleted_count if count == 0 : raise DocumentNotFoundError ( instance ) def remove ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], just_one : bool = False , session : SyncSessionType = None , ) -> int : \"\"\"Delete Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply just_one: limit the deletion to just one document session: an optional session to use for the operation Returns: the number of instances deleted from the database. \"\"\" query = SyncEngine . _build_query ( * queries ) collection = self . get_collection ( model ) if just_one : result = collection . delete_one ( query , session = self . _get_session ( session )) else : result = collection . delete_many ( query , session = self . _get_session ( session )) return result . deleted_count def count ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], session : SyncSessionType = None , ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on *queries: query filters to apply session: an optional session to use for the operation Returns: number of document matching the query <!--- #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call count with a Model class\" ) query = BaseEngine . _build_query ( * queries ) collection = self . database [ model . __collection__ ] count = collection . count_documents ( query , session = self . _get_session ( session )) return int ( count )","title":"SyncEngine"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.__init__","text":"Engine constructor. Parameters: Name Type Description Default client Union[MongoClient, None] instance of a PyMongo client. If None, a default one will be created None database str name of the database to use 'test' Source code in odmantic/engine.py 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 def __init__ ( self , client : \"Union[MongoClient, None]\" = None , database : str = \"test\" , ): \"\"\"Engine constructor. Args: client: instance of a PyMongo client. If None, a default one will be created database: name of the database to use \"\"\" if client is None : client = MongoClient () super () . __init__ ( client = client , database = database )","title":"__init__()"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.configure_database","text":"Apply model constraints to the database. Parameters: Name Type Description Default models Sequence [ Type [ ModelType ]] list of models to initialize the database with required update_existing_indexes bool conflicting indexes will be dropped before creation False session SyncSessionType an optional session to use for the operation None Source code in odmantic/engine.py 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 def configure_database ( self , models : Sequence [ Type [ ModelType ]], * , update_existing_indexes : bool = False , session : SyncSessionType = None , ) -> None : \"\"\"Apply model constraints to the database. Args: models: list of models to initialize the database with update_existing_indexes: conflicting indexes will be dropped before creation session: an optional session to use for the operation <!--- #noqa: DAR401 pymongo.errors.OperationFailure --> \"\"\" driver_session = self . _get_session ( session ) for model in models : collection = self . get_collection ( model ) for index in model . __indexes__ (): pymongo_index = ( index . get_pymongo_index () if isinstance ( index , ODMBaseIndex ) else index ) try : collection . create_indexes ([ pymongo_index ], session = driver_session ) except pymongo . errors . OperationFailure as exc : if update_existing_indexes and getattr ( exc , \"code\" , None ) in ( 85 , # aka IndexOptionsConflict 86 , # aka IndexKeySpecsConflict for MongoDB > 5 ): collection . drop_index ( pymongo_index . document [ \"name\" ], session = driver_session ) collection . create_indexes ( [ pymongo_index ], session = driver_session ) else : raise","title":"configure_database()"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.count","text":"Get the count of documents matching a query Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filters to apply () session SyncSessionType an optional session to use for the operation None Returns: Type Description int number of document matching the query Source code in odmantic/engine.py 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 def count ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], session : SyncSessionType = None , ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on *queries: query filters to apply session: an optional session to use for the operation Returns: number of document matching the query <!--- #noqa: DAR401 TypeError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call count with a Model class\" ) query = BaseEngine . _build_query ( * queries ) collection = self . database [ model . __collection__ ] count = collection . count_documents ( query , session = self . _get_session ( session )) return int ( count )","title":"count()"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.delete","text":"Delete an instance from the database Parameters: Name Type Description Default instance ModelType the instance to delete required session SyncSessionType an optional session to use for the operation None Raises: Type Description DocumentNotFoundError the instance has not been persisted to the database Source code in odmantic/engine.py 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 def delete ( self , instance : ModelType , session : SyncSessionType = None , ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete session: an optional session to use for the operation Raises: DocumentNotFoundError: the instance has not been persisted to the database \"\"\" # TODO handle cascade deletion collection = self . database [ instance . __collection__ ] pk_name = instance . __primary_field__ result = collection . delete_many ( { \"_id\" : getattr ( instance , pk_name )}, session = self . _get_session ( session ) ) count = result . deleted_count if count == 0 : raise DocumentNotFoundError ( instance )","title":"delete()"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.find","text":"Search for Model instances matching the query filter provided Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () sort Optional [ Any ] sort expression None skip int number of document to skip 0 limit Optional [ int ] maximum number of instance fetched None session SyncSessionType an optional session to use for the operation None Raises: Type Description DocumentParsingError unable to parse one of the resulting documents Returns: Type Description SyncCursor [ ModelType ] odmantic.engine.SyncCursor of the query Source code in odmantic/engine.py 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 def find ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , session : SyncSessionType = None , ) -> SyncCursor [ ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched session: an optional session to use for the operation Raises: DocumentParsingError: unable to parse one of the resulting documents Returns: [odmantic.engine.SyncCursor][] of the query <!--- #noqa: DAR401 ValueError #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" pipeline = self . _prepare_find_pipeline ( model , * queries , sort = sort , skip = skip , limit = limit , ) collection = self . get_collection ( model ) cursor = collection . aggregate ( pipeline , session = self . _get_session ( session )) return SyncCursor ( model , cursor )","title":"find()"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.find_one","text":"Search for a Model instance matching the query filter provided Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () sort Optional [ Any ] sort expression None session SyncSessionType an optional session to use for the operation None Raises: Type Description DocumentParsingError unable to parse the resulting document Returns: Type Description Optional [ ModelType ] the fetched instance if found otherwise None Source code in odmantic/engine.py 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 def find_one ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin sort : Optional [ Any ] = None , session : SyncSessionType = None , ) -> Optional [ ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression session: an optional session to use for the operation Raises: DocumentParsingError: unable to parse the resulting document Returns: the fetched instance if found otherwise None <!--- #noqa: DAR401 TypeError #noqa: DAR402 DocumentParsingError --> \"\"\" if not lenient_issubclass ( model , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) results = list ( self . find ( model , * queries , sort = sort , limit = 1 , session = session )) if len ( results ) == 0 : return None return results [ 0 ]","title":"find_one()"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.get_collection","text":"Get the pymongo collection associated to a Model. Parameters: Name Type Description Default model Type [ ModelType ] model class required Returns: Type Description Collection the pymongo collection object Source code in odmantic/engine.py 739 740 741 742 743 744 745 746 747 748 749 def get_collection ( self , model : Type [ ModelType ]) -> \"Collection\" : \"\"\"Get the pymongo collection associated to a Model. Args: model: model class Returns: the pymongo collection object \"\"\" collection = self . database [ model . __collection__ ] return collection","title":"get_collection()"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.remove","text":"Delete Model instances matching the query filter provided Parameters: Name Type Description Default model Type [ ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () just_one bool limit the deletion to just one document False session SyncSessionType an optional session to use for the operation None Returns: Type Description int the number of instances deleted from the database. Source code in odmantic/engine.py 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 def remove ( self , model : Type [ ModelType ], * queries : Union [ QueryExpression , Dict , bool ], just_one : bool = False , session : SyncSessionType = None , ) -> int : \"\"\"Delete Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply just_one: limit the deletion to just one document session: an optional session to use for the operation Returns: the number of instances deleted from the database. \"\"\" query = SyncEngine . _build_query ( * queries ) collection = self . get_collection ( model ) if just_one : result = collection . delete_one ( query , session = self . _get_session ( session )) else : result = collection . delete_many ( query , session = self . _get_session ( session )) return result . deleted_count","title":"remove()"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.save","text":"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Parameters: Name Type Description Default instance ModelType instance to persist required session SyncSessionType An optional session to use for the operation. If not provided, an internal session will be used to persist the instance and sub-instances. None Returns: Type Description ModelType the saved instance Raises: Type Description DuplicateKeyError the instance is duplicated according to a unique index. NOTE The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. Source code in odmantic/engine.py 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 def save ( self , instance : ModelType , * , session : SyncSessionType = None , ) -> ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist session: An optional session to use for the operation. If not provided, an internal session will be used to persist the instance and sub-instances. Returns: the saved instance Raises: DuplicateKeyError: the instance is duplicated according to a unique index. NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. <!--- #noqa: DAR401 TypeError #noqa: DAR402 DuplicateKeyError --> \"\"\" if not isinstance ( instance , Model ): raise TypeError ( \"Can only call find_one with a Model class\" ) if session : self . _save ( instance , self . _get_session ( session )) # type: ignore else : with self . client . start_session () as local_session : self . _save ( instance , local_session ) return instance","title":"save()"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.save_all","text":"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Parameters: Name Type Description Default instances Sequence [ ModelType ] instances to persist required session SyncSessionType An optional session to use for the operation. If not provided an internal session will be used to persist the instances. None Returns: Type Description List [ ModelType ] the saved instances Raises: Type Description DuplicateKeyError an instance is duplicated according to a unique index. NOTE The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. Source code in odmantic/engine.py 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 def save_all ( self , instances : Sequence [ ModelType ], * , session : SyncSessionType = None , ) -> List [ ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist session: An optional session to use for the operation. If not provided an internal session will be used to persist the instances. Returns: the saved instances Raises: DuplicateKeyError: an instance is duplicated according to a unique index. NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. <!--- #noqa: DAR402 DuplicateKeyError --> \"\"\" if session : added_instances = [ self . _save ( instance , self . _get_session ( session )) # type: ignore for instance in instances ] else : with self . client . start_session () as local_session : added_instances = [ self . _save ( instance , local_session ) for instance in instances ] return added_instances","title":"save_all()"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.session","text":"Get a new session for the engine to allow ordering sequential operations. Returns: Type Description SyncSession a new session object Example usage: engine = SyncEngine ( ... ) with engine . session () as session : john = session . find ( User , User . name == \"John\" ) john . name = \"Doe\" session . save ( john ) Source code in odmantic/engine.py 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 def session ( self ) -> SyncSession : \"\"\"Get a new session for the engine to allow ordering sequential operations. Returns: a new session object Example usage: ```python engine = SyncEngine(...) with engine.session() as session: john = session.find(User, User.name == \"John\") john.name = \"Doe\" session.save(john) ``` \"\"\" return SyncSession ( self )","title":"session()"},{"location":"api_reference/engine/#odmantic.engine.SyncEngine.transaction","text":"Get a new transaction for the engine to aggregate sequential operations. Returns: Type Description SyncTransaction a new transaction object Example usage: engine = SyncEngine ( ... ) with engine . transaction () as transaction : john = transaction . find ( User , User . name == \"John\" ) john . name = \"Doe\" transaction . save ( john ) transaction . commit () Warning MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled. Source code in odmantic/engine.py 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 def transaction ( self ) -> SyncTransaction : \"\"\"Get a new transaction for the engine to aggregate sequential operations. Returns: a new transaction object Example usage: ```python engine = SyncEngine(...) with engine.transaction() as transaction: john = transaction.find(User, User.name == \"John\") john.name = \"Doe\" transaction.save(john) transaction.commit() ``` Warning: MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled. \"\"\" return SyncTransaction ( self )","title":"transaction()"},{"location":"api_reference/engine/#odmantic.engine.SyncCursor","text":"Bases: BaseCursor [ ModelType ] , Iterable [ ModelType ] This object has to be built from the odmantic.engine.SyncEngine.find method. A SyncCursor object supports iterating over the query results using for . To get a list of all the results you can wrap it with list , as in list(cursor) . Source code in odmantic/engine.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 class SyncCursor ( BaseCursor [ ModelType ], Iterable [ ModelType ]): \"\"\"This object has to be built from the [odmantic.engine.SyncEngine.find][] method. A SyncCursor object supports iterating over the query results using **`for`**. To get a list of all the results you can wrap it with `list`, as in `list(cursor)`. \"\"\" _cursor : \"CommandCursor\" def __init__ ( self , model : Type [ ModelType ], cursor : \"CommandCursor\" ): super () . __init__ ( model = model , cursor = cursor ) def __iter__ ( self ) -> Iterator [ ModelType ]: if self . _results is not None : for res in self . _results : yield res return results = [] for raw_doc in self . _cursor : instance = self . _parse_document ( raw_doc ) results . append ( instance ) yield instance self . _results = results","title":"SyncCursor"},{"location":"api_reference/exceptions/","text":"odmantic.exceptions.BaseEngineException \u00b6 Bases: Exception Base Exception raised by the engine while operating with the database. Source code in odmantic/exceptions.py 13 14 15 16 17 18 class BaseEngineException ( Exception , metaclass = ABCMeta ): \"\"\"Base Exception raised by the engine while operating with the database.\"\"\" def __init__ ( self , message : str , model : Type [ \"Model\" ]): self . model : Type [ \"Model\" ] = model super () . __init__ ( message ) odmantic.exceptions.DocumentNotFoundError \u00b6 Bases: BaseEngineException The targetted document has not been found by the engine. Attributes: Name Type Description instance Model the instance that has not been found Source code in odmantic/exceptions.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class DocumentNotFoundError ( BaseEngineException ): \"\"\"The targetted document has not been found by the engine. Attributes: instance: the instance that has not been found \"\"\" def __init__ ( self , instance : \"Model\" ): self . instance : \"Model\" = instance super () . __init__ ( f \"Document not found for : { type ( instance ) . __name__ } . \" f \"Instance: { self . instance } \" , type ( instance ), ) odmantic.exceptions.DocumentParsingError \u00b6 Bases: ValidationError Unable to parse the document into an instance. Inherits from the ValidationError defined by Pydantic. Attributes: Name Type Description model Union [ Type [ Model ], Type [ EmbeddedModel ]] model which could not be instanciated Source code in odmantic/exceptions.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 class DocumentParsingError ( ValidationError ): \"\"\"Unable to parse the document into an instance. Inherits from the `ValidationError` defined by Pydantic. Attributes: model (Union[Type[Model],Type[EmbeddedModel]]): model which could not be instanciated \"\"\" def __init__ ( self , errors : Sequence [ ErrorList ], model : Type [ \"_BaseODMModel\" ], primary_value : Any , ): super () . __init__ ( errors , model ) self . model : Union [ Type [ \"Model\" ], Type [ \"EmbeddedModel\" ]] self . primary_value = primary_value def __str__ ( self ) -> str : from odmantic import Model if issubclass ( self . model , Model ): return ( f \" { super () . __str__ () } \\n \" f \"( { self . model . __name__ } instance details:\" f \" { self . model . __primary_field__ } = { repr ( self . primary_value ) } )\" ) return super () . __str__ () odmantic.exceptions.DuplicateKeyError \u00b6 Bases: BaseEngineException The targetted document is duplicated according to a unique index. Attributes: Name Type Description instance Model the instance that has not been found driver_error the original driver error Source code in odmantic/exceptions.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class DuplicateKeyError ( BaseEngineException ): \"\"\"The targetted document is duplicated according to a unique index. Attributes: instance: the instance that has not been found driver_error: the original driver error \"\"\" def __init__ ( self , instance : \"Model\" , driver_error : pymongo . errors . DuplicateKeyError ): self . instance : \"Model\" = instance self . driver_error = driver_error super () . __init__ ( f \"Duplicate key error for: { type ( instance ) . __name__ } . \" f \"Instance: { self . instance } \" f \"Driver error: { self . driver_error } \" , type ( instance ), )","title":"odmantic.exceptions"},{"location":"api_reference/exceptions/#odmantic.exceptions.BaseEngineException","text":"Bases: Exception Base Exception raised by the engine while operating with the database. Source code in odmantic/exceptions.py 13 14 15 16 17 18 class BaseEngineException ( Exception , metaclass = ABCMeta ): \"\"\"Base Exception raised by the engine while operating with the database.\"\"\" def __init__ ( self , message : str , model : Type [ \"Model\" ]): self . model : Type [ \"Model\" ] = model super () . __init__ ( message )","title":"BaseEngineException"},{"location":"api_reference/exceptions/#odmantic.exceptions.DocumentNotFoundError","text":"Bases: BaseEngineException The targetted document has not been found by the engine. Attributes: Name Type Description instance Model the instance that has not been found Source code in odmantic/exceptions.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class DocumentNotFoundError ( BaseEngineException ): \"\"\"The targetted document has not been found by the engine. Attributes: instance: the instance that has not been found \"\"\" def __init__ ( self , instance : \"Model\" ): self . instance : \"Model\" = instance super () . __init__ ( f \"Document not found for : { type ( instance ) . __name__ } . \" f \"Instance: { self . instance } \" , type ( instance ), )","title":"DocumentNotFoundError"},{"location":"api_reference/exceptions/#odmantic.exceptions.DocumentParsingError","text":"Bases: ValidationError Unable to parse the document into an instance. Inherits from the ValidationError defined by Pydantic. Attributes: Name Type Description model Union [ Type [ Model ], Type [ EmbeddedModel ]] model which could not be instanciated Source code in odmantic/exceptions.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 class DocumentParsingError ( ValidationError ): \"\"\"Unable to parse the document into an instance. Inherits from the `ValidationError` defined by Pydantic. Attributes: model (Union[Type[Model],Type[EmbeddedModel]]): model which could not be instanciated \"\"\" def __init__ ( self , errors : Sequence [ ErrorList ], model : Type [ \"_BaseODMModel\" ], primary_value : Any , ): super () . __init__ ( errors , model ) self . model : Union [ Type [ \"Model\" ], Type [ \"EmbeddedModel\" ]] self . primary_value = primary_value def __str__ ( self ) -> str : from odmantic import Model if issubclass ( self . model , Model ): return ( f \" { super () . __str__ () } \\n \" f \"( { self . model . __name__ } instance details:\" f \" { self . model . __primary_field__ } = { repr ( self . primary_value ) } )\" ) return super () . __str__ ()","title":"DocumentParsingError"},{"location":"api_reference/exceptions/#odmantic.exceptions.DuplicateKeyError","text":"Bases: BaseEngineException The targetted document is duplicated according to a unique index. Attributes: Name Type Description instance Model the instance that has not been found driver_error the original driver error Source code in odmantic/exceptions.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class DuplicateKeyError ( BaseEngineException ): \"\"\"The targetted document is duplicated according to a unique index. Attributes: instance: the instance that has not been found driver_error: the original driver error \"\"\" def __init__ ( self , instance : \"Model\" , driver_error : pymongo . errors . DuplicateKeyError ): self . instance : \"Model\" = instance self . driver_error = driver_error super () . __init__ ( f \"Duplicate key error for: { type ( instance ) . __name__ } . \" f \"Instance: { self . instance } \" f \"Driver error: { self . driver_error } \" , type ( instance ), )","title":"DuplicateKeyError"},{"location":"api_reference/fastapi/","text":"odmantic.fastapi.AIOEngineDependency \u00b6 Bases: fastapi . params . Depends AIOEngine FastAPI Dependency. Warning Deprecated since v0.2.0, more details . Internally caches the AIOEngine instance to avoid creating a new client on each request. Sample usage: app = FastAPI () EngineD = AIOEngineDependency () @app . get ( \"/\" ) async def get ( engine : AIOEngine = EngineD ): await engine . find ( ... ) await engine . save ( ... ) Source code in odmantic/fastapi.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class AIOEngineDependency ( fastapi . params . Depends ): \"\"\"AIOEngine FastAPI Dependency. Warning: Deprecated since v0.2.0, [more details](https://art049.github.io/odmantic/usage_fastapi/#building-the-engine). Internally caches the AIOEngine instance to avoid creating a new client on each request. Sample usage: ```python app = FastAPI() EngineD = AIOEngineDependency() @app.get(\"/\") async def get(engine: AIOEngine = EngineD): await engine.find(...) await engine.save(...) ``` \"\"\" def __init__ ( self , mongo_uri : Optional [ str ] = None , database : str = \"test\" ) -> None : \"\"\"Dependency initializer for AIOEngine. Args: mongo_uri: mongo_uri that should be used for creating the motor client database: database to use \"\"\" super () . __init__ ( dependency = self ) self . mongo_uri = mongo_uri self . database = database self . engine : Optional [ AIOEngine ] = None warnings . warn ( \"the AIOEngineDependency object is deprecated, see \" \"https://art049.github.io/odmantic/usage_fastapi/#building-the-engine \" \"for more details.\" , DeprecationWarning , ) async def __call__ ( self ) -> AIOEngine : if self . engine is None : motor_client = None if self . mongo_uri is not None : motor_client = AsyncIOMotorClient ( self . mongo_uri ) self . engine = AIOEngine ( motor_client , self . database ) return self . engine __init__ ( mongo_uri = None , database = 'test' ) \u00b6 Dependency initializer for AIOEngine. Parameters: Name Type Description Default mongo_uri Optional [ str ] mongo_uri that should be used for creating the motor client None database str database to use 'test' Source code in odmantic/fastapi.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __init__ ( self , mongo_uri : Optional [ str ] = None , database : str = \"test\" ) -> None : \"\"\"Dependency initializer for AIOEngine. Args: mongo_uri: mongo_uri that should be used for creating the motor client database: database to use \"\"\" super () . __init__ ( dependency = self ) self . mongo_uri = mongo_uri self . database = database self . engine : Optional [ AIOEngine ] = None warnings . warn ( \"the AIOEngineDependency object is deprecated, see \" \"https://art049.github.io/odmantic/usage_fastapi/#building-the-engine \" \"for more details.\" , DeprecationWarning , )","title":"odmantic.fastapi"},{"location":"api_reference/fastapi/#odmantic.fastapi.AIOEngineDependency","text":"Bases: fastapi . params . Depends AIOEngine FastAPI Dependency. Warning Deprecated since v0.2.0, more details . Internally caches the AIOEngine instance to avoid creating a new client on each request. Sample usage: app = FastAPI () EngineD = AIOEngineDependency () @app . get ( \"/\" ) async def get ( engine : AIOEngine = EngineD ): await engine . find ( ... ) await engine . save ( ... ) Source code in odmantic/fastapi.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class AIOEngineDependency ( fastapi . params . Depends ): \"\"\"AIOEngine FastAPI Dependency. Warning: Deprecated since v0.2.0, [more details](https://art049.github.io/odmantic/usage_fastapi/#building-the-engine). Internally caches the AIOEngine instance to avoid creating a new client on each request. Sample usage: ```python app = FastAPI() EngineD = AIOEngineDependency() @app.get(\"/\") async def get(engine: AIOEngine = EngineD): await engine.find(...) await engine.save(...) ``` \"\"\" def __init__ ( self , mongo_uri : Optional [ str ] = None , database : str = \"test\" ) -> None : \"\"\"Dependency initializer for AIOEngine. Args: mongo_uri: mongo_uri that should be used for creating the motor client database: database to use \"\"\" super () . __init__ ( dependency = self ) self . mongo_uri = mongo_uri self . database = database self . engine : Optional [ AIOEngine ] = None warnings . warn ( \"the AIOEngineDependency object is deprecated, see \" \"https://art049.github.io/odmantic/usage_fastapi/#building-the-engine \" \"for more details.\" , DeprecationWarning , ) async def __call__ ( self ) -> AIOEngine : if self . engine is None : motor_client = None if self . mongo_uri is not None : motor_client = AsyncIOMotorClient ( self . mongo_uri ) self . engine = AIOEngine ( motor_client , self . database ) return self . engine","title":"AIOEngineDependency"},{"location":"api_reference/fastapi/#odmantic.fastapi.AIOEngineDependency.__init__","text":"Dependency initializer for AIOEngine. Parameters: Name Type Description Default mongo_uri Optional [ str ] mongo_uri that should be used for creating the motor client None database str database to use 'test' Source code in odmantic/fastapi.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __init__ ( self , mongo_uri : Optional [ str ] = None , database : str = \"test\" ) -> None : \"\"\"Dependency initializer for AIOEngine. Args: mongo_uri: mongo_uri that should be used for creating the motor client database: database to use \"\"\" super () . __init__ ( dependency = self ) self . mongo_uri = mongo_uri self . database = database self . engine : Optional [ AIOEngine ] = None warnings . warn ( \"the AIOEngineDependency object is deprecated, see \" \"https://art049.github.io/odmantic/usage_fastapi/#building-the-engine \" \"for more details.\" , DeprecationWarning , )","title":"__init__()"},{"location":"api_reference/field/","text":"odmantic . field . Field ( default = Undefined , * , key_name = None , primary_field = False , index = False , unique = False , default_factory = None , title = None , description = None , const = None , gt = None , ge = None , lt = None , le = None , multiple_of = None , min_items = None , max_items = None , min_length = None , max_length = None , regex = None , ** extra ) \u00b6 Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields ( int , float , Decimal ) and some apply only to str . Tip The main additions of ODMantic to the regular pydantic Field are the key_name , index , unique and the primary_field options. Warning If both default and default_factory are set, an error is raised. Warning primary_field can't be used along with key_name since the key_name will be set to _id . Parameters: Name Type Description Default default Any since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis ( ... ) to indicate the field has no default value Undefined key_name Optional [ str ] the name to use in the the mongo document structure None primary_field bool this field should be considered as a primary key. False index bool this field should be considered as an index False unique bool this field should be considered as a unique index False default_factory Optional [ NoArgAnyCallable ] callable that will be called when a default value is needed for this field. None title Optional [ str ] can be any string, used in the schema None description Optional [ str ] can be any string, used in the schema None const Optional [ bool ] this field is required and must take it's default value None gt Optional [ float ] only applies to numbers, requires the field to be \"greater than\". The schema will have an exclusiveMinimum validation keyword None ge Optional [ float ] only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a minimum validation keyword None lt Optional [ float ] only applies to numbers, requires the field to be \"less than\". The schema will have an exclusiveMaximum validation keyword None le Optional [ float ] only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a maximum validation keyword None multiple_of Optional [ float ] only applies to numbers, requires the field to be \"a multiple of \". The schema will have a multipleOf validation keyword None min_items Optional [ int ] only applies to sequences, requires the field to have a minimum item count. None max_items Optional [ int ] only applies to sequences, requires the field to have a maximum item count. None min_length Optional [ int ] only applies to strings, requires the field to have a minimum length. The schema will have a maximum validation keyword None max_length Optional [ int ] only applies to strings, requires the field to have a maximum length. The schema will have a maxLength validation keyword None regex Optional [ str ] only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a pattern validation keyword None **extra Any any additional keyword arguments will be added as is to the schema {} Source code in odmantic/field.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def Field ( default : Any = Undefined , * , key_name : Optional [ str ] = None , primary_field : bool = False , index : bool = False , unique : bool = False , default_factory : Optional [ NoArgAnyCallable ] = None , # alias: str = None, # FIXME not supported yet title : Optional [ str ] = None , description : Optional [ str ] = None , const : Optional [ bool ] = None , gt : Optional [ float ] = None , ge : Optional [ float ] = None , lt : Optional [ float ] = None , le : Optional [ float ] = None , multiple_of : Optional [ float ] = None , min_items : Optional [ int ] = None , max_items : Optional [ int ] = None , min_length : Optional [ int ] = None , max_length : Optional [ int ] = None , regex : Optional [ str ] = None , ** extra : Any , ) -> Any : \"\"\"Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str``. Tip: The main additions of ODMantic to the regular pydantic `Field` are the `key_name`, `index`, `unique` and the `primary_field` options. Warning: If both `default` and `default_factory` are set, an error is raised. Warning: `primary_field` can't be used along with `key_name` since the key_name will be set to `_id`. Args: default: since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis (``...``) to indicate the field has no default value key_name: the name to use in the the mongo document structure primary_field: this field should be considered as a primary key. index: this field should be considered as an index unique: this field should be considered as a unique index default_factory: callable that will be called when a default value is needed for this field. title: can be any string, used in the schema description: can be any string, used in the schema const: this field is required and *must* take it's default value gt: only applies to numbers, requires the field to be \"greater than\". The schema will have an ``exclusiveMinimum`` validation keyword ge: only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a ``minimum`` validation keyword lt: only applies to numbers, requires the field to be \"less than\". The schema will have an ``exclusiveMaximum`` validation keyword le: only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a ``maximum`` validation keyword multiple_of: only applies to numbers, requires the field to be \"a multiple of \". The schema will have a ``multipleOf`` validation keyword min_items: only applies to sequences, requires the field to have a minimum item count. max_items: only applies to sequences, requires the field to have a maximum item count. min_length: only applies to strings, requires the field to have a minimum length. The schema will have a ``maximum`` validation keyword max_length: only applies to strings, requires the field to have a maximum length. The schema will have a ``maxLength`` validation keyword regex: only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a ``pattern`` validation keyword **extra: any additional keyword arguments will be added as is to the schema <!--- # noqa: DAR201 # noqa: DAR003 # noqa: DAR401 # noqa: DAR101 --> \"\"\" # Perform casts on optional fields to avoid incompatibility due to the strict # optional mypy setting pydantic_field = PDField ( default , default_factory = default_factory , # alias=alias, # FIXME check aliases compatibility title = cast ( str , title ), description = cast ( str , description ), const = cast ( bool , const ), gt = cast ( float , gt ), ge = cast ( float , ge ), lt = cast ( float , lt ), le = cast ( float , le ), multiple_of = cast ( float , multiple_of ), min_items = cast ( int , min_items ), max_items = cast ( int , max_items ), min_length = cast ( int , min_length ), max_length = cast ( int , max_length ), regex = cast ( str , regex ), ** extra , ) if primary_field : if key_name is not None and key_name != \"_id\" : raise ValueError ( \"cannot specify a primary field with a custom key_name,\" \"key_name='_id' enforced\" ) else : key_name = \"_id\" elif key_name == \"_id\" : raise ValueError ( \"cannot specify key_name='_id' without defining the field as primary\" ) return ODMFieldInfo ( pydantic_field_info = pydantic_field , primary_field = primary_field , key_name = key_name , index = index , unique = unique , )","title":"odmantic.field"},{"location":"api_reference/field/#odmantic.field.Field","text":"Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields ( int , float , Decimal ) and some apply only to str . Tip The main additions of ODMantic to the regular pydantic Field are the key_name , index , unique and the primary_field options. Warning If both default and default_factory are set, an error is raised. Warning primary_field can't be used along with key_name since the key_name will be set to _id . Parameters: Name Type Description Default default Any since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis ( ... ) to indicate the field has no default value Undefined key_name Optional [ str ] the name to use in the the mongo document structure None primary_field bool this field should be considered as a primary key. False index bool this field should be considered as an index False unique bool this field should be considered as a unique index False default_factory Optional [ NoArgAnyCallable ] callable that will be called when a default value is needed for this field. None title Optional [ str ] can be any string, used in the schema None description Optional [ str ] can be any string, used in the schema None const Optional [ bool ] this field is required and must take it's default value None gt Optional [ float ] only applies to numbers, requires the field to be \"greater than\". The schema will have an exclusiveMinimum validation keyword None ge Optional [ float ] only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a minimum validation keyword None lt Optional [ float ] only applies to numbers, requires the field to be \"less than\". The schema will have an exclusiveMaximum validation keyword None le Optional [ float ] only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a maximum validation keyword None multiple_of Optional [ float ] only applies to numbers, requires the field to be \"a multiple of \". The schema will have a multipleOf validation keyword None min_items Optional [ int ] only applies to sequences, requires the field to have a minimum item count. None max_items Optional [ int ] only applies to sequences, requires the field to have a maximum item count. None min_length Optional [ int ] only applies to strings, requires the field to have a minimum length. The schema will have a maximum validation keyword None max_length Optional [ int ] only applies to strings, requires the field to have a maximum length. The schema will have a maxLength validation keyword None regex Optional [ str ] only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a pattern validation keyword None **extra Any any additional keyword arguments will be added as is to the schema {} Source code in odmantic/field.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def Field ( default : Any = Undefined , * , key_name : Optional [ str ] = None , primary_field : bool = False , index : bool = False , unique : bool = False , default_factory : Optional [ NoArgAnyCallable ] = None , # alias: str = None, # FIXME not supported yet title : Optional [ str ] = None , description : Optional [ str ] = None , const : Optional [ bool ] = None , gt : Optional [ float ] = None , ge : Optional [ float ] = None , lt : Optional [ float ] = None , le : Optional [ float ] = None , multiple_of : Optional [ float ] = None , min_items : Optional [ int ] = None , max_items : Optional [ int ] = None , min_length : Optional [ int ] = None , max_length : Optional [ int ] = None , regex : Optional [ str ] = None , ** extra : Any , ) -> Any : \"\"\"Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str``. Tip: The main additions of ODMantic to the regular pydantic `Field` are the `key_name`, `index`, `unique` and the `primary_field` options. Warning: If both `default` and `default_factory` are set, an error is raised. Warning: `primary_field` can't be used along with `key_name` since the key_name will be set to `_id`. Args: default: since this is replacing the field\u2019s default, its first argument is used to set the default, use ellipsis (``...``) to indicate the field has no default value key_name: the name to use in the the mongo document structure primary_field: this field should be considered as a primary key. index: this field should be considered as an index unique: this field should be considered as a unique index default_factory: callable that will be called when a default value is needed for this field. title: can be any string, used in the schema description: can be any string, used in the schema const: this field is required and *must* take it's default value gt: only applies to numbers, requires the field to be \"greater than\". The schema will have an ``exclusiveMinimum`` validation keyword ge: only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a ``minimum`` validation keyword lt: only applies to numbers, requires the field to be \"less than\". The schema will have an ``exclusiveMaximum`` validation keyword le: only applies to numbers, requires the field to be \"less than or equal to\" . The schema will have a ``maximum`` validation keyword multiple_of: only applies to numbers, requires the field to be \"a multiple of \". The schema will have a ``multipleOf`` validation keyword min_items: only applies to sequences, requires the field to have a minimum item count. max_items: only applies to sequences, requires the field to have a maximum item count. min_length: only applies to strings, requires the field to have a minimum length. The schema will have a ``maximum`` validation keyword max_length: only applies to strings, requires the field to have a maximum length. The schema will have a ``maxLength`` validation keyword regex: only applies to strings, requires the field match agains a regular expression pattern string. The schema will have a ``pattern`` validation keyword **extra: any additional keyword arguments will be added as is to the schema <!--- # noqa: DAR201 # noqa: DAR003 # noqa: DAR401 # noqa: DAR101 --> \"\"\" # Perform casts on optional fields to avoid incompatibility due to the strict # optional mypy setting pydantic_field = PDField ( default , default_factory = default_factory , # alias=alias, # FIXME check aliases compatibility title = cast ( str , title ), description = cast ( str , description ), const = cast ( bool , const ), gt = cast ( float , gt ), ge = cast ( float , ge ), lt = cast ( float , lt ), le = cast ( float , le ), multiple_of = cast ( float , multiple_of ), min_items = cast ( int , min_items ), max_items = cast ( int , max_items ), min_length = cast ( int , min_length ), max_length = cast ( int , max_length ), regex = cast ( str , regex ), ** extra , ) if primary_field : if key_name is not None and key_name != \"_id\" : raise ValueError ( \"cannot specify a primary field with a custom key_name,\" \"key_name='_id' enforced\" ) else : key_name = \"_id\" elif key_name == \"_id\" : raise ValueError ( \"cannot specify key_name='_id' without defining the field as primary\" ) return ODMFieldInfo ( pydantic_field_info = pydantic_field , primary_field = primary_field , key_name = key_name , index = index , unique = unique , )","title":"Field()"},{"location":"api_reference/model/","text":"odmantic.model._BaseODMModel \u00b6 Bases: pydantic . BaseModel Base class for Model and EmbeddedModel . Warning This internal class should never be instanciated directly. Source code in odmantic/model.py 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 class _BaseODMModel ( pydantic . BaseModel , metaclass = ABCMeta ): \"\"\"Base class for [Model][odmantic.model.Model] and [EmbeddedModel][odmantic.model.EmbeddedModel]. !!! warning This internal class should never be instanciated directly. \"\"\" if TYPE_CHECKING : __odm_fields__ : ClassVar [ Dict [ str , ODMBaseField ]] = {} __bson_serialized_fields__ : ClassVar [ FrozenSet [ str ]] = frozenset () __mutable_fields__ : ClassVar [ FrozenSet [ str ]] = frozenset () __references__ : ClassVar [ Tuple [ str , ... ]] = () __pydantic_model__ : ClassVar [ Type [ BaseBSONModel ]] # __fields_modified__ is not a ClassVar but this allows to hide this field from # the dataclass transform generated constructor __fields_modified__ : ClassVar [ Set [ str ]] = set () __slots__ = ( \"__fields_modified__\" ,) def __init__ ( self , ** data : Any ): super () . __init__ ( ** data ) object . __setattr__ ( self , \"__fields_modified__\" , set ( self . __odm_fields__ . keys ())) @classmethod def validate ( cls : Type [ BaseT ], value : Any ) -> BaseT : if isinstance ( value , cls ): # Do not copy the object as done in pydantic # This enable to keep the same python object return value return super () . validate ( value ) def __repr_args__ ( self ) -> \"ReprArgs\" : # Place the id field first in the repr string args = list ( super () . __repr_args__ ()) id_arg = next (( arg for arg in args if arg [ 0 ] == \"id\" ), None ) if id_arg is None : return args args . remove ( id_arg ) args = [ id_arg ] + args return args def copy ( self : BaseT , * , include : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , update : Optional [ \"DictStrAny\" ] = None , deep : bool = False , ) -> BaseT : \"\"\"Duplicate a model, optionally choose which fields to include, exclude and change. Danger: The data is not validated before creating the new model: **you should trust this data**. Arguments: include: fields to include in new model exclude: fields to exclude from new model, as with values this takes precedence over include update: values to change/add in the new model. deep: set to `True` to make a deep copy of the model Note: The `include` and `exclude` kwargs are only affecting the copied data, not filtering the update object. Returns: new model instance \"\"\" copied = super () . copy ( include = include , exclude = exclude , update = update , deep = deep # type: ignore ) copied . _post_copy_update () return copied def _post_copy_update ( self : BaseT ) -> None : \"\"\"Recursively update internal fields of the copied model after it has been copied. \"\"\" object . __setattr__ ( self , \"__fields_modified__\" , set ( self . __fields__ )) for field_name , field in self . __odm_fields__ . items (): if isinstance ( field , ODMEmbedded ): value = getattr ( self , field_name ) value . _post_copy_update () def update ( self , patch_object : Union [ BaseModel , Dict [ str , Any ]], * , include : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude_unset : bool = True , exclude_defaults : bool = False , exclude_none : bool = False , ) -> None : \"\"\"Update instance fields from a Pydantic model or a dictionary. If a pydantic model is provided, only the **fields set** will be applied by default. Args: patch_object: object containing the values to update include: fields to include from the `patch_object` (include all fields if `None`) exclude: fields to exclude from the `patch_object`, this takes precedence over include exclude_unset: only update fields explicitly set in the patch object (only applies to Pydantic models) exclude_defaults: only update fields that are different from their default value in the patch object (only applies to Pydantic models) exclude_none: only update fields different from None in the patch object (only applies to Pydantic models) Raises: ValidationError: the modifications would make the instance invalid <!-- #noqa: DAR402 ValidationError --> \"\"\" if isinstance ( patch_object , BaseModel ): patch_dict = patch_object . dict ( include = include , # type: ignore exclude = exclude , # type: ignore exclude_unset = exclude_unset , exclude_defaults = exclude_defaults , exclude_none = exclude_none , ) else : odm_fields = set ( self . __odm_fields__ . keys ()) patch_dict = {} for k , v in patch_object . items (): if include is not None and k not in include : continue if exclude is not None and k in exclude : continue if k not in odm_fields : continue patch_dict [ k ] = v patched_instance_dict = { ** self . dict (), ** patch_dict } # FIXME: improve performance by only running updated field validators and then # model validators patched_instance = self . validate ( patched_instance_dict ) for name , new_value in patched_instance . __dict__ . items (): if self . __dict__ [ name ] != new_value : # Manually change the field to avoid running the validators again self . __dict__ [ name ] = new_value self . __fields_set__ . add ( name ) self . __fields_modified__ . add ( name ) def __setattr__ ( self , name : str , value : Any ) -> None : super () . __setattr__ ( name , value ) self . __fields_modified__ . add ( name ) def dict ( # type: ignore # Missing deprecated/ unsupported parameters self , * , include : Union [ \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , # type: ignore exclude : Union [ \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , # type: ignore exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , by_alias : bool = False , # FIXME when aliases are supported ) -> \"DictStrAny\" : \"\"\"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Args: include: fields to include (include all fields if `None`) exclude: fields to exclude this takes precedence over include exclude_unset: only include fields explicitly set exclude_defaults: only include fields that are different from their default value exclude_none: only include fields different from `None` by_alias: **not supported yet** Returns: the dictionary representation of the instance \"\"\" return super () . dict ( include = include , exclude = exclude , exclude_unset = exclude_unset , exclude_defaults = exclude_defaults , exclude_none = exclude_none , ) def __doc ( self , raw_doc : Dict [ str , Any ], model : Type [ \"_BaseODMModel\" ], include : Optional [ \"AbstractSetIntStr\" ] = None , ) -> Dict [ str , Any ]: doc : Dict [ str , Any ] = {} for field_name , field in model . __odm_fields__ . items (): if include is not None and field_name not in include : continue if isinstance ( field , ODMReference ): doc [ field . key_name ] = raw_doc [ field_name ][ field . model . __primary_field__ ] elif isinstance ( field , ODMEmbedded ): doc [ field . key_name ] = self . __doc ( raw_doc [ field_name ], field . model , None ) elif isinstance ( field , ODMEmbeddedGeneric ): if field . generic_origin is dict : doc [ field . key_name ] = { item_key : self . __doc ( item_value , field . model ) for item_key , item_value in raw_doc [ field_name ] . items () } else : doc [ field . key_name ] = [ self . __doc ( item , field . model ) for item in raw_doc [ field_name ] ] elif field_name in model . __bson_serialized_fields__ : doc [ field . key_name ] = model . __fields__ [ field_name ] . type_ . __bson__ ( raw_doc [ field_name ] ) else : doc [ field . key_name ] = raw_doc [ field_name ] if model . Config . extra == \"allow\" : extras = set ( raw_doc . keys ()) - set ( model . __odm_fields__ . keys ()) for extra in extras : value = raw_doc [ extra ] subst_type = validate_type ( type ( value )) bson_serialization_method = getattr ( subst_type , \"__bson__\" , lambda x : x ) doc [ extra ] = bson_serialization_method ( raw_doc [ extra ]) return doc def doc ( self , include : Optional [ \"AbstractSetIntStr\" ] = None ) -> Dict [ str , Any ]: \"\"\"Generate a document representation of the instance (as a dictionary). Args: include: field that should be included; if None, every fields will be included Returns: the document associated to the instance \"\"\" raw_doc = self . dict () doc = self . __doc ( raw_doc , type ( self ), include ) return doc @classmethod def parse_doc ( cls : Type [ BaseT ], raw_doc : Dict ) -> BaseT : \"\"\"Parse a BSON document into an instance of the Model Args: raw_doc: document to parse (as Dict) Raises: DocumentParsingError: the specified document is invalid Returns: an instance of the Model class this method is called on. \"\"\" errors , obj = cls . _parse_doc_to_obj ( raw_doc ) if len ( errors ) > 0 : raise DocumentParsingError ( errors = [ errors ], model = cls , primary_value = raw_doc . get ( \"_id\" , \"<unknown>\" ), ) try : instance = cls . parse_obj ( obj ) except ValidationError as e : raise DocumentParsingError ( errors = e . raw_errors , # type: ignore model = cls , primary_value = raw_doc . get ( \"_id\" , \"<unknown>\" ), ) return instance @classmethod def _parse_doc_to_obj ( # noqa C901 # TODO: refactor document parsing cls : Type [ BaseT ], raw_doc : Dict , base_loc : Tuple [ str , ... ] = () ) -> Tuple [ ErrorList , Dict [ str , Any ]]: errors : ErrorList = [] obj : Dict [ str , Any ] = {} for field_name , field in cls . __odm_fields__ . items (): if isinstance ( field , ODMReference ): sub_doc = raw_doc . get ( field . key_name ) if sub_doc is None : errors . append ( ErrorWrapper ( exc = ReferencedDocumentNotFoundError ( field . key_name ), loc = base_loc + ( field_name ,), ) ) else : sub_errors , sub_obj = field . model . _parse_doc_to_obj ( sub_doc , base_loc = base_loc + ( field_name ,) ) errors . extend ( sub_errors ) obj [ field_name ] = sub_obj elif isinstance ( field , ODMEmbedded ): value = raw_doc . get ( field . key_name , Undefined ) if value is not Undefined : sub_errors , value = field . model . _parse_doc_to_obj ( value , base_loc = base_loc + ( field_name ,) ) errors . extend ( sub_errors ) else : if not field . is_required_in_doc (): value = field . get_default_importing_value () if value is Undefined : errors . append ( ErrorWrapper ( exc = KeyNotFoundInDocumentError ( field . key_name ), loc = base_loc + ( field_name ,), ) ) obj [ field_name ] = value elif isinstance ( field , ODMEmbeddedGeneric ): value = Undefined raw_value = raw_doc . get ( field . key_name , Undefined ) if raw_value is not Undefined : if isinstance ( raw_value , list ) and ( field . generic_origin is list or field . generic_origin is tuple or field . generic_origin is set ): value = [] for i , item in enumerate ( raw_value ): sub_errors , item = field . model . _parse_doc_to_obj ( item , base_loc = base_loc + ( field_name , f \"[ { i } ]\" ) ) if len ( sub_errors ) > 0 : errors . extend ( sub_errors ) else : value . append ( item ) obj [ field_name ] = value elif isinstance ( raw_value , dict ) and field . generic_origin is dict : value = {} for item_key , item_value in raw_value . items (): sub_errors , item_value = field . model . _parse_doc_to_obj ( item_value , base_loc = base_loc + ( field_name , f '[\" { item_key } \"]' ), ) if len ( sub_errors ) > 0 : errors . extend ( sub_errors ) else : value [ item_key ] = item_value obj [ field_name ] = value else : errors . append ( ErrorWrapper ( exc = IncorrectGenericEmbeddedModelValue ( raw_value ), loc = base_loc + ( field_name ,), ) ) else : if not field . is_required_in_doc (): value = field . get_default_importing_value () if value is Undefined : errors . append ( ErrorWrapper ( exc = KeyNotFoundInDocumentError ( field . key_name ), loc = base_loc + ( field_name ,), ) ) else : obj [ field_name ] = value else : field = cast ( ODMField , field ) value = raw_doc . get ( field . key_name , Undefined ) if value is Undefined and not field . is_required_in_doc (): value = field . get_default_importing_value () if value is Undefined : errors . append ( ErrorWrapper ( exc = KeyNotFoundInDocumentError ( field . key_name ), loc = base_loc + ( field_name ,), ) ) else : obj [ field_name ] = value if cls . Config . extra == \"allow\" : extras = set ( raw_doc . keys ()) - set ( obj . keys ()) for extra in extras : obj [ extra ] = raw_doc [ extra ] return errors , obj parse_doc ( raw_doc ) classmethod \u00b6 Parse a BSON document into an instance of the Model Parameters: Name Type Description Default raw_doc Dict document to parse (as Dict) required Raises: Type Description DocumentParsingError the specified document is invalid Returns: Type Description BaseT an instance of the Model class this method is called on. Source code in odmantic/model.py 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 @classmethod def parse_doc ( cls : Type [ BaseT ], raw_doc : Dict ) -> BaseT : \"\"\"Parse a BSON document into an instance of the Model Args: raw_doc: document to parse (as Dict) Raises: DocumentParsingError: the specified document is invalid Returns: an instance of the Model class this method is called on. \"\"\" errors , obj = cls . _parse_doc_to_obj ( raw_doc ) if len ( errors ) > 0 : raise DocumentParsingError ( errors = [ errors ], model = cls , primary_value = raw_doc . get ( \"_id\" , \"<unknown>\" ), ) try : instance = cls . parse_obj ( obj ) except ValidationError as e : raise DocumentParsingError ( errors = e . raw_errors , # type: ignore model = cls , primary_value = raw_doc . get ( \"_id\" , \"<unknown>\" ), ) return instance doc ( include = None ) \u00b6 Generate a document representation of the instance (as a dictionary). Parameters: Name Type Description Default include Optional [ AbstractSetIntStr ] field that should be included; if None, every fields will be included None Returns: Type Description Dict [ str , Any ] the document associated to the instance Source code in odmantic/model.py 733 734 735 736 737 738 739 740 741 742 743 744 745 def doc ( self , include : Optional [ \"AbstractSetIntStr\" ] = None ) -> Dict [ str , Any ]: \"\"\"Generate a document representation of the instance (as a dictionary). Args: include: field that should be included; if None, every fields will be included Returns: the document associated to the instance \"\"\" raw_doc = self . dict () doc = self . __doc ( raw_doc , type ( self ), include ) return doc update ( patch_object , * , include = None , exclude = None , exclude_unset = True , exclude_defaults = False , exclude_none = False ) \u00b6 Update instance fields from a Pydantic model or a dictionary. If a pydantic model is provided, only the fields set will be applied by default. Parameters: Name Type Description Default patch_object Union [ BaseModel , Dict [ str , Any ]] object containing the values to update required include Union [None, AbstractSetIntStr , MappingIntStrAny ] fields to include from the patch_object (include all fields if None ) None exclude Union [None, AbstractSetIntStr , MappingIntStrAny ] fields to exclude from the patch_object , this takes precedence over include None exclude_unset bool only update fields explicitly set in the patch object (only applies to Pydantic models) True exclude_defaults bool only update fields that are different from their default value in the patch object (only applies to Pydantic models) False exclude_none bool only update fields different from None in the patch object (only applies to Pydantic models) False Raises: Type Description ValidationError the modifications would make the instance invalid Source code in odmantic/model.py 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 def update ( self , patch_object : Union [ BaseModel , Dict [ str , Any ]], * , include : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude_unset : bool = True , exclude_defaults : bool = False , exclude_none : bool = False , ) -> None : \"\"\"Update instance fields from a Pydantic model or a dictionary. If a pydantic model is provided, only the **fields set** will be applied by default. Args: patch_object: object containing the values to update include: fields to include from the `patch_object` (include all fields if `None`) exclude: fields to exclude from the `patch_object`, this takes precedence over include exclude_unset: only update fields explicitly set in the patch object (only applies to Pydantic models) exclude_defaults: only update fields that are different from their default value in the patch object (only applies to Pydantic models) exclude_none: only update fields different from None in the patch object (only applies to Pydantic models) Raises: ValidationError: the modifications would make the instance invalid <!-- #noqa: DAR402 ValidationError --> \"\"\" if isinstance ( patch_object , BaseModel ): patch_dict = patch_object . dict ( include = include , # type: ignore exclude = exclude , # type: ignore exclude_unset = exclude_unset , exclude_defaults = exclude_defaults , exclude_none = exclude_none , ) else : odm_fields = set ( self . __odm_fields__ . keys ()) patch_dict = {} for k , v in patch_object . items (): if include is not None and k not in include : continue if exclude is not None and k in exclude : continue if k not in odm_fields : continue patch_dict [ k ] = v patched_instance_dict = { ** self . dict (), ** patch_dict } # FIXME: improve performance by only running updated field validators and then # model validators patched_instance = self . validate ( patched_instance_dict ) for name , new_value in patched_instance . __dict__ . items (): if self . __dict__ [ name ] != new_value : # Manually change the field to avoid running the validators again self . __dict__ [ name ] = new_value self . __fields_set__ . add ( name ) self . __fields_modified__ . add ( name ) copy ( * , include = None , exclude = None , update = None , deep = False ) \u00b6 Duplicate a model, optionally choose which fields to include, exclude and change. Danger The data is not validated before creating the new model: you should trust this data . Parameters: Name Type Description Default include Union [None, AbstractSetIntStr , MappingIntStrAny ] fields to include in new model None exclude Union [None, AbstractSetIntStr , MappingIntStrAny ] fields to exclude from new model, as with values this takes precedence over include None update Optional [ DictStrAny ] values to change/add in the new model. None deep bool set to True to make a deep copy of the model False Note The include and exclude kwargs are only affecting the copied data, not filtering the update object. Returns: Type Description BaseT new model instance Source code in odmantic/model.py 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 def copy ( self : BaseT , * , include : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , update : Optional [ \"DictStrAny\" ] = None , deep : bool = False , ) -> BaseT : \"\"\"Duplicate a model, optionally choose which fields to include, exclude and change. Danger: The data is not validated before creating the new model: **you should trust this data**. Arguments: include: fields to include in new model exclude: fields to exclude from new model, as with values this takes precedence over include update: values to change/add in the new model. deep: set to `True` to make a deep copy of the model Note: The `include` and `exclude` kwargs are only affecting the copied data, not filtering the update object. Returns: new model instance \"\"\" copied = super () . copy ( include = include , exclude = exclude , update = update , deep = deep # type: ignore ) copied . _post_copy_update () return copied dict ( * , include = None , exclude = None , exclude_unset = False , exclude_defaults = False , exclude_none = False , by_alias = False ) \u00b6 Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Parameters: Name Type Description Default include Union [ AbstractSetIntStr , MappingIntStrAny ] fields to include (include all fields if None ) None exclude Union [ AbstractSetIntStr , MappingIntStrAny ] fields to exclude this takes precedence over include None exclude_unset bool only include fields explicitly set False exclude_defaults bool only include fields that are different from their default value False exclude_none bool only include fields different from None False by_alias bool not supported yet False Returns: Type Description DictStrAny the dictionary representation of the instance Source code in odmantic/model.py 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 def dict ( # type: ignore # Missing deprecated/ unsupported parameters self , * , include : Union [ \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , # type: ignore exclude : Union [ \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , # type: ignore exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , by_alias : bool = False , # FIXME when aliases are supported ) -> \"DictStrAny\" : \"\"\"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Args: include: fields to include (include all fields if `None`) exclude: fields to exclude this takes precedence over include exclude_unset: only include fields explicitly set exclude_defaults: only include fields that are different from their default value exclude_none: only include fields different from `None` by_alias: **not supported yet** Returns: the dictionary representation of the instance \"\"\" return super () . dict ( include = include , exclude = exclude , exclude_unset = exclude_unset , exclude_defaults = exclude_defaults , exclude_none = exclude_none , ) odmantic.model.Model \u00b6 Bases: _BaseODMModel Class that can be extended to create an ODMantic Model. Each model will be bound to a MongoDB collection. You can customize the collection name by setting the __collection__ class variable in the model classes. Source code in odmantic/model.py 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 class Model ( _BaseODMModel , metaclass = ModelMetaclass ): \"\"\"Class that can be extended to create an ODMantic Model. Each model will be bound to a MongoDB collection. You can customize the collection name by setting the `__collection__` class variable in the model classes. \"\"\" if TYPE_CHECKING : __collection__ : ClassVar [ str ] = \"\" __primary_field__ : ClassVar [ str ] = \"\" id : Union [ ObjectId , Any ] = Field ( init = False ) # TODO fix basic id field typing def __setattr__ ( self , name : str , value : Any ) -> None : if name == self . __primary_field__ : # TODO implement raise NotImplementedError ( \"Reassigning a new primary key is not supported yet\" ) super () . __setattr__ ( name , value ) @classmethod def __indexes__ ( cls ) -> Tuple [ Union [ ODMBaseIndex , pymongo . IndexModel ], ... ]: indexes : List [ Union [ ODMBaseIndex , pymongo . IndexModel ]] = [] for field in cls . __odm_fields__ . values (): if isinstance ( field , ODMBaseIndexableField ) and ( field . index or field . unique ): indexes . append ( ODMSingleFieldIndex ( key_name = field . key_name , unique = field . unique , ) ) for index in cast ( BaseODMConfig , cls . Config ) . indexes (): indexes . append ( index . to_odm_index () if isinstance ( index , Index ) else index ) return tuple ( indexes ) def update ( self , patch_object : Union [ BaseModel , Dict [ str , Any ]], * , include : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude_unset : bool = True , exclude_defaults : bool = False , exclude_none : bool = False , ) -> None : is_primary_field_in_patch = ( isinstance ( patch_object , BaseModel ) and self . __primary_field__ in patch_object . __fields__ ) or ( isinstance ( patch_object , dict ) and self . __primary_field__ in patch_object ) if is_primary_field_in_patch : if ( include is None and ( exclude is None or self . __primary_field__ not in exclude ) ) or ( include is not None and self . __primary_field__ in include and ( exclude is None or self . __primary_field__ not in exclude ) ): raise ValueError ( \"Updating the primary key is not supported. \" \"See the copy method if you want to modify the primary field.\" ) return super () . update ( patch_object , include = include , exclude = exclude , exclude_unset = exclude_unset , exclude_defaults = exclude_defaults , exclude_none = exclude_none , ) odmantic.model.EmbeddedModel \u00b6 Bases: _BaseODMModel Class that can be extended to create an ODMantic Embedded Model. An embedded document cannot be persisted directly to the database but should be integrated in a regular ODMantic Model. Source code in odmantic/model.py 968 969 970 971 972 973 class EmbeddedModel ( _BaseODMModel , metaclass = EmbeddedModelMetaclass ): \"\"\"Class that can be extended to create an ODMantic Embedded Model. An embedded document cannot be persisted directly to the database but should be integrated in a regular ODMantic Model. \"\"\"","title":"odmantic.model"},{"location":"api_reference/model/#odmantic.model._BaseODMModel","text":"Bases: pydantic . BaseModel Base class for Model and EmbeddedModel . Warning This internal class should never be instanciated directly. Source code in odmantic/model.py 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 class _BaseODMModel ( pydantic . BaseModel , metaclass = ABCMeta ): \"\"\"Base class for [Model][odmantic.model.Model] and [EmbeddedModel][odmantic.model.EmbeddedModel]. !!! warning This internal class should never be instanciated directly. \"\"\" if TYPE_CHECKING : __odm_fields__ : ClassVar [ Dict [ str , ODMBaseField ]] = {} __bson_serialized_fields__ : ClassVar [ FrozenSet [ str ]] = frozenset () __mutable_fields__ : ClassVar [ FrozenSet [ str ]] = frozenset () __references__ : ClassVar [ Tuple [ str , ... ]] = () __pydantic_model__ : ClassVar [ Type [ BaseBSONModel ]] # __fields_modified__ is not a ClassVar but this allows to hide this field from # the dataclass transform generated constructor __fields_modified__ : ClassVar [ Set [ str ]] = set () __slots__ = ( \"__fields_modified__\" ,) def __init__ ( self , ** data : Any ): super () . __init__ ( ** data ) object . __setattr__ ( self , \"__fields_modified__\" , set ( self . __odm_fields__ . keys ())) @classmethod def validate ( cls : Type [ BaseT ], value : Any ) -> BaseT : if isinstance ( value , cls ): # Do not copy the object as done in pydantic # This enable to keep the same python object return value return super () . validate ( value ) def __repr_args__ ( self ) -> \"ReprArgs\" : # Place the id field first in the repr string args = list ( super () . __repr_args__ ()) id_arg = next (( arg for arg in args if arg [ 0 ] == \"id\" ), None ) if id_arg is None : return args args . remove ( id_arg ) args = [ id_arg ] + args return args def copy ( self : BaseT , * , include : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , update : Optional [ \"DictStrAny\" ] = None , deep : bool = False , ) -> BaseT : \"\"\"Duplicate a model, optionally choose which fields to include, exclude and change. Danger: The data is not validated before creating the new model: **you should trust this data**. Arguments: include: fields to include in new model exclude: fields to exclude from new model, as with values this takes precedence over include update: values to change/add in the new model. deep: set to `True` to make a deep copy of the model Note: The `include` and `exclude` kwargs are only affecting the copied data, not filtering the update object. Returns: new model instance \"\"\" copied = super () . copy ( include = include , exclude = exclude , update = update , deep = deep # type: ignore ) copied . _post_copy_update () return copied def _post_copy_update ( self : BaseT ) -> None : \"\"\"Recursively update internal fields of the copied model after it has been copied. \"\"\" object . __setattr__ ( self , \"__fields_modified__\" , set ( self . __fields__ )) for field_name , field in self . __odm_fields__ . items (): if isinstance ( field , ODMEmbedded ): value = getattr ( self , field_name ) value . _post_copy_update () def update ( self , patch_object : Union [ BaseModel , Dict [ str , Any ]], * , include : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude_unset : bool = True , exclude_defaults : bool = False , exclude_none : bool = False , ) -> None : \"\"\"Update instance fields from a Pydantic model or a dictionary. If a pydantic model is provided, only the **fields set** will be applied by default. Args: patch_object: object containing the values to update include: fields to include from the `patch_object` (include all fields if `None`) exclude: fields to exclude from the `patch_object`, this takes precedence over include exclude_unset: only update fields explicitly set in the patch object (only applies to Pydantic models) exclude_defaults: only update fields that are different from their default value in the patch object (only applies to Pydantic models) exclude_none: only update fields different from None in the patch object (only applies to Pydantic models) Raises: ValidationError: the modifications would make the instance invalid <!-- #noqa: DAR402 ValidationError --> \"\"\" if isinstance ( patch_object , BaseModel ): patch_dict = patch_object . dict ( include = include , # type: ignore exclude = exclude , # type: ignore exclude_unset = exclude_unset , exclude_defaults = exclude_defaults , exclude_none = exclude_none , ) else : odm_fields = set ( self . __odm_fields__ . keys ()) patch_dict = {} for k , v in patch_object . items (): if include is not None and k not in include : continue if exclude is not None and k in exclude : continue if k not in odm_fields : continue patch_dict [ k ] = v patched_instance_dict = { ** self . dict (), ** patch_dict } # FIXME: improve performance by only running updated field validators and then # model validators patched_instance = self . validate ( patched_instance_dict ) for name , new_value in patched_instance . __dict__ . items (): if self . __dict__ [ name ] != new_value : # Manually change the field to avoid running the validators again self . __dict__ [ name ] = new_value self . __fields_set__ . add ( name ) self . __fields_modified__ . add ( name ) def __setattr__ ( self , name : str , value : Any ) -> None : super () . __setattr__ ( name , value ) self . __fields_modified__ . add ( name ) def dict ( # type: ignore # Missing deprecated/ unsupported parameters self , * , include : Union [ \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , # type: ignore exclude : Union [ \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , # type: ignore exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , by_alias : bool = False , # FIXME when aliases are supported ) -> \"DictStrAny\" : \"\"\"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Args: include: fields to include (include all fields if `None`) exclude: fields to exclude this takes precedence over include exclude_unset: only include fields explicitly set exclude_defaults: only include fields that are different from their default value exclude_none: only include fields different from `None` by_alias: **not supported yet** Returns: the dictionary representation of the instance \"\"\" return super () . dict ( include = include , exclude = exclude , exclude_unset = exclude_unset , exclude_defaults = exclude_defaults , exclude_none = exclude_none , ) def __doc ( self , raw_doc : Dict [ str , Any ], model : Type [ \"_BaseODMModel\" ], include : Optional [ \"AbstractSetIntStr\" ] = None , ) -> Dict [ str , Any ]: doc : Dict [ str , Any ] = {} for field_name , field in model . __odm_fields__ . items (): if include is not None and field_name not in include : continue if isinstance ( field , ODMReference ): doc [ field . key_name ] = raw_doc [ field_name ][ field . model . __primary_field__ ] elif isinstance ( field , ODMEmbedded ): doc [ field . key_name ] = self . __doc ( raw_doc [ field_name ], field . model , None ) elif isinstance ( field , ODMEmbeddedGeneric ): if field . generic_origin is dict : doc [ field . key_name ] = { item_key : self . __doc ( item_value , field . model ) for item_key , item_value in raw_doc [ field_name ] . items () } else : doc [ field . key_name ] = [ self . __doc ( item , field . model ) for item in raw_doc [ field_name ] ] elif field_name in model . __bson_serialized_fields__ : doc [ field . key_name ] = model . __fields__ [ field_name ] . type_ . __bson__ ( raw_doc [ field_name ] ) else : doc [ field . key_name ] = raw_doc [ field_name ] if model . Config . extra == \"allow\" : extras = set ( raw_doc . keys ()) - set ( model . __odm_fields__ . keys ()) for extra in extras : value = raw_doc [ extra ] subst_type = validate_type ( type ( value )) bson_serialization_method = getattr ( subst_type , \"__bson__\" , lambda x : x ) doc [ extra ] = bson_serialization_method ( raw_doc [ extra ]) return doc def doc ( self , include : Optional [ \"AbstractSetIntStr\" ] = None ) -> Dict [ str , Any ]: \"\"\"Generate a document representation of the instance (as a dictionary). Args: include: field that should be included; if None, every fields will be included Returns: the document associated to the instance \"\"\" raw_doc = self . dict () doc = self . __doc ( raw_doc , type ( self ), include ) return doc @classmethod def parse_doc ( cls : Type [ BaseT ], raw_doc : Dict ) -> BaseT : \"\"\"Parse a BSON document into an instance of the Model Args: raw_doc: document to parse (as Dict) Raises: DocumentParsingError: the specified document is invalid Returns: an instance of the Model class this method is called on. \"\"\" errors , obj = cls . _parse_doc_to_obj ( raw_doc ) if len ( errors ) > 0 : raise DocumentParsingError ( errors = [ errors ], model = cls , primary_value = raw_doc . get ( \"_id\" , \"<unknown>\" ), ) try : instance = cls . parse_obj ( obj ) except ValidationError as e : raise DocumentParsingError ( errors = e . raw_errors , # type: ignore model = cls , primary_value = raw_doc . get ( \"_id\" , \"<unknown>\" ), ) return instance @classmethod def _parse_doc_to_obj ( # noqa C901 # TODO: refactor document parsing cls : Type [ BaseT ], raw_doc : Dict , base_loc : Tuple [ str , ... ] = () ) -> Tuple [ ErrorList , Dict [ str , Any ]]: errors : ErrorList = [] obj : Dict [ str , Any ] = {} for field_name , field in cls . __odm_fields__ . items (): if isinstance ( field , ODMReference ): sub_doc = raw_doc . get ( field . key_name ) if sub_doc is None : errors . append ( ErrorWrapper ( exc = ReferencedDocumentNotFoundError ( field . key_name ), loc = base_loc + ( field_name ,), ) ) else : sub_errors , sub_obj = field . model . _parse_doc_to_obj ( sub_doc , base_loc = base_loc + ( field_name ,) ) errors . extend ( sub_errors ) obj [ field_name ] = sub_obj elif isinstance ( field , ODMEmbedded ): value = raw_doc . get ( field . key_name , Undefined ) if value is not Undefined : sub_errors , value = field . model . _parse_doc_to_obj ( value , base_loc = base_loc + ( field_name ,) ) errors . extend ( sub_errors ) else : if not field . is_required_in_doc (): value = field . get_default_importing_value () if value is Undefined : errors . append ( ErrorWrapper ( exc = KeyNotFoundInDocumentError ( field . key_name ), loc = base_loc + ( field_name ,), ) ) obj [ field_name ] = value elif isinstance ( field , ODMEmbeddedGeneric ): value = Undefined raw_value = raw_doc . get ( field . key_name , Undefined ) if raw_value is not Undefined : if isinstance ( raw_value , list ) and ( field . generic_origin is list or field . generic_origin is tuple or field . generic_origin is set ): value = [] for i , item in enumerate ( raw_value ): sub_errors , item = field . model . _parse_doc_to_obj ( item , base_loc = base_loc + ( field_name , f \"[ { i } ]\" ) ) if len ( sub_errors ) > 0 : errors . extend ( sub_errors ) else : value . append ( item ) obj [ field_name ] = value elif isinstance ( raw_value , dict ) and field . generic_origin is dict : value = {} for item_key , item_value in raw_value . items (): sub_errors , item_value = field . model . _parse_doc_to_obj ( item_value , base_loc = base_loc + ( field_name , f '[\" { item_key } \"]' ), ) if len ( sub_errors ) > 0 : errors . extend ( sub_errors ) else : value [ item_key ] = item_value obj [ field_name ] = value else : errors . append ( ErrorWrapper ( exc = IncorrectGenericEmbeddedModelValue ( raw_value ), loc = base_loc + ( field_name ,), ) ) else : if not field . is_required_in_doc (): value = field . get_default_importing_value () if value is Undefined : errors . append ( ErrorWrapper ( exc = KeyNotFoundInDocumentError ( field . key_name ), loc = base_loc + ( field_name ,), ) ) else : obj [ field_name ] = value else : field = cast ( ODMField , field ) value = raw_doc . get ( field . key_name , Undefined ) if value is Undefined and not field . is_required_in_doc (): value = field . get_default_importing_value () if value is Undefined : errors . append ( ErrorWrapper ( exc = KeyNotFoundInDocumentError ( field . key_name ), loc = base_loc + ( field_name ,), ) ) else : obj [ field_name ] = value if cls . Config . extra == \"allow\" : extras = set ( raw_doc . keys ()) - set ( obj . keys ()) for extra in extras : obj [ extra ] = raw_doc [ extra ] return errors , obj","title":"_BaseODMModel"},{"location":"api_reference/model/#odmantic.model._BaseODMModel.parse_doc","text":"Parse a BSON document into an instance of the Model Parameters: Name Type Description Default raw_doc Dict document to parse (as Dict) required Raises: Type Description DocumentParsingError the specified document is invalid Returns: Type Description BaseT an instance of the Model class this method is called on. Source code in odmantic/model.py 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 @classmethod def parse_doc ( cls : Type [ BaseT ], raw_doc : Dict ) -> BaseT : \"\"\"Parse a BSON document into an instance of the Model Args: raw_doc: document to parse (as Dict) Raises: DocumentParsingError: the specified document is invalid Returns: an instance of the Model class this method is called on. \"\"\" errors , obj = cls . _parse_doc_to_obj ( raw_doc ) if len ( errors ) > 0 : raise DocumentParsingError ( errors = [ errors ], model = cls , primary_value = raw_doc . get ( \"_id\" , \"<unknown>\" ), ) try : instance = cls . parse_obj ( obj ) except ValidationError as e : raise DocumentParsingError ( errors = e . raw_errors , # type: ignore model = cls , primary_value = raw_doc . get ( \"_id\" , \"<unknown>\" ), ) return instance","title":"parse_doc()"},{"location":"api_reference/model/#odmantic.model._BaseODMModel.doc","text":"Generate a document representation of the instance (as a dictionary). Parameters: Name Type Description Default include Optional [ AbstractSetIntStr ] field that should be included; if None, every fields will be included None Returns: Type Description Dict [ str , Any ] the document associated to the instance Source code in odmantic/model.py 733 734 735 736 737 738 739 740 741 742 743 744 745 def doc ( self , include : Optional [ \"AbstractSetIntStr\" ] = None ) -> Dict [ str , Any ]: \"\"\"Generate a document representation of the instance (as a dictionary). Args: include: field that should be included; if None, every fields will be included Returns: the document associated to the instance \"\"\" raw_doc = self . dict () doc = self . __doc ( raw_doc , type ( self ), include ) return doc","title":"doc()"},{"location":"api_reference/model/#odmantic.model._BaseODMModel.update","text":"Update instance fields from a Pydantic model or a dictionary. If a pydantic model is provided, only the fields set will be applied by default. Parameters: Name Type Description Default patch_object Union [ BaseModel , Dict [ str , Any ]] object containing the values to update required include Union [None, AbstractSetIntStr , MappingIntStrAny ] fields to include from the patch_object (include all fields if None ) None exclude Union [None, AbstractSetIntStr , MappingIntStrAny ] fields to exclude from the patch_object , this takes precedence over include None exclude_unset bool only update fields explicitly set in the patch object (only applies to Pydantic models) True exclude_defaults bool only update fields that are different from their default value in the patch object (only applies to Pydantic models) False exclude_none bool only update fields different from None in the patch object (only applies to Pydantic models) False Raises: Type Description ValidationError the modifications would make the instance invalid Source code in odmantic/model.py 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 def update ( self , patch_object : Union [ BaseModel , Dict [ str , Any ]], * , include : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude_unset : bool = True , exclude_defaults : bool = False , exclude_none : bool = False , ) -> None : \"\"\"Update instance fields from a Pydantic model or a dictionary. If a pydantic model is provided, only the **fields set** will be applied by default. Args: patch_object: object containing the values to update include: fields to include from the `patch_object` (include all fields if `None`) exclude: fields to exclude from the `patch_object`, this takes precedence over include exclude_unset: only update fields explicitly set in the patch object (only applies to Pydantic models) exclude_defaults: only update fields that are different from their default value in the patch object (only applies to Pydantic models) exclude_none: only update fields different from None in the patch object (only applies to Pydantic models) Raises: ValidationError: the modifications would make the instance invalid <!-- #noqa: DAR402 ValidationError --> \"\"\" if isinstance ( patch_object , BaseModel ): patch_dict = patch_object . dict ( include = include , # type: ignore exclude = exclude , # type: ignore exclude_unset = exclude_unset , exclude_defaults = exclude_defaults , exclude_none = exclude_none , ) else : odm_fields = set ( self . __odm_fields__ . keys ()) patch_dict = {} for k , v in patch_object . items (): if include is not None and k not in include : continue if exclude is not None and k in exclude : continue if k not in odm_fields : continue patch_dict [ k ] = v patched_instance_dict = { ** self . dict (), ** patch_dict } # FIXME: improve performance by only running updated field validators and then # model validators patched_instance = self . validate ( patched_instance_dict ) for name , new_value in patched_instance . __dict__ . items (): if self . __dict__ [ name ] != new_value : # Manually change the field to avoid running the validators again self . __dict__ [ name ] = new_value self . __fields_set__ . add ( name ) self . __fields_modified__ . add ( name )","title":"update()"},{"location":"api_reference/model/#odmantic.model._BaseODMModel.copy","text":"Duplicate a model, optionally choose which fields to include, exclude and change. Danger The data is not validated before creating the new model: you should trust this data . Parameters: Name Type Description Default include Union [None, AbstractSetIntStr , MappingIntStrAny ] fields to include in new model None exclude Union [None, AbstractSetIntStr , MappingIntStrAny ] fields to exclude from new model, as with values this takes precedence over include None update Optional [ DictStrAny ] values to change/add in the new model. None deep bool set to True to make a deep copy of the model False Note The include and exclude kwargs are only affecting the copied data, not filtering the update object. Returns: Type Description BaseT new model instance Source code in odmantic/model.py 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 def copy ( self : BaseT , * , include : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , update : Optional [ \"DictStrAny\" ] = None , deep : bool = False , ) -> BaseT : \"\"\"Duplicate a model, optionally choose which fields to include, exclude and change. Danger: The data is not validated before creating the new model: **you should trust this data**. Arguments: include: fields to include in new model exclude: fields to exclude from new model, as with values this takes precedence over include update: values to change/add in the new model. deep: set to `True` to make a deep copy of the model Note: The `include` and `exclude` kwargs are only affecting the copied data, not filtering the update object. Returns: new model instance \"\"\" copied = super () . copy ( include = include , exclude = exclude , update = update , deep = deep # type: ignore ) copied . _post_copy_update () return copied","title":"copy()"},{"location":"api_reference/model/#odmantic.model._BaseODMModel.dict","text":"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Parameters: Name Type Description Default include Union [ AbstractSetIntStr , MappingIntStrAny ] fields to include (include all fields if None ) None exclude Union [ AbstractSetIntStr , MappingIntStrAny ] fields to exclude this takes precedence over include None exclude_unset bool only include fields explicitly set False exclude_defaults bool only include fields that are different from their default value False exclude_none bool only include fields different from None False by_alias bool not supported yet False Returns: Type Description DictStrAny the dictionary representation of the instance Source code in odmantic/model.py 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 def dict ( # type: ignore # Missing deprecated/ unsupported parameters self , * , include : Union [ \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , # type: ignore exclude : Union [ \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , # type: ignore exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , by_alias : bool = False , # FIXME when aliases are supported ) -> \"DictStrAny\" : \"\"\"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Args: include: fields to include (include all fields if `None`) exclude: fields to exclude this takes precedence over include exclude_unset: only include fields explicitly set exclude_defaults: only include fields that are different from their default value exclude_none: only include fields different from `None` by_alias: **not supported yet** Returns: the dictionary representation of the instance \"\"\" return super () . dict ( include = include , exclude = exclude , exclude_unset = exclude_unset , exclude_defaults = exclude_defaults , exclude_none = exclude_none , )","title":"dict()"},{"location":"api_reference/model/#odmantic.model.Model","text":"Bases: _BaseODMModel Class that can be extended to create an ODMantic Model. Each model will be bound to a MongoDB collection. You can customize the collection name by setting the __collection__ class variable in the model classes. Source code in odmantic/model.py 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 class Model ( _BaseODMModel , metaclass = ModelMetaclass ): \"\"\"Class that can be extended to create an ODMantic Model. Each model will be bound to a MongoDB collection. You can customize the collection name by setting the `__collection__` class variable in the model classes. \"\"\" if TYPE_CHECKING : __collection__ : ClassVar [ str ] = \"\" __primary_field__ : ClassVar [ str ] = \"\" id : Union [ ObjectId , Any ] = Field ( init = False ) # TODO fix basic id field typing def __setattr__ ( self , name : str , value : Any ) -> None : if name == self . __primary_field__ : # TODO implement raise NotImplementedError ( \"Reassigning a new primary key is not supported yet\" ) super () . __setattr__ ( name , value ) @classmethod def __indexes__ ( cls ) -> Tuple [ Union [ ODMBaseIndex , pymongo . IndexModel ], ... ]: indexes : List [ Union [ ODMBaseIndex , pymongo . IndexModel ]] = [] for field in cls . __odm_fields__ . values (): if isinstance ( field , ODMBaseIndexableField ) and ( field . index or field . unique ): indexes . append ( ODMSingleFieldIndex ( key_name = field . key_name , unique = field . unique , ) ) for index in cast ( BaseODMConfig , cls . Config ) . indexes (): indexes . append ( index . to_odm_index () if isinstance ( index , Index ) else index ) return tuple ( indexes ) def update ( self , patch_object : Union [ BaseModel , Dict [ str , Any ]], * , include : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude : Union [ None , \"AbstractSetIntStr\" , \"MappingIntStrAny\" ] = None , exclude_unset : bool = True , exclude_defaults : bool = False , exclude_none : bool = False , ) -> None : is_primary_field_in_patch = ( isinstance ( patch_object , BaseModel ) and self . __primary_field__ in patch_object . __fields__ ) or ( isinstance ( patch_object , dict ) and self . __primary_field__ in patch_object ) if is_primary_field_in_patch : if ( include is None and ( exclude is None or self . __primary_field__ not in exclude ) ) or ( include is not None and self . __primary_field__ in include and ( exclude is None or self . __primary_field__ not in exclude ) ): raise ValueError ( \"Updating the primary key is not supported. \" \"See the copy method if you want to modify the primary field.\" ) return super () . update ( patch_object , include = include , exclude = exclude , exclude_unset = exclude_unset , exclude_defaults = exclude_defaults , exclude_none = exclude_none , )","title":"Model"},{"location":"api_reference/model/#odmantic.model.EmbeddedModel","text":"Bases: _BaseODMModel Class that can be extended to create an ODMantic Embedded Model. An embedded document cannot be persisted directly to the database but should be integrated in a regular ODMantic Model. Source code in odmantic/model.py 968 969 970 971 972 973 class EmbeddedModel ( _BaseODMModel , metaclass = EmbeddedModelMetaclass ): \"\"\"Class that can be extended to create an ODMantic Embedded Model. An embedded document cannot be persisted directly to the database but should be integrated in a regular ODMantic Model. \"\"\"","title":"EmbeddedModel"},{"location":"api_reference/query/","text":"odmantic.query.QueryExpression \u00b6 Bases: Dict [ str , Any ] Base object used to build queries. All comparison and logical operators returns QueryExpression objects. The | and & operators are supported for respectively the or and the and logical operators. Warning When using those operators make sure to correctly bracket the expressions to avoid python operator precedence issues. Source code in odmantic/query.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class QueryExpression ( Dict [ str , Any ]): \"\"\"Base object used to build queries. All comparison and logical operators returns `QueryExpression` objects. The `|` and `&` operators are supported for respectively the [or][odmantic.query.or_] and the [and][odmantic.query.and_] logical operators. Warning: When using those operators make sure to correctly bracket the expressions to avoid python operator precedence issues. \"\"\" def __repr__ ( self ) -> str : parent_repr = super () . __repr__ () if parent_repr == \" {} \" : parent_repr = \"\" return f \"QueryExpression( { parent_repr } )\" def __or__ ( self , other : \"QueryExpression\" ) -> \"QueryExpression\" : # type: ignore return or_ ( self , other ) def __and__ ( self , other : \"QueryExpression\" ) -> \"QueryExpression\" : return and_ ( self , other ) Logical Operators \u00b6 odmantic . query . and_ ( * elements ) \u00b6 Logical AND operation between multiple QueryExpression objects. Source code in odmantic/query.py 40 41 42 def and_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **AND** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$and\" : elements }) odmantic . query . or_ ( * elements ) \u00b6 Logical OR operation between multiple QueryExpression objects. Source code in odmantic/query.py 45 46 47 def or_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **OR** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$or\" : elements }) odmantic . query . nor_ ( * elements ) \u00b6 Logical NOR operation between multiple QueryExpression objects. Source code in odmantic/query.py 50 51 52 def nor_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **NOR** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$nor\" : elements }) Comparison Operators \u00b6 odmantic . query . eq ( field , value ) \u00b6 Equality comparison operator. Source code in odmantic/query.py 71 72 73 def eq ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Equality comparison operator.\"\"\" return _cmp_expression ( field , \"$eq\" , value ) odmantic . query . ne ( field , value ) \u00b6 Inequality comparison operator (includes documents not containing the field). Source code in odmantic/query.py 76 77 78 def ne ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Inequality comparison operator (includes documents not containing the field).\"\"\" return _cmp_expression ( field , \"$ne\" , value ) odmantic . query . gt ( field , value ) \u00b6 Greater than (strict) comparison operator (i.e. >). Source code in odmantic/query.py 81 82 83 def gt ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Greater than (strict) comparison operator (i.e. >).\"\"\" return _cmp_expression ( field , \"$gt\" , value ) odmantic . query . gte ( field , value ) \u00b6 Greater than or equal comparison operator (i.e. >=). Source code in odmantic/query.py 86 87 88 def gte ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Greater than or equal comparison operator (i.e. >=).\"\"\" return _cmp_expression ( field , \"$gte\" , value ) odmantic . query . lt ( field , value ) \u00b6 Less than (strict) comparison operator (i.e. <). Source code in odmantic/query.py 91 92 93 def lt ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Less than (strict) comparison operator (i.e. <).\"\"\" return _cmp_expression ( field , \"$lt\" , value ) odmantic . query . lte ( field , value ) \u00b6 Less than or equal comparison operator (i.e. <=). Source code in odmantic/query.py 96 97 98 def lte ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Less than or equal comparison operator (i.e. <=).\"\"\" return _cmp_expression ( field , \"$lte\" , value ) odmantic . query . in_ ( field , sequence ) \u00b6 Select instances where field is contained in sequence . Source code in odmantic/query.py 101 102 103 def in_ ( field : FieldProxyAny , sequence : Iterable ) -> QueryExpression : \"\"\"Select instances where `field` is contained in `sequence`.\"\"\" return _cmp_expression ( field , \"$in\" , list ( sequence )) odmantic . query . not_in ( field , sequence ) \u00b6 Select instances where field is not contained in sequence . Source code in odmantic/query.py 106 107 108 def not_in ( field : FieldProxyAny , sequence : Iterable ) -> QueryExpression : \"\"\"Select instances where `field` is **not** contained in `sequence`.\"\"\" return _cmp_expression ( field , \"$nin\" , list ( sequence )) odmantic . query . match ( field , pattern ) \u00b6 Select instances where field matches the pattern regular expression. Source code in odmantic/query.py 111 112 113 114 115 116 117 118 119 def match ( field : FieldProxyAny , pattern : Union [ Pattern , str ]) -> QueryExpression : \"\"\"Select instances where `field` matches the `pattern` regular expression.\"\"\" # FIXME might create incompatibilities # https://docs.mongodb.com/manual/reference/operator/query/regex/#regex-and-not if isinstance ( pattern , str ): r = re . compile ( pattern ) else : r = pattern return QueryExpression ({ + field : r }) Sort helpers \u00b6 odmantic.query.SortExpression \u00b6 Bases: Dict [ str , Literal [-1, 1]] Base object used to build sort queries. Source code in odmantic/query.py 122 123 124 125 126 127 128 129 class SortExpression ( Dict [ str , Literal [ - 1 , 1 ]]): \"\"\"Base object used to build sort queries.\"\"\" def __repr__ ( self ) -> str : parent_repr = super () . __repr__ () if parent_repr == \" {} \" : parent_repr = \"\" return f \"SortExpression( { parent_repr } )\" odmantic . query . asc ( field ) \u00b6 Sort by ascending field . Source code in odmantic/query.py 138 139 140 def asc ( field : FieldProxyAny ) -> SortExpression : \"\"\"Sort by ascending `field`.\"\"\" return _build_sort_expression ( field , 1 ) odmantic . query . desc ( field ) \u00b6 Sort by descending field . Source code in odmantic/query.py 143 144 145 def desc ( field : FieldProxyAny ) -> SortExpression : \"\"\"Sort by descending `field`.\"\"\" return _build_sort_expression ( field , - 1 )","title":"odmantic.query"},{"location":"api_reference/query/#odmantic.query.QueryExpression","text":"Bases: Dict [ str , Any ] Base object used to build queries. All comparison and logical operators returns QueryExpression objects. The | and & operators are supported for respectively the or and the and logical operators. Warning When using those operators make sure to correctly bracket the expressions to avoid python operator precedence issues. Source code in odmantic/query.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class QueryExpression ( Dict [ str , Any ]): \"\"\"Base object used to build queries. All comparison and logical operators returns `QueryExpression` objects. The `|` and `&` operators are supported for respectively the [or][odmantic.query.or_] and the [and][odmantic.query.and_] logical operators. Warning: When using those operators make sure to correctly bracket the expressions to avoid python operator precedence issues. \"\"\" def __repr__ ( self ) -> str : parent_repr = super () . __repr__ () if parent_repr == \" {} \" : parent_repr = \"\" return f \"QueryExpression( { parent_repr } )\" def __or__ ( self , other : \"QueryExpression\" ) -> \"QueryExpression\" : # type: ignore return or_ ( self , other ) def __and__ ( self , other : \"QueryExpression\" ) -> \"QueryExpression\" : return and_ ( self , other )","title":"QueryExpression"},{"location":"api_reference/query/#logical-operators","text":"","title":"Logical Operators"},{"location":"api_reference/query/#odmantic.query.and_","text":"Logical AND operation between multiple QueryExpression objects. Source code in odmantic/query.py 40 41 42 def and_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **AND** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$and\" : elements })","title":"and_()"},{"location":"api_reference/query/#odmantic.query.or_","text":"Logical OR operation between multiple QueryExpression objects. Source code in odmantic/query.py 45 46 47 def or_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **OR** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$or\" : elements })","title":"or_()"},{"location":"api_reference/query/#odmantic.query.nor_","text":"Logical NOR operation between multiple QueryExpression objects. Source code in odmantic/query.py 50 51 52 def nor_ ( * elements : QueryDictBool ) -> QueryExpression : \"\"\"Logical **NOR** operation between multiple `QueryExpression` objects.\"\"\" return QueryExpression ({ \"$nor\" : elements })","title":"nor_()"},{"location":"api_reference/query/#comparison-operators","text":"","title":"Comparison Operators"},{"location":"api_reference/query/#odmantic.query.eq","text":"Equality comparison operator. Source code in odmantic/query.py 71 72 73 def eq ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Equality comparison operator.\"\"\" return _cmp_expression ( field , \"$eq\" , value )","title":"eq()"},{"location":"api_reference/query/#odmantic.query.ne","text":"Inequality comparison operator (includes documents not containing the field). Source code in odmantic/query.py 76 77 78 def ne ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Inequality comparison operator (includes documents not containing the field).\"\"\" return _cmp_expression ( field , \"$ne\" , value )","title":"ne()"},{"location":"api_reference/query/#odmantic.query.gt","text":"Greater than (strict) comparison operator (i.e. >). Source code in odmantic/query.py 81 82 83 def gt ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Greater than (strict) comparison operator (i.e. >).\"\"\" return _cmp_expression ( field , \"$gt\" , value )","title":"gt()"},{"location":"api_reference/query/#odmantic.query.gte","text":"Greater than or equal comparison operator (i.e. >=). Source code in odmantic/query.py 86 87 88 def gte ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Greater than or equal comparison operator (i.e. >=).\"\"\" return _cmp_expression ( field , \"$gte\" , value )","title":"gte()"},{"location":"api_reference/query/#odmantic.query.lt","text":"Less than (strict) comparison operator (i.e. <). Source code in odmantic/query.py 91 92 93 def lt ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Less than (strict) comparison operator (i.e. <).\"\"\" return _cmp_expression ( field , \"$lt\" , value )","title":"lt()"},{"location":"api_reference/query/#odmantic.query.lte","text":"Less than or equal comparison operator (i.e. <=). Source code in odmantic/query.py 96 97 98 def lte ( field : FieldProxyAny , value : Any ) -> QueryExpression : \"\"\"Less than or equal comparison operator (i.e. <=).\"\"\" return _cmp_expression ( field , \"$lte\" , value )","title":"lte()"},{"location":"api_reference/query/#odmantic.query.in_","text":"Select instances where field is contained in sequence . Source code in odmantic/query.py 101 102 103 def in_ ( field : FieldProxyAny , sequence : Iterable ) -> QueryExpression : \"\"\"Select instances where `field` is contained in `sequence`.\"\"\" return _cmp_expression ( field , \"$in\" , list ( sequence ))","title":"in_()"},{"location":"api_reference/query/#odmantic.query.not_in","text":"Select instances where field is not contained in sequence . Source code in odmantic/query.py 106 107 108 def not_in ( field : FieldProxyAny , sequence : Iterable ) -> QueryExpression : \"\"\"Select instances where `field` is **not** contained in `sequence`.\"\"\" return _cmp_expression ( field , \"$nin\" , list ( sequence ))","title":"not_in()"},{"location":"api_reference/query/#odmantic.query.match","text":"Select instances where field matches the pattern regular expression. Source code in odmantic/query.py 111 112 113 114 115 116 117 118 119 def match ( field : FieldProxyAny , pattern : Union [ Pattern , str ]) -> QueryExpression : \"\"\"Select instances where `field` matches the `pattern` regular expression.\"\"\" # FIXME might create incompatibilities # https://docs.mongodb.com/manual/reference/operator/query/regex/#regex-and-not if isinstance ( pattern , str ): r = re . compile ( pattern ) else : r = pattern return QueryExpression ({ + field : r })","title":"match()"},{"location":"api_reference/query/#sort-helpers","text":"","title":"Sort helpers"},{"location":"api_reference/query/#odmantic.query.SortExpression","text":"Bases: Dict [ str , Literal [-1, 1]] Base object used to build sort queries. Source code in odmantic/query.py 122 123 124 125 126 127 128 129 class SortExpression ( Dict [ str , Literal [ - 1 , 1 ]]): \"\"\"Base object used to build sort queries.\"\"\" def __repr__ ( self ) -> str : parent_repr = super () . __repr__ () if parent_repr == \" {} \" : parent_repr = \"\" return f \"SortExpression( { parent_repr } )\"","title":"SortExpression"},{"location":"api_reference/query/#odmantic.query.asc","text":"Sort by ascending field . Source code in odmantic/query.py 138 139 140 def asc ( field : FieldProxyAny ) -> SortExpression : \"\"\"Sort by ascending `field`.\"\"\" return _build_sort_expression ( field , 1 )","title":"asc()"},{"location":"api_reference/query/#odmantic.query.desc","text":"Sort by descending field . Source code in odmantic/query.py 143 144 145 def desc ( field : FieldProxyAny ) -> SortExpression : \"\"\"Sort by descending `field`.\"\"\" return _build_sort_expression ( field , - 1 )","title":"desc()"},{"location":"api_reference/reference/","text":"odmantic . reference . Reference ( * , key_name = None ) \u00b6 Used to define reference fields. Parameters: Name Type Description Default key_name Optional [ str ] name of the Mongo key that stores the foreign key None Source code in odmantic/reference.py 4 5 6 7 8 9 10 11 12 13 14 def Reference ( * , key_name : Optional [ str ] = None ) -> Any : \"\"\"Used to define reference fields. Args: key_name: name of the Mongo key that stores the foreign key <!-- #noqa: DAR201 --> \"\"\" return ODMReferenceInfo ( key_name = key_name )","title":"odmantic.reference"},{"location":"api_reference/reference/#odmantic.reference.Reference","text":"Used to define reference fields. Parameters: Name Type Description Default key_name Optional [ str ] name of the Mongo key that stores the foreign key None Source code in odmantic/reference.py 4 5 6 7 8 9 10 11 12 13 14 def Reference ( * , key_name : Optional [ str ] = None ) -> Any : \"\"\"Used to define reference fields. Args: key_name: name of the Mongo key that stores the foreign key <!-- #noqa: DAR201 --> \"\"\" return ODMReferenceInfo ( key_name = key_name )","title":"Reference()"},{"location":"api_reference/session/","text":"odmantic.session.AIOSession \u00b6 Bases: AIOSessionBase , AsyncContextManager An AsyncIO session object for ordering sequential operations. Sessions can be created from the engine directly by using the AIOEngine.session method. Example usage as a context manager: engine = AIOEngine ( ... ) async with engine . session () as session : john = await session . find ( User , User . name == \"John\" ) john . name = \"Doe\" await session . save ( john ) Example raw usage: engine = AIOEngine ( ... ) session = engine . session () await session . start () john = await session . find ( User , User . name == \"John\" ) john . name = \"Doe\" await session . save ( john ) await session . end () Source code in odmantic/session.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 class AIOSession ( AIOSessionBase , AsyncContextManager ): \"\"\"An AsyncIO session object for ordering sequential operations. Sessions can be created from the engine directly by using the [AIOEngine.session][odmantic.engine.AIOEngine.session] method. Example usage as a context manager: ```python engine = AIOEngine(...) async with engine.session() as session: john = await session.find(User, User.name == \"John\") john.name = \"Doe\" await session.save(john) ``` Example raw usage: ```python engine = AIOEngine(...) session = engine.session() await session.start() john = await session.find(User, User.name == \"John\") john.name = \"Doe\" await session.save(john) await session.end() ``` \"\"\" def __init__ ( self , engine : ODMEngine . AIOEngine ): self . engine = engine self . session : Optional [ AsyncIOMotorClientSession ] = None @property def is_started ( self ) -> bool : return self . session is not None def get_driver_session ( self ) -> AsyncIOMotorClientSession : \"\"\"Return the underlying Motor Session\"\"\" if self . session is None : raise RuntimeError ( \"session not started\" ) return self . session async def start ( self ) -> None : \"\"\"Start the logical Mongo session.\"\"\" if self . is_started : raise RuntimeError ( \"Session is already started\" ) self . session = await self . engine . client . start_session () async def end ( self ) -> None : \"\"\"Finish the logical session.\"\"\" if self . session is None : raise RuntimeError ( \"Session is not started\" ) await self . session . end_session () self . session = None async def __aenter__ ( self ) -> \"AIOSession\" : await self . start () return self async def __aexit__ ( self , exc_type : Optional [ Type [ BaseException ]], exc : Optional [ BaseException ], traceback : Optional [ TracebackType ], ) -> None : await self . end () def transaction ( self ) -> AIOTransaction : \"\"\"Create a transaction in the existing session\"\"\" return AIOTransaction ( self ) end () async \u00b6 Finish the logical session. Source code in odmantic/session.py 245 246 247 248 249 250 async def end ( self ) -> None : \"\"\"Finish the logical session.\"\"\" if self . session is None : raise RuntimeError ( \"Session is not started\" ) await self . session . end_session () self . session = None get_driver_session () \u00b6 Return the underlying Motor Session Source code in odmantic/session.py 233 234 235 236 237 def get_driver_session ( self ) -> AsyncIOMotorClientSession : \"\"\"Return the underlying Motor Session\"\"\" if self . session is None : raise RuntimeError ( \"session not started\" ) return self . session start () async \u00b6 Start the logical Mongo session. Source code in odmantic/session.py 239 240 241 242 243 async def start ( self ) -> None : \"\"\"Start the logical Mongo session.\"\"\" if self . is_started : raise RuntimeError ( \"Session is already started\" ) self . session = await self . engine . client . start_session () transaction () \u00b6 Create a transaction in the existing session Source code in odmantic/session.py 264 265 266 def transaction ( self ) -> AIOTransaction : \"\"\"Create a transaction in the existing session\"\"\" return AIOTransaction ( self ) odmantic.engine.AIOTransaction \u00b6 Bases: AIOSessionBase , AsyncContextManager A transaction object to aggregate sequential operations. Transactions can be created from the engine using the AIOEngine.transaction method or they can be created during an existing session by using AIOSession.transaction . Example usage as a context manager: engine = AIOEngine ( ... ) async with engine . transaction () as transaction : john = await transaction . find ( User , User . name == \"John\" ) john . name = \"Doe\" await transaction . save ( john ) await transaction . commit () Example raw usage: engine = AIOEngine ( ... ) transaction = engine . transaction () await transaction . start () john = await transaction . find ( User , User . name == \"John\" ) john . name = \"Doe\" await transaction . save ( john ) await transaction . commit () Warning MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled. Source code in odmantic/session.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 class AIOTransaction ( AIOSessionBase , AsyncContextManager ): \"\"\"A transaction object to aggregate sequential operations. Transactions can be created from the engine using the [AIOEngine.transaction][odmantic.engine.AIOEngine.transaction] method or they can be created during an existing session by using [AIOSession.transaction][odmantic.session.AIOSession.transaction]. Example usage as a context manager: ```python engine = AIOEngine(...) async with engine.transaction() as transaction: john = await transaction.find(User, User.name == \"John\") john.name = \"Doe\" await transaction.save(john) await transaction.commit() ``` Example raw usage: ```python engine = AIOEngine(...) transaction = engine.transaction() await transaction.start() john = await transaction.find(User, User.name == \"John\") john.name = \"Doe\" await transaction.save(john) await transaction.commit() ``` Warning: MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled. \"\"\" def __init__ ( self , context : Union [ ODMEngine . AIOEngine , ODMEngine . AIOSession ]): self . _session_provided = isinstance ( context , ODMEngine . AIOSession ) if self . _session_provided : assert isinstance ( context , ODMEngine . AIOSession ) if not context . is_started : raise RuntimeError ( \"provided session is not started\" ) self . session = context self . engine = context . engine else : assert isinstance ( context , ODMEngine . AIOEngine ) self . session = AIOSession ( context ) self . engine = context self . _transaction_started = False self . _transaction_context : Optional [ AsyncContextManager ] = None def get_driver_session ( self ) -> AsyncIOMotorClientSession : \"\"\"Return the underlying Motor Session\"\"\" if not self . _transaction_started : raise RuntimeError ( \"transaction not started\" ) return self . session . get_driver_session () async def start ( self ) -> None : \"\"\"Initiate the transaction.\"\"\" if self . _transaction_started : raise RuntimeError ( \"Transaction already started\" ) if not self . _session_provided : await self . session . start () assert self . session . session is not None self . _transaction_context = ( await self . session . session . start_transaction () . __aenter__ () ) self . _transaction_started = True async def commit ( self ) -> None : \"\"\"Commit the changes and close the transaction.\"\"\" if not self . _transaction_started : raise RuntimeError ( \"Transaction not started\" ) assert self . session . session is not None await self . session . session . commit_transaction () self . _transaction_started = False if not self . _session_provided : await self . session . end () async def abort ( self ) -> None : \"\"\"Discard the changes and drop the transaction\"\"\" if not self . _transaction_started : raise RuntimeError ( \"Transaction not started\" ) assert self . session . session is not None await self . session . session . abort_transaction () self . _transaction_started = False if not self . _session_provided : await self . session . end () async def __aenter__ ( self ) -> \"AIOTransaction\" : await self . start () return self async def __aexit__ ( self , exc_type : Optional [ Type [ BaseException ]], exc : Optional [ BaseException ], traceback : Optional [ TracebackType ], ) -> None : assert self . _transaction_context is not None await self . _transaction_context . __aexit__ ( exc_type , exc , traceback ) self . _transaction_started = False abort () async \u00b6 Discard the changes and drop the transaction Source code in odmantic/session.py 347 348 349 350 351 352 353 354 355 async def abort ( self ) -> None : \"\"\"Discard the changes and drop the transaction\"\"\" if not self . _transaction_started : raise RuntimeError ( \"Transaction not started\" ) assert self . session . session is not None await self . session . session . abort_transaction () self . _transaction_started = False if not self . _session_provided : await self . session . end () commit () async \u00b6 Commit the changes and close the transaction. Source code in odmantic/session.py 337 338 339 340 341 342 343 344 345 async def commit ( self ) -> None : \"\"\"Commit the changes and close the transaction.\"\"\" if not self . _transaction_started : raise RuntimeError ( \"Transaction not started\" ) assert self . session . session is not None await self . session . session . commit_transaction () self . _transaction_started = False if not self . _session_provided : await self . session . end () get_driver_session () \u00b6 Return the underlying Motor Session Source code in odmantic/session.py 319 320 321 322 323 def get_driver_session ( self ) -> AsyncIOMotorClientSession : \"\"\"Return the underlying Motor Session\"\"\" if not self . _transaction_started : raise RuntimeError ( \"transaction not started\" ) return self . session . get_driver_session () start () async \u00b6 Initiate the transaction. Source code in odmantic/session.py 325 326 327 328 329 330 331 332 333 334 335 async def start ( self ) -> None : \"\"\"Initiate the transaction.\"\"\" if self . _transaction_started : raise RuntimeError ( \"Transaction already started\" ) if not self . _session_provided : await self . session . start () assert self . session . session is not None self . _transaction_context = ( await self . session . session . start_transaction () . __aenter__ () ) self . _transaction_started = True odmantic.session.AIOSessionBase \u00b6 Source code in odmantic/session.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 class AIOSessionBase ( metaclass = ABCMeta ): engine : ODMEngine . AIOEngine def find ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , ) -> ODMEngine . AIOCursor [ ODMEngine . ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched Returns: [odmantic.engine.AIOCursor][] of the query \"\"\" return self . engine . find ( model , * queries , sort = sort , skip = skip , limit = limit , session = self . engine . _get_session ( self ), ) async def find_one ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin sort : Optional [ Any ] = None , ) -> Optional [ ODMEngine . ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression Raises: DocumentParsingError: unable to parse the resulting document Returns: the fetched instance if found otherwise None <!--- #noqa: DAR402 DocumentParsingError --> \"\"\" return await self . engine . find_one ( model , * queries , sort = sort , session = self . engine . _get_session ( self ) ) async def count ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on *queries: query filters to apply Returns: number of document matching the query \"\"\" return await self . engine . count ( model , * queries , session = self . engine . _get_session ( self ) ) async def save ( self , instance : ODMEngine . ModelType , ) -> ODMEngine . ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist Returns: the saved instance NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. \"\"\" return await self . engine . save ( instance , session = self . engine . _get_session ( self )) async def save_all ( self , instances : Sequence [ ODMEngine . ModelType ], ) -> List [ ODMEngine . ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist Returns: the saved instances NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. \"\"\" return await self . engine . save_all ( instances , session = self . engine . _get_session ( self ) ) async def delete ( self , instance : ODMEngine . ModelType , ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete Raises: DocumentNotFoundError: the instance has not been persisted to the database <!--- #noqa: DAR402 DocumentNotFoundError #noqa: DAR201 --> \"\"\" return await self . engine . delete ( instance , session = self . engine . _get_session ( self ) ) async def remove ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], just_one : bool = False , ) -> int : \"\"\"Delete Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply just_one: limit the deletion to just one document Returns: the number of instances deleted from the database. \"\"\" return await self . engine . remove ( model , * queries , just_one = just_one , session = self . engine . _get_session ( self ) ) count ( model , * queries ) async \u00b6 Get the count of documents matching a query Parameters: Name Type Description Default model Type [ ODMEngine . ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filters to apply () Returns: Type Description int number of document matching the query Source code in odmantic/session.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 async def count ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on *queries: query filters to apply Returns: number of document matching the query \"\"\" return await self . engine . count ( model , * queries , session = self . engine . _get_session ( self ) ) delete ( instance ) async \u00b6 Delete an instance from the database Parameters: Name Type Description Default instance ODMEngine . ModelType the instance to delete required Raises: Type Description DocumentNotFoundError the instance has not been persisted to the database Source code in odmantic/session.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 async def delete ( self , instance : ODMEngine . ModelType , ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete Raises: DocumentNotFoundError: the instance has not been persisted to the database <!--- #noqa: DAR402 DocumentNotFoundError #noqa: DAR201 --> \"\"\" return await self . engine . delete ( instance , session = self . engine . _get_session ( self ) ) find ( model , * queries , sort = None , skip = 0 , limit = None ) \u00b6 Search for Model instances matching the query filter provided Parameters: Name Type Description Default model Type [ ODMEngine . ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () sort Optional [ Any ] sort expression None skip int number of document to skip 0 limit Optional [ int ] maximum number of instance fetched None Returns: Type Description ODMEngine . AIOCursor [ ODMEngine . ModelType ] odmantic.engine.AIOCursor of the query Source code in odmantic/session.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def find ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , ) -> ODMEngine . AIOCursor [ ODMEngine . ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched Returns: [odmantic.engine.AIOCursor][] of the query \"\"\" return self . engine . find ( model , * queries , sort = sort , skip = skip , limit = limit , session = self . engine . _get_session ( self ), ) find_one ( model , * queries , sort = None ) async \u00b6 Search for a Model instance matching the query filter provided Parameters: Name Type Description Default model Type [ ODMEngine . ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () sort Optional [ Any ] sort expression None Raises: Type Description DocumentParsingError unable to parse the resulting document Returns: Type Description Optional [ ODMEngine . ModelType ] the fetched instance if found otherwise None Source code in odmantic/session.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 async def find_one ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin sort : Optional [ Any ] = None , ) -> Optional [ ODMEngine . ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression Raises: DocumentParsingError: unable to parse the resulting document Returns: the fetched instance if found otherwise None <!--- #noqa: DAR402 DocumentParsingError --> \"\"\" return await self . engine . find_one ( model , * queries , sort = sort , session = self . engine . _get_session ( self ) ) remove ( model , * queries , just_one = False ) async \u00b6 Delete Model instances matching the query filter provided Parameters: Name Type Description Default model Type [ ODMEngine . ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () just_one bool limit the deletion to just one document False Returns: Type Description int the number of instances deleted from the database. Source code in odmantic/session.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 async def remove ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], just_one : bool = False , ) -> int : \"\"\"Delete Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply just_one: limit the deletion to just one document Returns: the number of instances deleted from the database. \"\"\" return await self . engine . remove ( model , * queries , just_one = just_one , session = self . engine . _get_session ( self ) ) save ( instance ) async \u00b6 Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Parameters: Name Type Description Default instance ODMEngine . ModelType instance to persist required Returns: Type Description ODMEngine . ModelType the saved instance NOTE The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. Source code in odmantic/session.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 async def save ( self , instance : ODMEngine . ModelType , ) -> ODMEngine . ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist Returns: the saved instance NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. \"\"\" return await self . engine . save ( instance , session = self . engine . _get_session ( self )) save_all ( instances ) async \u00b6 Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Parameters: Name Type Description Default instances Sequence [ ODMEngine . ModelType ] instances to persist required Returns: Type Description List [ ODMEngine . ModelType ] the saved instances NOTE The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. Source code in odmantic/session.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 async def save_all ( self , instances : Sequence [ ODMEngine . ModelType ], ) -> List [ ODMEngine . ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist Returns: the saved instances NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. \"\"\" return await self . engine . save_all ( instances , session = self . engine . _get_session ( self ) ) odmantic.engine.SyncSession \u00b6 Bases: SyncSessionBase , ContextManager A session object for ordering sequential operations. Sessions can be created from the engine directly by using the SyncEngine.session method. Example usage as a context manager: engine = SyncEngine ( ... ) with engine . session () as session : john = session . find ( User , User . name == \"John\" ) john . name = \"Doe\" session . save ( john ) Example raw usage: engine = SyncEngine ( ... ) session = engine . session () session . start () john = session . find ( User , User . name == \"John\" ) john . name = \"Doe\" session . save ( john ) session . end () Source code in odmantic/session.py 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 class SyncSession ( SyncSessionBase , ContextManager ): \"\"\"A session object for ordering sequential operations. Sessions can be created from the engine directly by using the [SyncEngine.session][odmantic.engine.SyncEngine.session] method. Example usage as a context manager: ```python engine = SyncEngine(...) with engine.session() as session: john = session.find(User, User.name == \"John\") john.name = \"Doe\" session.save(john) ``` Example raw usage: ```python engine = SyncEngine(...) session = engine.session() session.start() john = session.find(User, User.name == \"John\") john.name = \"Doe\" session.save(john) session.end() ``` \"\"\" def __init__ ( self , engine : ODMEngine . SyncEngine ): self . engine = engine self . session : Optional [ ClientSession ] = None @property def is_started ( self ) -> bool : return self . session is not None def get_driver_session ( self ) -> ClientSession : \"\"\"Return the underlying PyMongo Session\"\"\" if self . session is None : raise RuntimeError ( \"session not started\" ) return self . session def start ( self ) -> None : \"\"\"Start the logical session.\"\"\" if self . is_started : raise RuntimeError ( \"Session is already started\" ) self . session = self . engine . client . start_session () def end ( self ) -> None : \"\"\"Finish the logical session.\"\"\" if self . session is None : raise RuntimeError ( \"Session is not started\" ) self . session . end_session () self . session = None def __enter__ ( self ) -> \"SyncSession\" : self . start () return self def __exit__ ( self , exc_type : Optional [ Type [ BaseException ]], exc : Optional [ BaseException ], traceback : Optional [ TracebackType ], ) -> None : self . end () def transaction ( self ) -> SyncTransaction : \"\"\"Create a transaction in the existing session\"\"\" return SyncTransaction ( self ) end () \u00b6 Finish the logical session. Source code in odmantic/session.py 589 590 591 592 593 594 def end ( self ) -> None : \"\"\"Finish the logical session.\"\"\" if self . session is None : raise RuntimeError ( \"Session is not started\" ) self . session . end_session () self . session = None get_driver_session () \u00b6 Return the underlying PyMongo Session Source code in odmantic/session.py 577 578 579 580 581 def get_driver_session ( self ) -> ClientSession : \"\"\"Return the underlying PyMongo Session\"\"\" if self . session is None : raise RuntimeError ( \"session not started\" ) return self . session start () \u00b6 Start the logical session. Source code in odmantic/session.py 583 584 585 586 587 def start ( self ) -> None : \"\"\"Start the logical session.\"\"\" if self . is_started : raise RuntimeError ( \"Session is already started\" ) self . session = self . engine . client . start_session () transaction () \u00b6 Create a transaction in the existing session Source code in odmantic/session.py 608 609 610 def transaction ( self ) -> SyncTransaction : \"\"\"Create a transaction in the existing session\"\"\" return SyncTransaction ( self ) odmantic.engine.SyncTransaction \u00b6 Bases: SyncSessionBase , ContextManager A transaction object to aggregate sequential operations. Transactions can be created from the engine using the SyncEngine.transaction method or they can be created during an existing session by using SyncSession.transaction . Example usage as a context manager: engine = SyncEngine ( ... ) with engine . transaction () as transaction : john = transaction . find ( User , User . name == \"John\" ) john . name = \"Doe\" transaction . save ( john ) transaction . commit () Example raw usage: engine = SyncEngine ( ... ) transaction = engine . transaction () transaction . start () john = transaction . find ( User , User . name == \"John\" ) john . name = \"Doe\" transaction . save ( john ) transaction . commit () Warning MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled. Source code in odmantic/session.py 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 class SyncTransaction ( SyncSessionBase , ContextManager ): \"\"\"A transaction object to aggregate sequential operations. Transactions can be created from the engine using the [SyncEngine.transaction][odmantic.engine.SyncEngine.transaction] method or they can be created during an existing session by using [SyncSession.transaction][odmantic.session.SyncSession.transaction]. Example usage as a context manager: ```python engine = SyncEngine(...) with engine.transaction() as transaction: john = transaction.find(User, User.name == \"John\") john.name = \"Doe\" transaction.save(john) transaction.commit() ``` Example raw usage: ```python engine = SyncEngine(...) transaction = engine.transaction() transaction.start() john = transaction.find(User, User.name == \"John\") john.name = \"Doe\" transaction.save(john) transaction.commit() ``` Warning: MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled. \"\"\" def __init__ ( self , context : Union [ ODMEngine . SyncEngine , ODMEngine . SyncSession ]): self . _session_provided = isinstance ( context , ODMEngine . SyncSession ) if self . _session_provided : assert isinstance ( context , ODMEngine . SyncSession ) if not context . is_started : raise RuntimeError ( \"provided session is not started\" ) self . session = context self . engine = context . engine else : assert isinstance ( context , ODMEngine . SyncEngine ) self . session = SyncSession ( context ) self . engine = context self . _transaction_started = False self . _transaction_context : Optional [ ContextManager ] = None def get_driver_session ( self ) -> ClientSession : \"\"\"Return the underlying PyMongo Session\"\"\" if not self . _transaction_started : raise RuntimeError ( \"transaction not started\" ) return self . session . get_driver_session () def start ( self ) -> None : \"\"\"Initiate the transaction.\"\"\" if self . _transaction_started : raise RuntimeError ( \"Transaction already started\" ) if not self . _session_provided : self . session . start () assert self . session . session is not None self . _transaction_context = self . session . session . start_transaction () . __enter__ () self . _transaction_started = True def commit ( self ) -> None : \"\"\"Commit the changes and close the transaction.\"\"\" if not self . _transaction_started : raise RuntimeError ( \"Transaction not started\" ) assert self . session . session is not None self . session . session . commit_transaction () self . _transaction_started = False if not self . _session_provided : self . session . end () def abort ( self ) -> None : \"\"\"Discard the changes and drop the transaction.\"\"\" if not self . _transaction_started : raise RuntimeError ( \"Transaction not started\" ) assert self . session . session is not None self . session . session . abort_transaction () self . _transaction_started = False if not self . _session_provided : self . session . end () def __enter__ ( self ) -> \"SyncTransaction\" : self . start () return self def __exit__ ( self , exc_type : Optional [ Type [ BaseException ]], exc : Optional [ BaseException ], traceback : Optional [ TracebackType ], ) -> None : assert self . _transaction_context is not None self . _transaction_context . __exit__ ( exc_type , exc , traceback ) self . _transaction_started = False abort () \u00b6 Discard the changes and drop the transaction. Source code in odmantic/session.py 689 690 691 692 693 694 695 696 697 def abort ( self ) -> None : \"\"\"Discard the changes and drop the transaction.\"\"\" if not self . _transaction_started : raise RuntimeError ( \"Transaction not started\" ) assert self . session . session is not None self . session . session . abort_transaction () self . _transaction_started = False if not self . _session_provided : self . session . end () commit () \u00b6 Commit the changes and close the transaction. Source code in odmantic/session.py 679 680 681 682 683 684 685 686 687 def commit ( self ) -> None : \"\"\"Commit the changes and close the transaction.\"\"\" if not self . _transaction_started : raise RuntimeError ( \"Transaction not started\" ) assert self . session . session is not None self . session . session . commit_transaction () self . _transaction_started = False if not self . _session_provided : self . session . end () get_driver_session () \u00b6 Return the underlying PyMongo Session Source code in odmantic/session.py 663 664 665 666 667 def get_driver_session ( self ) -> ClientSession : \"\"\"Return the underlying PyMongo Session\"\"\" if not self . _transaction_started : raise RuntimeError ( \"transaction not started\" ) return self . session . get_driver_session () start () \u00b6 Initiate the transaction. Source code in odmantic/session.py 669 670 671 672 673 674 675 676 677 def start ( self ) -> None : \"\"\"Initiate the transaction.\"\"\" if self . _transaction_started : raise RuntimeError ( \"Transaction already started\" ) if not self . _session_provided : self . session . start () assert self . session . session is not None self . _transaction_context = self . session . session . start_transaction () . __enter__ () self . _transaction_started = True odmantic.engine.SyncSessionBase \u00b6 Source code in odmantic/session.py 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 class SyncSessionBase ( metaclass = ABCMeta ): engine : ODMEngine . SyncEngine def find ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , ) -> ODMEngine . SyncCursor [ ODMEngine . ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched Returns: [odmantic.engine.SyncCursor][] of the query \"\"\" return self . engine . find ( model , * queries , sort = sort , skip = skip , limit = limit , session = self . engine . _get_session ( self ), ) def find_one ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin sort : Optional [ Any ] = None , ) -> Optional [ ODMEngine . ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression Raises: DocumentParsingError: unable to parse the resulting document Returns: the fetched instance if found otherwise None <!--- #noqa: DAR402 DocumentParsingError --> \"\"\" return self . engine . find_one ( model , * queries , sort = sort , session = self . engine . _get_session ( self ) ) def count ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on *queries: query filters to apply Returns: number of document matching the query \"\"\" return self . engine . count ( model , * queries , session = self . engine . _get_session ( self ) ) def save ( self , instance : ODMEngine . ModelType , ) -> ODMEngine . ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist Returns: the saved instance NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. \"\"\" return self . engine . save ( instance , session = self . engine . _get_session ( self )) def save_all ( self , instances : Sequence [ ODMEngine . ModelType ], ) -> List [ ODMEngine . ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist Returns: the saved instances NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. \"\"\" return self . engine . save_all ( instances , session = self . engine . _get_session ( self )) def delete ( self , instance : ODMEngine . ModelType , ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete Raises: DocumentNotFoundError: the instance has not been persisted to the database <!--- #noqa: DAR402 DocumentNotFoundError #noqa: DAR201 --> \"\"\" return self . engine . delete ( instance , session = self . engine . _get_session ( self )) def remove ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], just_one : bool = False , ) -> int : \"\"\"Delete Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply just_one: limit the deletion to just one document Returns: the number of instances deleted from the database. \"\"\" return self . engine . remove ( model , * queries , just_one = just_one , session = self . engine . _get_session ( self ) ) count ( model , * queries ) \u00b6 Get the count of documents matching a query Parameters: Name Type Description Default model Type [ ODMEngine . ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filters to apply () Returns: Type Description int number of document matching the query Source code in odmantic/session.py 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 def count ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on *queries: query filters to apply Returns: number of document matching the query \"\"\" return self . engine . count ( model , * queries , session = self . engine . _get_session ( self ) ) delete ( instance ) \u00b6 Delete an instance from the database Parameters: Name Type Description Default instance ODMEngine . ModelType the instance to delete required Raises: Type Description DocumentNotFoundError the instance has not been persisted to the database Source code in odmantic/session.py 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 def delete ( self , instance : ODMEngine . ModelType , ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete Raises: DocumentNotFoundError: the instance has not been persisted to the database <!--- #noqa: DAR402 DocumentNotFoundError #noqa: DAR201 --> \"\"\" return self . engine . delete ( instance , session = self . engine . _get_session ( self )) find ( model , * queries , sort = None , skip = 0 , limit = None ) \u00b6 Search for Model instances matching the query filter provided Parameters: Name Type Description Default model Type [ ODMEngine . ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () sort Optional [ Any ] sort expression None skip int number of document to skip 0 limit Optional [ int ] maximum number of instance fetched None Returns: Type Description ODMEngine . SyncCursor [ ODMEngine . ModelType ] odmantic.engine.SyncCursor of the query Source code in odmantic/session.py 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 def find ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , ) -> ODMEngine . SyncCursor [ ODMEngine . ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched Returns: [odmantic.engine.SyncCursor][] of the query \"\"\" return self . engine . find ( model , * queries , sort = sort , skip = skip , limit = limit , session = self . engine . _get_session ( self ), ) find_one ( model , * queries , sort = None ) \u00b6 Search for a Model instance matching the query filter provided Parameters: Name Type Description Default model Type [ ODMEngine . ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () sort Optional [ Any ] sort expression None Raises: Type Description DocumentParsingError unable to parse the resulting document Returns: Type Description Optional [ ODMEngine . ModelType ] the fetched instance if found otherwise None Source code in odmantic/session.py 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 def find_one ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin sort : Optional [ Any ] = None , ) -> Optional [ ODMEngine . ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression Raises: DocumentParsingError: unable to parse the resulting document Returns: the fetched instance if found otherwise None <!--- #noqa: DAR402 DocumentParsingError --> \"\"\" return self . engine . find_one ( model , * queries , sort = sort , session = self . engine . _get_session ( self ) ) remove ( model , * queries , just_one = False ) \u00b6 Delete Model instances matching the query filter provided Parameters: Name Type Description Default model Type [ ODMEngine . ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () just_one bool limit the deletion to just one document False Returns: Type Description int the number of instances deleted from the database. Source code in odmantic/session.py 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 def remove ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], just_one : bool = False , ) -> int : \"\"\"Delete Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply just_one: limit the deletion to just one document Returns: the number of instances deleted from the database. \"\"\" return self . engine . remove ( model , * queries , just_one = just_one , session = self . engine . _get_session ( self ) ) save ( instance ) \u00b6 Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Parameters: Name Type Description Default instance ODMEngine . ModelType instance to persist required Returns: Type Description ODMEngine . ModelType the saved instance NOTE The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. Source code in odmantic/session.py 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 def save ( self , instance : ODMEngine . ModelType , ) -> ODMEngine . ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist Returns: the saved instance NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. \"\"\" return self . engine . save ( instance , session = self . engine . _get_session ( self )) save_all ( instances ) \u00b6 Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Parameters: Name Type Description Default instances Sequence [ ODMEngine . ModelType ] instances to persist required Returns: Type Description List [ ODMEngine . ModelType ] the saved instances NOTE The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. Source code in odmantic/session.py 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 def save_all ( self , instances : Sequence [ ODMEngine . ModelType ], ) -> List [ ODMEngine . ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist Returns: the saved instances NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. \"\"\" return self . engine . save_all ( instances , session = self . engine . _get_session ( self ))","title":"odmantic.session"},{"location":"api_reference/session/#odmantic.session.AIOSession","text":"Bases: AIOSessionBase , AsyncContextManager An AsyncIO session object for ordering sequential operations. Sessions can be created from the engine directly by using the AIOEngine.session method. Example usage as a context manager: engine = AIOEngine ( ... ) async with engine . session () as session : john = await session . find ( User , User . name == \"John\" ) john . name = \"Doe\" await session . save ( john ) Example raw usage: engine = AIOEngine ( ... ) session = engine . session () await session . start () john = await session . find ( User , User . name == \"John\" ) john . name = \"Doe\" await session . save ( john ) await session . end () Source code in odmantic/session.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 class AIOSession ( AIOSessionBase , AsyncContextManager ): \"\"\"An AsyncIO session object for ordering sequential operations. Sessions can be created from the engine directly by using the [AIOEngine.session][odmantic.engine.AIOEngine.session] method. Example usage as a context manager: ```python engine = AIOEngine(...) async with engine.session() as session: john = await session.find(User, User.name == \"John\") john.name = \"Doe\" await session.save(john) ``` Example raw usage: ```python engine = AIOEngine(...) session = engine.session() await session.start() john = await session.find(User, User.name == \"John\") john.name = \"Doe\" await session.save(john) await session.end() ``` \"\"\" def __init__ ( self , engine : ODMEngine . AIOEngine ): self . engine = engine self . session : Optional [ AsyncIOMotorClientSession ] = None @property def is_started ( self ) -> bool : return self . session is not None def get_driver_session ( self ) -> AsyncIOMotorClientSession : \"\"\"Return the underlying Motor Session\"\"\" if self . session is None : raise RuntimeError ( \"session not started\" ) return self . session async def start ( self ) -> None : \"\"\"Start the logical Mongo session.\"\"\" if self . is_started : raise RuntimeError ( \"Session is already started\" ) self . session = await self . engine . client . start_session () async def end ( self ) -> None : \"\"\"Finish the logical session.\"\"\" if self . session is None : raise RuntimeError ( \"Session is not started\" ) await self . session . end_session () self . session = None async def __aenter__ ( self ) -> \"AIOSession\" : await self . start () return self async def __aexit__ ( self , exc_type : Optional [ Type [ BaseException ]], exc : Optional [ BaseException ], traceback : Optional [ TracebackType ], ) -> None : await self . end () def transaction ( self ) -> AIOTransaction : \"\"\"Create a transaction in the existing session\"\"\" return AIOTransaction ( self )","title":"AIOSession"},{"location":"api_reference/session/#odmantic.session.AIOSession.end","text":"Finish the logical session. Source code in odmantic/session.py 245 246 247 248 249 250 async def end ( self ) -> None : \"\"\"Finish the logical session.\"\"\" if self . session is None : raise RuntimeError ( \"Session is not started\" ) await self . session . end_session () self . session = None","title":"end()"},{"location":"api_reference/session/#odmantic.session.AIOSession.get_driver_session","text":"Return the underlying Motor Session Source code in odmantic/session.py 233 234 235 236 237 def get_driver_session ( self ) -> AsyncIOMotorClientSession : \"\"\"Return the underlying Motor Session\"\"\" if self . session is None : raise RuntimeError ( \"session not started\" ) return self . session","title":"get_driver_session()"},{"location":"api_reference/session/#odmantic.session.AIOSession.start","text":"Start the logical Mongo session. Source code in odmantic/session.py 239 240 241 242 243 async def start ( self ) -> None : \"\"\"Start the logical Mongo session.\"\"\" if self . is_started : raise RuntimeError ( \"Session is already started\" ) self . session = await self . engine . client . start_session ()","title":"start()"},{"location":"api_reference/session/#odmantic.session.AIOSession.transaction","text":"Create a transaction in the existing session Source code in odmantic/session.py 264 265 266 def transaction ( self ) -> AIOTransaction : \"\"\"Create a transaction in the existing session\"\"\" return AIOTransaction ( self )","title":"transaction()"},{"location":"api_reference/session/#odmantic.engine.AIOTransaction","text":"Bases: AIOSessionBase , AsyncContextManager A transaction object to aggregate sequential operations. Transactions can be created from the engine using the AIOEngine.transaction method or they can be created during an existing session by using AIOSession.transaction . Example usage as a context manager: engine = AIOEngine ( ... ) async with engine . transaction () as transaction : john = await transaction . find ( User , User . name == \"John\" ) john . name = \"Doe\" await transaction . save ( john ) await transaction . commit () Example raw usage: engine = AIOEngine ( ... ) transaction = engine . transaction () await transaction . start () john = await transaction . find ( User , User . name == \"John\" ) john . name = \"Doe\" await transaction . save ( john ) await transaction . commit () Warning MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled. Source code in odmantic/session.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 class AIOTransaction ( AIOSessionBase , AsyncContextManager ): \"\"\"A transaction object to aggregate sequential operations. Transactions can be created from the engine using the [AIOEngine.transaction][odmantic.engine.AIOEngine.transaction] method or they can be created during an existing session by using [AIOSession.transaction][odmantic.session.AIOSession.transaction]. Example usage as a context manager: ```python engine = AIOEngine(...) async with engine.transaction() as transaction: john = await transaction.find(User, User.name == \"John\") john.name = \"Doe\" await transaction.save(john) await transaction.commit() ``` Example raw usage: ```python engine = AIOEngine(...) transaction = engine.transaction() await transaction.start() john = await transaction.find(User, User.name == \"John\") john.name = \"Doe\" await transaction.save(john) await transaction.commit() ``` Warning: MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled. \"\"\" def __init__ ( self , context : Union [ ODMEngine . AIOEngine , ODMEngine . AIOSession ]): self . _session_provided = isinstance ( context , ODMEngine . AIOSession ) if self . _session_provided : assert isinstance ( context , ODMEngine . AIOSession ) if not context . is_started : raise RuntimeError ( \"provided session is not started\" ) self . session = context self . engine = context . engine else : assert isinstance ( context , ODMEngine . AIOEngine ) self . session = AIOSession ( context ) self . engine = context self . _transaction_started = False self . _transaction_context : Optional [ AsyncContextManager ] = None def get_driver_session ( self ) -> AsyncIOMotorClientSession : \"\"\"Return the underlying Motor Session\"\"\" if not self . _transaction_started : raise RuntimeError ( \"transaction not started\" ) return self . session . get_driver_session () async def start ( self ) -> None : \"\"\"Initiate the transaction.\"\"\" if self . _transaction_started : raise RuntimeError ( \"Transaction already started\" ) if not self . _session_provided : await self . session . start () assert self . session . session is not None self . _transaction_context = ( await self . session . session . start_transaction () . __aenter__ () ) self . _transaction_started = True async def commit ( self ) -> None : \"\"\"Commit the changes and close the transaction.\"\"\" if not self . _transaction_started : raise RuntimeError ( \"Transaction not started\" ) assert self . session . session is not None await self . session . session . commit_transaction () self . _transaction_started = False if not self . _session_provided : await self . session . end () async def abort ( self ) -> None : \"\"\"Discard the changes and drop the transaction\"\"\" if not self . _transaction_started : raise RuntimeError ( \"Transaction not started\" ) assert self . session . session is not None await self . session . session . abort_transaction () self . _transaction_started = False if not self . _session_provided : await self . session . end () async def __aenter__ ( self ) -> \"AIOTransaction\" : await self . start () return self async def __aexit__ ( self , exc_type : Optional [ Type [ BaseException ]], exc : Optional [ BaseException ], traceback : Optional [ TracebackType ], ) -> None : assert self . _transaction_context is not None await self . _transaction_context . __aexit__ ( exc_type , exc , traceback ) self . _transaction_started = False","title":"AIOTransaction"},{"location":"api_reference/session/#odmantic.session.AIOTransaction.abort","text":"Discard the changes and drop the transaction Source code in odmantic/session.py 347 348 349 350 351 352 353 354 355 async def abort ( self ) -> None : \"\"\"Discard the changes and drop the transaction\"\"\" if not self . _transaction_started : raise RuntimeError ( \"Transaction not started\" ) assert self . session . session is not None await self . session . session . abort_transaction () self . _transaction_started = False if not self . _session_provided : await self . session . end ()","title":"abort()"},{"location":"api_reference/session/#odmantic.session.AIOTransaction.commit","text":"Commit the changes and close the transaction. Source code in odmantic/session.py 337 338 339 340 341 342 343 344 345 async def commit ( self ) -> None : \"\"\"Commit the changes and close the transaction.\"\"\" if not self . _transaction_started : raise RuntimeError ( \"Transaction not started\" ) assert self . session . session is not None await self . session . session . commit_transaction () self . _transaction_started = False if not self . _session_provided : await self . session . end ()","title":"commit()"},{"location":"api_reference/session/#odmantic.session.AIOTransaction.get_driver_session","text":"Return the underlying Motor Session Source code in odmantic/session.py 319 320 321 322 323 def get_driver_session ( self ) -> AsyncIOMotorClientSession : \"\"\"Return the underlying Motor Session\"\"\" if not self . _transaction_started : raise RuntimeError ( \"transaction not started\" ) return self . session . get_driver_session ()","title":"get_driver_session()"},{"location":"api_reference/session/#odmantic.session.AIOTransaction.start","text":"Initiate the transaction. Source code in odmantic/session.py 325 326 327 328 329 330 331 332 333 334 335 async def start ( self ) -> None : \"\"\"Initiate the transaction.\"\"\" if self . _transaction_started : raise RuntimeError ( \"Transaction already started\" ) if not self . _session_provided : await self . session . start () assert self . session . session is not None self . _transaction_context = ( await self . session . session . start_transaction () . __aenter__ () ) self . _transaction_started = True","title":"start()"},{"location":"api_reference/session/#odmantic.session.AIOSessionBase","text":"Source code in odmantic/session.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 class AIOSessionBase ( metaclass = ABCMeta ): engine : ODMEngine . AIOEngine def find ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , ) -> ODMEngine . AIOCursor [ ODMEngine . ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched Returns: [odmantic.engine.AIOCursor][] of the query \"\"\" return self . engine . find ( model , * queries , sort = sort , skip = skip , limit = limit , session = self . engine . _get_session ( self ), ) async def find_one ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin sort : Optional [ Any ] = None , ) -> Optional [ ODMEngine . ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression Raises: DocumentParsingError: unable to parse the resulting document Returns: the fetched instance if found otherwise None <!--- #noqa: DAR402 DocumentParsingError --> \"\"\" return await self . engine . find_one ( model , * queries , sort = sort , session = self . engine . _get_session ( self ) ) async def count ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on *queries: query filters to apply Returns: number of document matching the query \"\"\" return await self . engine . count ( model , * queries , session = self . engine . _get_session ( self ) ) async def save ( self , instance : ODMEngine . ModelType , ) -> ODMEngine . ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist Returns: the saved instance NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. \"\"\" return await self . engine . save ( instance , session = self . engine . _get_session ( self )) async def save_all ( self , instances : Sequence [ ODMEngine . ModelType ], ) -> List [ ODMEngine . ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist Returns: the saved instances NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. \"\"\" return await self . engine . save_all ( instances , session = self . engine . _get_session ( self ) ) async def delete ( self , instance : ODMEngine . ModelType , ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete Raises: DocumentNotFoundError: the instance has not been persisted to the database <!--- #noqa: DAR402 DocumentNotFoundError #noqa: DAR201 --> \"\"\" return await self . engine . delete ( instance , session = self . engine . _get_session ( self ) ) async def remove ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], just_one : bool = False , ) -> int : \"\"\"Delete Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply just_one: limit the deletion to just one document Returns: the number of instances deleted from the database. \"\"\" return await self . engine . remove ( model , * queries , just_one = just_one , session = self . engine . _get_session ( self ) )","title":"AIOSessionBase"},{"location":"api_reference/session/#odmantic.session.AIOSessionBase.count","text":"Get the count of documents matching a query Parameters: Name Type Description Default model Type [ ODMEngine . ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filters to apply () Returns: Type Description int number of document matching the query Source code in odmantic/session.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 async def count ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on *queries: query filters to apply Returns: number of document matching the query \"\"\" return await self . engine . count ( model , * queries , session = self . engine . _get_session ( self ) )","title":"count()"},{"location":"api_reference/session/#odmantic.session.AIOSessionBase.delete","text":"Delete an instance from the database Parameters: Name Type Description Default instance ODMEngine . ModelType the instance to delete required Raises: Type Description DocumentNotFoundError the instance has not been persisted to the database Source code in odmantic/session.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 async def delete ( self , instance : ODMEngine . ModelType , ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete Raises: DocumentNotFoundError: the instance has not been persisted to the database <!--- #noqa: DAR402 DocumentNotFoundError #noqa: DAR201 --> \"\"\" return await self . engine . delete ( instance , session = self . engine . _get_session ( self ) )","title":"delete()"},{"location":"api_reference/session/#odmantic.session.AIOSessionBase.find","text":"Search for Model instances matching the query filter provided Parameters: Name Type Description Default model Type [ ODMEngine . ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () sort Optional [ Any ] sort expression None skip int number of document to skip 0 limit Optional [ int ] maximum number of instance fetched None Returns: Type Description ODMEngine . AIOCursor [ ODMEngine . ModelType ] odmantic.engine.AIOCursor of the query Source code in odmantic/session.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def find ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , ) -> ODMEngine . AIOCursor [ ODMEngine . ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched Returns: [odmantic.engine.AIOCursor][] of the query \"\"\" return self . engine . find ( model , * queries , sort = sort , skip = skip , limit = limit , session = self . engine . _get_session ( self ), )","title":"find()"},{"location":"api_reference/session/#odmantic.session.AIOSessionBase.find_one","text":"Search for a Model instance matching the query filter provided Parameters: Name Type Description Default model Type [ ODMEngine . ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () sort Optional [ Any ] sort expression None Raises: Type Description DocumentParsingError unable to parse the resulting document Returns: Type Description Optional [ ODMEngine . ModelType ] the fetched instance if found otherwise None Source code in odmantic/session.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 async def find_one ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin sort : Optional [ Any ] = None , ) -> Optional [ ODMEngine . ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression Raises: DocumentParsingError: unable to parse the resulting document Returns: the fetched instance if found otherwise None <!--- #noqa: DAR402 DocumentParsingError --> \"\"\" return await self . engine . find_one ( model , * queries , sort = sort , session = self . engine . _get_session ( self ) )","title":"find_one()"},{"location":"api_reference/session/#odmantic.session.AIOSessionBase.remove","text":"Delete Model instances matching the query filter provided Parameters: Name Type Description Default model Type [ ODMEngine . ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () just_one bool limit the deletion to just one document False Returns: Type Description int the number of instances deleted from the database. Source code in odmantic/session.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 async def remove ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], just_one : bool = False , ) -> int : \"\"\"Delete Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply just_one: limit the deletion to just one document Returns: the number of instances deleted from the database. \"\"\" return await self . engine . remove ( model , * queries , just_one = just_one , session = self . engine . _get_session ( self ) )","title":"remove()"},{"location":"api_reference/session/#odmantic.session.AIOSessionBase.save","text":"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Parameters: Name Type Description Default instance ODMEngine . ModelType instance to persist required Returns: Type Description ODMEngine . ModelType the saved instance NOTE The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. Source code in odmantic/session.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 async def save ( self , instance : ODMEngine . ModelType , ) -> ODMEngine . ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist Returns: the saved instance NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. \"\"\" return await self . engine . save ( instance , session = self . engine . _get_session ( self ))","title":"save()"},{"location":"api_reference/session/#odmantic.session.AIOSessionBase.save_all","text":"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Parameters: Name Type Description Default instances Sequence [ ODMEngine . ModelType ] instances to persist required Returns: Type Description List [ ODMEngine . ModelType ] the saved instances NOTE The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. Source code in odmantic/session.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 async def save_all ( self , instances : Sequence [ ODMEngine . ModelType ], ) -> List [ ODMEngine . ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist Returns: the saved instances NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. \"\"\" return await self . engine . save_all ( instances , session = self . engine . _get_session ( self ) )","title":"save_all()"},{"location":"api_reference/session/#odmantic.engine.SyncSession","text":"Bases: SyncSessionBase , ContextManager A session object for ordering sequential operations. Sessions can be created from the engine directly by using the SyncEngine.session method. Example usage as a context manager: engine = SyncEngine ( ... ) with engine . session () as session : john = session . find ( User , User . name == \"John\" ) john . name = \"Doe\" session . save ( john ) Example raw usage: engine = SyncEngine ( ... ) session = engine . session () session . start () john = session . find ( User , User . name == \"John\" ) john . name = \"Doe\" session . save ( john ) session . end () Source code in odmantic/session.py 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 class SyncSession ( SyncSessionBase , ContextManager ): \"\"\"A session object for ordering sequential operations. Sessions can be created from the engine directly by using the [SyncEngine.session][odmantic.engine.SyncEngine.session] method. Example usage as a context manager: ```python engine = SyncEngine(...) with engine.session() as session: john = session.find(User, User.name == \"John\") john.name = \"Doe\" session.save(john) ``` Example raw usage: ```python engine = SyncEngine(...) session = engine.session() session.start() john = session.find(User, User.name == \"John\") john.name = \"Doe\" session.save(john) session.end() ``` \"\"\" def __init__ ( self , engine : ODMEngine . SyncEngine ): self . engine = engine self . session : Optional [ ClientSession ] = None @property def is_started ( self ) -> bool : return self . session is not None def get_driver_session ( self ) -> ClientSession : \"\"\"Return the underlying PyMongo Session\"\"\" if self . session is None : raise RuntimeError ( \"session not started\" ) return self . session def start ( self ) -> None : \"\"\"Start the logical session.\"\"\" if self . is_started : raise RuntimeError ( \"Session is already started\" ) self . session = self . engine . client . start_session () def end ( self ) -> None : \"\"\"Finish the logical session.\"\"\" if self . session is None : raise RuntimeError ( \"Session is not started\" ) self . session . end_session () self . session = None def __enter__ ( self ) -> \"SyncSession\" : self . start () return self def __exit__ ( self , exc_type : Optional [ Type [ BaseException ]], exc : Optional [ BaseException ], traceback : Optional [ TracebackType ], ) -> None : self . end () def transaction ( self ) -> SyncTransaction : \"\"\"Create a transaction in the existing session\"\"\" return SyncTransaction ( self )","title":"SyncSession"},{"location":"api_reference/session/#odmantic.session.SyncSession.end","text":"Finish the logical session. Source code in odmantic/session.py 589 590 591 592 593 594 def end ( self ) -> None : \"\"\"Finish the logical session.\"\"\" if self . session is None : raise RuntimeError ( \"Session is not started\" ) self . session . end_session () self . session = None","title":"end()"},{"location":"api_reference/session/#odmantic.session.SyncSession.get_driver_session","text":"Return the underlying PyMongo Session Source code in odmantic/session.py 577 578 579 580 581 def get_driver_session ( self ) -> ClientSession : \"\"\"Return the underlying PyMongo Session\"\"\" if self . session is None : raise RuntimeError ( \"session not started\" ) return self . session","title":"get_driver_session()"},{"location":"api_reference/session/#odmantic.session.SyncSession.start","text":"Start the logical session. Source code in odmantic/session.py 583 584 585 586 587 def start ( self ) -> None : \"\"\"Start the logical session.\"\"\" if self . is_started : raise RuntimeError ( \"Session is already started\" ) self . session = self . engine . client . start_session ()","title":"start()"},{"location":"api_reference/session/#odmantic.session.SyncSession.transaction","text":"Create a transaction in the existing session Source code in odmantic/session.py 608 609 610 def transaction ( self ) -> SyncTransaction : \"\"\"Create a transaction in the existing session\"\"\" return SyncTransaction ( self )","title":"transaction()"},{"location":"api_reference/session/#odmantic.engine.SyncTransaction","text":"Bases: SyncSessionBase , ContextManager A transaction object to aggregate sequential operations. Transactions can be created from the engine using the SyncEngine.transaction method or they can be created during an existing session by using SyncSession.transaction . Example usage as a context manager: engine = SyncEngine ( ... ) with engine . transaction () as transaction : john = transaction . find ( User , User . name == \"John\" ) john . name = \"Doe\" transaction . save ( john ) transaction . commit () Example raw usage: engine = SyncEngine ( ... ) transaction = engine . transaction () transaction . start () john = transaction . find ( User , User . name == \"John\" ) john . name = \"Doe\" transaction . save ( john ) transaction . commit () Warning MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled. Source code in odmantic/session.py 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 class SyncTransaction ( SyncSessionBase , ContextManager ): \"\"\"A transaction object to aggregate sequential operations. Transactions can be created from the engine using the [SyncEngine.transaction][odmantic.engine.SyncEngine.transaction] method or they can be created during an existing session by using [SyncSession.transaction][odmantic.session.SyncSession.transaction]. Example usage as a context manager: ```python engine = SyncEngine(...) with engine.transaction() as transaction: john = transaction.find(User, User.name == \"John\") john.name = \"Doe\" transaction.save(john) transaction.commit() ``` Example raw usage: ```python engine = SyncEngine(...) transaction = engine.transaction() transaction.start() john = transaction.find(User, User.name == \"John\") john.name = \"Doe\" transaction.save(john) transaction.commit() ``` Warning: MongoDB transaction are only supported on replicated clusters: either directly a replicaSet or a sharded cluster with replication enabled. \"\"\" def __init__ ( self , context : Union [ ODMEngine . SyncEngine , ODMEngine . SyncSession ]): self . _session_provided = isinstance ( context , ODMEngine . SyncSession ) if self . _session_provided : assert isinstance ( context , ODMEngine . SyncSession ) if not context . is_started : raise RuntimeError ( \"provided session is not started\" ) self . session = context self . engine = context . engine else : assert isinstance ( context , ODMEngine . SyncEngine ) self . session = SyncSession ( context ) self . engine = context self . _transaction_started = False self . _transaction_context : Optional [ ContextManager ] = None def get_driver_session ( self ) -> ClientSession : \"\"\"Return the underlying PyMongo Session\"\"\" if not self . _transaction_started : raise RuntimeError ( \"transaction not started\" ) return self . session . get_driver_session () def start ( self ) -> None : \"\"\"Initiate the transaction.\"\"\" if self . _transaction_started : raise RuntimeError ( \"Transaction already started\" ) if not self . _session_provided : self . session . start () assert self . session . session is not None self . _transaction_context = self . session . session . start_transaction () . __enter__ () self . _transaction_started = True def commit ( self ) -> None : \"\"\"Commit the changes and close the transaction.\"\"\" if not self . _transaction_started : raise RuntimeError ( \"Transaction not started\" ) assert self . session . session is not None self . session . session . commit_transaction () self . _transaction_started = False if not self . _session_provided : self . session . end () def abort ( self ) -> None : \"\"\"Discard the changes and drop the transaction.\"\"\" if not self . _transaction_started : raise RuntimeError ( \"Transaction not started\" ) assert self . session . session is not None self . session . session . abort_transaction () self . _transaction_started = False if not self . _session_provided : self . session . end () def __enter__ ( self ) -> \"SyncTransaction\" : self . start () return self def __exit__ ( self , exc_type : Optional [ Type [ BaseException ]], exc : Optional [ BaseException ], traceback : Optional [ TracebackType ], ) -> None : assert self . _transaction_context is not None self . _transaction_context . __exit__ ( exc_type , exc , traceback ) self . _transaction_started = False","title":"SyncTransaction"},{"location":"api_reference/session/#odmantic.session.SyncTransaction.abort","text":"Discard the changes and drop the transaction. Source code in odmantic/session.py 689 690 691 692 693 694 695 696 697 def abort ( self ) -> None : \"\"\"Discard the changes and drop the transaction.\"\"\" if not self . _transaction_started : raise RuntimeError ( \"Transaction not started\" ) assert self . session . session is not None self . session . session . abort_transaction () self . _transaction_started = False if not self . _session_provided : self . session . end ()","title":"abort()"},{"location":"api_reference/session/#odmantic.session.SyncTransaction.commit","text":"Commit the changes and close the transaction. Source code in odmantic/session.py 679 680 681 682 683 684 685 686 687 def commit ( self ) -> None : \"\"\"Commit the changes and close the transaction.\"\"\" if not self . _transaction_started : raise RuntimeError ( \"Transaction not started\" ) assert self . session . session is not None self . session . session . commit_transaction () self . _transaction_started = False if not self . _session_provided : self . session . end ()","title":"commit()"},{"location":"api_reference/session/#odmantic.session.SyncTransaction.get_driver_session","text":"Return the underlying PyMongo Session Source code in odmantic/session.py 663 664 665 666 667 def get_driver_session ( self ) -> ClientSession : \"\"\"Return the underlying PyMongo Session\"\"\" if not self . _transaction_started : raise RuntimeError ( \"transaction not started\" ) return self . session . get_driver_session ()","title":"get_driver_session()"},{"location":"api_reference/session/#odmantic.session.SyncTransaction.start","text":"Initiate the transaction. Source code in odmantic/session.py 669 670 671 672 673 674 675 676 677 def start ( self ) -> None : \"\"\"Initiate the transaction.\"\"\" if self . _transaction_started : raise RuntimeError ( \"Transaction already started\" ) if not self . _session_provided : self . session . start () assert self . session . session is not None self . _transaction_context = self . session . session . start_transaction () . __enter__ () self . _transaction_started = True","title":"start()"},{"location":"api_reference/session/#odmantic.engine.SyncSessionBase","text":"Source code in odmantic/session.py 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 class SyncSessionBase ( metaclass = ABCMeta ): engine : ODMEngine . SyncEngine def find ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , ) -> ODMEngine . SyncCursor [ ODMEngine . ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched Returns: [odmantic.engine.SyncCursor][] of the query \"\"\" return self . engine . find ( model , * queries , sort = sort , skip = skip , limit = limit , session = self . engine . _get_session ( self ), ) def find_one ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin sort : Optional [ Any ] = None , ) -> Optional [ ODMEngine . ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression Raises: DocumentParsingError: unable to parse the resulting document Returns: the fetched instance if found otherwise None <!--- #noqa: DAR402 DocumentParsingError --> \"\"\" return self . engine . find_one ( model , * queries , sort = sort , session = self . engine . _get_session ( self ) ) def count ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on *queries: query filters to apply Returns: number of document matching the query \"\"\" return self . engine . count ( model , * queries , session = self . engine . _get_session ( self ) ) def save ( self , instance : ODMEngine . ModelType , ) -> ODMEngine . ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist Returns: the saved instance NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. \"\"\" return self . engine . save ( instance , session = self . engine . _get_session ( self )) def save_all ( self , instances : Sequence [ ODMEngine . ModelType ], ) -> List [ ODMEngine . ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist Returns: the saved instances NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. \"\"\" return self . engine . save_all ( instances , session = self . engine . _get_session ( self )) def delete ( self , instance : ODMEngine . ModelType , ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete Raises: DocumentNotFoundError: the instance has not been persisted to the database <!--- #noqa: DAR402 DocumentNotFoundError #noqa: DAR201 --> \"\"\" return self . engine . delete ( instance , session = self . engine . _get_session ( self )) def remove ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], just_one : bool = False , ) -> int : \"\"\"Delete Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply just_one: limit the deletion to just one document Returns: the number of instances deleted from the database. \"\"\" return self . engine . remove ( model , * queries , just_one = just_one , session = self . engine . _get_session ( self ) )","title":"SyncSessionBase"},{"location":"api_reference/session/#odmantic.session.SyncSessionBase.count","text":"Get the count of documents matching a query Parameters: Name Type Description Default model Type [ ODMEngine . ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filters to apply () Returns: Type Description int number of document matching the query Source code in odmantic/session.py 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 def count ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], ) -> int : \"\"\"Get the count of documents matching a query Args: model: model to perform the operation on *queries: query filters to apply Returns: number of document matching the query \"\"\" return self . engine . count ( model , * queries , session = self . engine . _get_session ( self ) )","title":"count()"},{"location":"api_reference/session/#odmantic.session.SyncSessionBase.delete","text":"Delete an instance from the database Parameters: Name Type Description Default instance ODMEngine . ModelType the instance to delete required Raises: Type Description DocumentNotFoundError the instance has not been persisted to the database Source code in odmantic/session.py 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 def delete ( self , instance : ODMEngine . ModelType , ) -> None : \"\"\"Delete an instance from the database Args: instance: the instance to delete Raises: DocumentNotFoundError: the instance has not been persisted to the database <!--- #noqa: DAR402 DocumentNotFoundError #noqa: DAR201 --> \"\"\" return self . engine . delete ( instance , session = self . engine . _get_session ( self ))","title":"delete()"},{"location":"api_reference/session/#odmantic.session.SyncSessionBase.find","text":"Search for Model instances matching the query filter provided Parameters: Name Type Description Default model Type [ ODMEngine . ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () sort Optional [ Any ] sort expression None skip int number of document to skip 0 limit Optional [ int ] maximum number of instance fetched None Returns: Type Description ODMEngine . SyncCursor [ ODMEngine . ModelType ] odmantic.engine.SyncCursor of the query Source code in odmantic/session.py 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 def find ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators with mypy sort : Optional [ Any ] = None , skip : int = 0 , limit : Optional [ int ] = None , ) -> ODMEngine . SyncCursor [ ODMEngine . ModelType ]: \"\"\"Search for Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression skip: number of document to skip limit: maximum number of instance fetched Returns: [odmantic.engine.SyncCursor][] of the query \"\"\" return self . engine . find ( model , * queries , sort = sort , skip = skip , limit = limit , session = self . engine . _get_session ( self ), )","title":"find()"},{"location":"api_reference/session/#odmantic.session.SyncSessionBase.find_one","text":"Search for a Model instance matching the query filter provided Parameters: Name Type Description Default model Type [ ODMEngine . ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () sort Optional [ Any ] sort expression None Raises: Type Description DocumentParsingError unable to parse the resulting document Returns: Type Description Optional [ ODMEngine . ModelType ] the fetched instance if found otherwise None Source code in odmantic/session.py 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 def find_one ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], # bool: allow using binary operators w/o plugin sort : Optional [ Any ] = None , ) -> Optional [ ODMEngine . ModelType ]: \"\"\"Search for a Model instance matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply sort: sort expression Raises: DocumentParsingError: unable to parse the resulting document Returns: the fetched instance if found otherwise None <!--- #noqa: DAR402 DocumentParsingError --> \"\"\" return self . engine . find_one ( model , * queries , sort = sort , session = self . engine . _get_session ( self ) )","title":"find_one()"},{"location":"api_reference/session/#odmantic.session.SyncSessionBase.remove","text":"Delete Model instances matching the query filter provided Parameters: Name Type Description Default model Type [ ODMEngine . ModelType ] model to perform the operation on required *queries Union [ QueryExpression , Dict , bool ] query filter to apply () just_one bool limit the deletion to just one document False Returns: Type Description int the number of instances deleted from the database. Source code in odmantic/session.py 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 def remove ( self , model : Type [ ODMEngine . ModelType ], * queries : Union [ QueryExpression , Dict , bool ], just_one : bool = False , ) -> int : \"\"\"Delete Model instances matching the query filter provided Args: model: model to perform the operation on *queries: query filter to apply just_one: limit the deletion to just one document Returns: the number of instances deleted from the database. \"\"\" return self . engine . remove ( model , * queries , just_one = just_one , session = self . engine . _get_session ( self ) )","title":"remove()"},{"location":"api_reference/session/#odmantic.session.SyncSessionBase.save","text":"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Parameters: Name Type Description Default instance ODMEngine . ModelType instance to persist required Returns: Type Description ODMEngine . ModelType the saved instance NOTE The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. Source code in odmantic/session.py 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 def save ( self , instance : ODMEngine . ModelType , ) -> ODMEngine . ModelType : \"\"\"Persist an instance to the database This method behaves as an 'upsert' operation. If a document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be saved as well. Args: instance: instance to persist Returns: the saved instance NOTE: The save operation actually modify the instance argument in place. However, the instance is still returned for convenience. \"\"\" return self . engine . save ( instance , session = self . engine . _get_session ( self ))","title":"save()"},{"location":"api_reference/session/#odmantic.session.SyncSessionBase.save_all","text":"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Parameters: Name Type Description Default instances Sequence [ ODMEngine . ModelType ] instances to persist required Returns: Type Description List [ ODMEngine . ModelType ] the saved instances NOTE The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. Source code in odmantic/session.py 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 def save_all ( self , instances : Sequence [ ODMEngine . ModelType ], ) -> List [ ODMEngine . ModelType ]: \"\"\"Persist instances to the database This method behaves as multiple 'upsert' operations. If one of the document already exists with the same primary key, it will be overwritten. All the other models referenced by this instance will be recursively saved as well. Args: instances: instances to persist Returns: the saved instances NOTE: The save_all operation actually modify the arguments in place. However, the instances are still returned for convenience. \"\"\" return self . engine . save_all ( instances , session = self . engine . _get_session ( self ))","title":"save_all()"}]}